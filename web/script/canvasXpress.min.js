/*
 * CanvasXpress 6.3 - JavaScript Canvas Library
 *
 * Copyright (c) 2009-2010 Isaac Neuhaus
 *
 * imnphd@gmail.com
 *
 *
 * Redistributions of this source code must retain this copyright
 * notice and the following disclaimer.
 *
 * CanvasXpress is licensed under the terms of the Open Source
 * LGPL 3.0 license.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Commercial use is permitted to the extent that this source code
 * do NOT become part of any other Open Source or Commercially licensed
 * development library or toolkit without explicit permission.
 *
 * Network graphs were implemented based on the HeyGraph by Tom Martin
 * <http://www.heychinaski.com>.
 *
 * Thanks to Mingyi Liu for his contributions with the Ext-JS panel and
 * network graphs and Charles Tilford for his input to the Genome Browser.
 *
 */
function str_repeat(b, a) {
    for (var c = []; a > 0; c[--a] = b) {}
    return (c.join(""))
}
function sprintf() {
    var g = 0,
        e, h = arguments[g++],
        k = [],
        d, j, l, b;
    while (h) {
        if (d = /^[^\x25]+/.exec(h)) {
            k.push(d[0])
        } else {
            if (d = /^\x25{2}/.exec(h)) {
                k.push("%")
            } else {
                if (d = /^\x25(?:(\d+)\$)?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(h)) {
                    if (((e = arguments[d[1] || g++]) == null) || (e == undefined)) {
                        throw ("Too few arguments.")
                    }
                    if (/[^s]/.test(d[7]) && (typeof (e) != "number")) {
                        throw ("Expecting number but found " + typeof (e))
                    }
					switch (d[7]) {
                        case "b":
                            e = e.toString(2);
                            break;
                        case "c":
                            e = String.fromCharCode(e);
                            break;
                        case "d":
                            e = parseInt(e);
                            break;
                        case "e":
                            e = d[6] ? e.toExponential(d[6]) : e.toExponential();
                            break;
                        case "f":
							e = d[6] ? parseFloat(e).toFixed(d[6]) : parseFloat(e);
                            break;
                        case "o":
                            e = e.toString(8);
                            break;
                        case "s":
                            e = ((e = String(e)) && d[6] ? e.substring(0, d[6]) : e);
                            break;
                        case "u":
                            e = Math.abs(e);
                            break;
                        case "x":
                            e = e.toString(16);
                            break;
                        case "X":
                            e = e.toString(16).toUpperCase();
                            break
                    }
                    e = (/[def]/.test(d[7]) && d[2] && e > 0 ? "+" + e : e);
                    l = d[3] ? d[3] == "0" ? "0" : d[3].charAt(1) : " ";
                    b = d[5] - String(e).length;
                    j = d[5] ? str_repeat(l, b) : "";
                    k.push(d[4] ? e + j : j + e)
                } else {
                    throw ("Huh ?!")
                }
            }
        }
        h = h.substring(d[0].length)
    }
    return k.join("")
};
var dateFormat = function () {
    var a = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
        b = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
        d = /[^-+\dA-Z]/g,
        c = function (f, e) {
            f = String(f);
            e = e || 2;
            while (f.length < e) {
                f = "0" + f
            }
            return f
        };
    return function (i, v, q) {
        var g = dateFormat;
        if (arguments.length == 1 && Object.prototype.toString.call(i) == "[object String]" && !/\d/.test(i)) {
            v = i;
            i = undefined
        }
        i = i ? new Date(i) : new Date;
        if (isNaN(i)) {
            throw SyntaxError("invalid date")
        }
        v = String(g.masks[v] || v || g.masks["default"]);
        if (v.slice(0, 4) == "UTC:") {
            v = v.slice(4);
            q = true
        }
        var t = q ? "getUTC" : "get",
            l = i[t + "Date"](),
            e = i[t + "Day"](),
            j = i[t + "Month"](),
            p = i[t + "FullYear"](),
            r = i[t + "Hours"](),
            k = i[t + "Minutes"](),
            u = i[t + "Seconds"](),
            n = i[t + "Milliseconds"](),
            f = q ? 0 : i.getTimezoneOffset(),
            h = {
                d: l,
                dd: c(l),
                ddd: g.i18n.dayNames[e],
                dddd: g.i18n.dayNames[e + 7],
                m: j + 1,
                mm: c(j + 1),
                mmm: g.i18n.monthNames[j],
                mmmm: g.i18n.monthNames[j + 12],
                yy: String(p).slice(2),
                yyyy: p,
                h: r % 12 || 12,
                hh: c(r % 12 || 12),
                H: r,
                HH: c(r),
                M: k,
                MM: c(k),
                s: u,
                ss: c(u),
                l: c(n, 3),
                L: c(n > 99 ? Math.round(n / 10) : n),
                t: r < 12 ? "a" : "p",
                tt: r < 12 ? "am" : "pm",
                T: r < 12 ? "A" : "P",
                TT: r < 12 ? "AM" : "PM",
                Z: q ? "UTC" : (String(i).match(b) || [""]).pop().replace(d, ""),
                o: (f > 0 ? "-" : "+") + c(Math.floor(Math.abs(f) / 60) * 100 + Math.abs(f) % 60, 4),
                S: ["th", "st", "nd", "rd"][l % 10 > 3 ? 0 : (l % 100 - l % 10 != 10) * l % 10]
            };
        return v.replace(a, function (m) {
            return m in h ? h[m] : m.slice(1, m.length - 1)
        })
    }
}();
dateFormat.masks = {
    "default": "ddd mmm dd yyyy HH:MM:ss",
    shortDate: "m/d/yy",
    mediumDate: "mmm d, yyyy",
    longDate: "mmmm d, yyyy",
    fullDate: "dddd, mmmm d, yyyy",
    shortTime: "h:MM TT",
    mediumTime: "h:MM:ss TT",
    longTime: "h:MM:ss TT Z",
    isoDate: "yyyy-mm-dd",
    isoTime: "HH:MM:ss",
    isoDateTime: "yyyy-mm-dd'T'HH:MM:ss",
    isoUtcDateTime: "UTC:yyyy-mm-dd'T'HH:MM:ss'Z'"
};
dateFormat.i18n = {
    dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    monthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
Date.prototype.format = function (a, b) {
    return dateFormat(this, a, b)
};
if (typeof (CanvasXpress) == "undefined") {
    CanvasXpress = {}
}
var CanvasXpress = function (f, d, a, b, c, e) {
	
	this.$ = function (g) {
        return document.getElementById(g)
    };
    this.$cX = function (h, l, j) {
        var k = document.createElement(h);
        if (l) {
            for (var g in l) {
                k[g] = l[g]
            }
        }
        if (j) {
            for (var g in j) {
                k.style[g] = j[g]
            }
        }
        return k
    };
    this.setInit = function () {
        this.version = 6.3;
        this.target = f;
        this.events = b;
        this.info = e;
        this.startTime = new Date().getTime()
    };
    this.validateParameters = function () {
        this.validateData();
        this.validateConfig();
        this.validateEvents();
        this.validateInfo()
    };
    this.validateData = function () {
        if (d && !this.subBrowser) {
            try {
                JSON.stringify(d)
            } catch (g) {
                alert("Data object malformed:\n" + g)
            }
        }
    };
    this.validateConfig = function () {
        this.addConfigLocation();
        if (!a) {
            a = {}
        } else {
            if (!this.subBrowser) {
                try {
                    JSON.stringify(a)
                } catch (g) {
                    alert("Config object malformed:\n" + g)
                }
            }
        }
        this.userConfig = a
    };
    this.validateEvents = function () {};
    this.validateInfo = function () {
        if (!e) {
            e = ""
        }
    };
    this.addConfigLocation = function () {
        var n = window.location.href.split(/&/);
        if (n && n.length > 0) {
            for (var h = 0; h < n.length; h++) {
                var g = n[h].match(/canvasXpress=(\{.+\})/);
                if (g && g.length > 1) {
                    var m = decodeURIComponent(JSON.stringify(g[1]).replace(/^\"/, "").replace(/\"$/, ""));
                    var j;
                    try {
                        j = JSON.parse(m)
                    } catch (l) {
                        alert("Location parameters malformed:\n" + l)
                    }
                    if (j) {
                        if (!a) {
                            a = {}
                        }
                        for (var k in j) {
                            if (!a[k]) {
                                a[k] = j[k]
                            }
                        }
                    }
                }
            }
        }
    };
    this.newId = function (h) {
        var k = 0;
        var g = this.target + h + k;
        var j = this.$(g);
        while (j) {
            k++;
            g = this.target + h + k;
            j = this.$(g)
        }
        return g
    };
    this.createNewTarget = function () {
        var g = this.$cX("canvas", {
            id: this.newId("canvasXpress")
        });
        document.body.appendChild(g);
        return g.id
    };
    this.insertTarget = function (j, l, i, k, g) {
        if (j && l) {
            var m = this.$(j);
            if (m) {
                return
            } else {
                m = this.$cX("canvas", {
                    id: j,
                    width: i,
                    height: k
                })
            }
            if (g) {
                l.parentNode.insertBefore(m, l.nextSibling)
            } else {
                l.parentNode.insertBefore(m, l)
            }
        }
    };
    this.removeTarget = function (g) {
        var h = this.$(g);
        if (h) {
            h.parentNode.removeChild(h)
        }
    };
    this.save = function () {
        return {
            renderTo: this.target,
            data: this.data,
            config: this.getConfig(),
            events: this.events
        }
    };
    this.print = function (g) {
        return function (h) {
            g.resetConfigurator();
            alert("A new window will open so you can right click on the graph and save it");
            if (g.isIE) {
                var j = g.canvas.parentNode.childNodes[0];
                return window.open().document.write("<html><body>" + j.innerHTML + "</body></html>")
            } else {
                var i = g.canvas.toDataURL("image/png");
                return window.open().document.write('<html><body><img src="' + i + '" /></body></html>')
            }
        }
    }(this);
    this.exportToExcel = function (j) {
        var h = "";
        for (var g = 0; g < j.length; g++) {
            h += j[g].join("%09") + "%0D"
        }
        return window.open("data:text/tab-separeted-values," + h)
    };
    this.exporttoHTML = function (j) {
        var h = "<table>";
        for (var g = 0; g < j.length; g++) {
            h += "<tr><td>";
            h += j[g].join("</td><td>");
            h += "</td></tr>"
        }
        h += "</table>";
        return window.open().document.write(h)
    };
    this.prettyJSON = function (g, p) {
        var q = function (i) {
            if (typeof (i) == "object") {
                if (i === null) {
                    return "null"
                }
                if (i.constructor == (new Array).constructor) {
                    return "array"
                }
                if (i.constructor == (new Date).constructor) {
                    return "date"
                }
                if (i.constructor == (new RegExp).constructor) {
                    return "regex"
                }
                return "object"
            }
            return typeof (i)
        };
        if (!p) {
            p = ""
        }
        var r;
        var m = "  ";
        var h = q(g);
        var j = 0;
        if (h == "array") {
            if (g.length == 0) {
                return "[]"
            }
            r = "["
        } else {
            for (var n in g) {
                j++;
                break
            }
            if (j == 0) {
                return "{}"
            }
            r = "{"
        }
        j = 0;
        for (var l in g) {
            v = g[l];
            if (j > 0) {
                r += ","
            }
            if (h == "array") {
                r += ("\n" + p + m)
            } else {
                r += ("\n" + p + m + '"' + l + '": ')
            }
            switch (q(v)) {
                case "array":
                case "object":
                    r += this.prettyJSON(v, (p + m));
                    break;
                case "boolean":
                case "number":
                    r += v.toString();
                    break;
                case "null":
                    r += "null";
                    break;
                case "string":
                    r += ('"' + v + '"');
                    break;
                default:
                    r += ("TYPEOF: " + typeof (v))
            }
            j++
        }
        if (h == "array") {
            r += ("\n" + p + "]")
        } else {
            r += ("\n" + p + "}")
        }
        return r
    };
    this.dumpToConsole = function (g) {
        console.log(this.target);
        console.log(this.prettyJSON(g))
    };
    this.profile = function (i) {
        var g = new Date().getTime();
        var h = this.profileTime || this.startTime;
        if (!i) {
            i = ""
        }
        console.log(this.target + ": " + i + ": " + (g - h));
        this.profileTime = g
    };
    this.stack = function () {
        if (this.debug) {
            for (var g in this) {
                if (arguments.callee.caller === this[g]) {
                    CanvasXpress.stack[this.target].push(g);
                    return
                }
            }
        }
    };
    this.initialize = function () {
        this.initCSS();
        this.setInit();
        this.initCrossBrowser();
        this.validateParameters();
        this.initConfig(a);
        this.initViewport(c);
        this.initUtils();
        this.initPrimitives();
        this.initExample();
        this.initData(d);
        this.initLayout();
        this.initEvents();
        this.initAnimation();
        this.initRemote();
        this.initGraph();
        this.showToolbar(true)
    };
    this.initialize();
    CanvasXpress.references.push(this);
    CanvasXpress.stack[this.target] = []
};
CanvasXpress.references = [];
CanvasXpress.cacheImages = {};
CanvasXpress.cacheText = {};
CanvasXpress.stack = {};
CanvasXpress.current = false;
CanvasXpress.resizing = false;
CanvasXpress.getObject = function (b) {
    for (var a = 0; a < CanvasXpress.references.length; a++) {
        if (CanvasXpress.references[a].target == b) {
            return CanvasXpress.references[a]
        }
    }
};
CanvasXpress.prototype.initCrossBrowser = function () {
    this.hasClass = function (a, b) {
        return new RegExp("(\\s|^)" + b + "(\\s|$)").test(a.className)
    };
    this.addClass = function (a, b) {
        if (!hasClass(a, b)) {
            a.className += (a.className ? " " : "") + b
        }
    };
    this.removeClass = function (a, b) {
        if (hasClass(a, b)) {
            a.className = a.className.replace(new RegExp("(\\s|^)" + b + "(\\s|$)"), " ").replace(/^\s+|\s+$/g, "")
        }
    };
    this.cancelEvent = function (a) {
        if (!a) {
            a = window.event
        }
        if (a.preventDefault) {
            a.preventDefault()
        } else {
            a.returnValue = true
        }
    };
    this.stopEvent = function (a) {
        if (!a) {
            a = window.event
        }
        if (a.stopPropagation) {
            a.stopPropagation()
        } else {
            a.cancelBubble = true
        }
    };
    this.normalizeEvtName = function (a) {
        return this.isIE ? "on" + a : a
    };
    this.addEvtListener = function (d, b, g, a) {
        if (b && g) {
            if (this.isIE) {
                d.attachEvent(this.normalizeEvtName(b), g)
            } else {
                d.addEventListener(b, g, a);
                if (b == "mousewheel") {
                    d.addEventListener("DOMMouseScroll", g, a)
                }
            }
        }
    };
    this.removeEvtListener = function (d, b, g, a) {
        if (b && g) {
            if (this.isIE) {
                d.detachEvent(this.normalizeEvtName(b), g)
            } else {
                d.removeEventListener(b, g, a);
                if (b == "mousewheel") {
                    d.removeEventListener("DOMMouseScroll", g, a)
                }
            }
        }
    };
    this.preventSelection = function () {
        if (document.selection) {
            document.selection.empty()
        } else {
            if (window.getSelection) {
                window.getSelection().removeAllRanges()
            }
        }
    };
    this.getTargetEvent = function (a) {
        return a.target || a.srcElement
    };
    this.isGoogleChromeFrame = function () {
        if (this.browser == "Explorer" && this.browserVersion < 9) {
            if (navigator.userAgent.toLowerCase().indexOf("chromeframe") < 0) {
                try {
                    var b = document.createElement("script");
                    b.type = "text/javascript";
                    b.src = "http://ajax.googleapis.com/ajax/libs/chrome-frame/1/CFInstall.min.js";
                    document.getElementsByTagName("head")[0].appendChild(b);
                    CFInstall.check({
                        mode: "overlay"
                    })
                } catch (a) {
                    alert("CanvasXpress works much faster in fully HTML 5 compliant browsers.\nPlease consider installing Google chrome frame to make this browser compliant.")
                }
            }
        }
    };
    this.dataBrowser = [{
        string: navigator.platform,
        subString: "iPhone",
        identity: "iPhone"
    }, {
        string: navigator.platform,
        subString: "iPod",
        identity: "iPod"
    }, {
        string: navigator.userAgent,
        subString: "iPad",
        identity: "iPad"
    }, {
        string: navigator.userAgent,
        subString: "Android",
        identity: "Android"
    }, {
        string: navigator.userAgent,
        subString: "BlackBerry",
        identity: "BlackBerry"
    }, {
        string: navigator.userAgent,
        subString: "Chrome",
        identity: "Chrome"
    }, {
        string: navigator.userAgent,
        subString: "OmniWeb",
        versionSearch: "OmniWeb/",
        identity: "OmniWeb"
    }, {
        string: navigator.vendor,
        subString: "Apple",
        identity: "Safari",
        versionSearch: "Version"
    }, {
        prop: window.opera,
        identity: "Opera"
    }, {
        string: navigator.vendor,
        subString: "iCab",
        identity: "iCab"
    }, {
        string: navigator.vendor,
        subString: "KDE",
        identity: "Konqueror"
    }, {
        string: navigator.userAgent,
        subString: "Firefox",
        identity: "Firefox"
    }, {
        string: navigator.vendor,
        subString: "Camino",
        identity: "Camino"
    }, {
        string: navigator.userAgent,
        subString: "Netscape",
        identity: "Netscape"
    }, {
        string: navigator.userAgent,
        subString: "MSIE",
        identity: "Explorer",
        versionSearch: "MSIE"
    }, {
        string: navigator.userAgent,
        subString: "Gecko",
        identity: "Mozilla",
        versionSearch: "rv"
    }, {
        string: navigator.userAgent,
        subString: "Mozilla",
        identity: "Netscape",
        versionSearch: "Mozilla"
    }];
    this.dataOS = [{
        string: navigator.platform,
        subString: "Win",
        identity: "Windows"
    }, {
        string: navigator.platform,
        subString: "Mac",
        identity: "Mac"
    }, {
        string: navigator.platform,
        subString: "iPhone",
        identity: "iPhone"
    }, {
        string: navigator.platform,
        subString: "iPod",
        identity: "iPod"
    }, {
        string: navigator.userAgent,
        subString: "iPad",
        identity: "iPad"
    }, {
        string: navigator.userAgent,
        subString: "Android",
        identity: "Android"
    }, {
        string: navigator.userAgent,
        subString: "BlackBerry",
        identity: "BlackBerry"
    }, {
        string: navigator.platform,
        subString: "Linux",
        identity: "Linux"
    }];
    this.isSubstandardBrowser = function () {
        if ((this.browser == "Firefox" && this.browserVersion > 4) || (this.browser == "Opera" && this.browserVersion > 9) || (this.browser == "Safari" && this.browserVersion > 4) || (this.browser == "Chrome" && this.browserVersion > 1)) {
            return false
        } else {
            return true
        }
    };
    this.isMobileApp = function () {
        if (this.browser.match(/iPhone|iPod|iPad|Android|BlackBerry/i)) {
            return true
        } else {
            return false
        }
    };
    this.searchString = function (d) {
        for (var a = 0; a < d.length; a++) {
            var b = d[a].string;
            var c = d[a].prop;
            this.versionSearchString = d[a].versionSearch || d[a].identity;
            if (b) {
                if (b.indexOf(d[a].subString) != -1) {
                    return d[a].identity
                }
            } else {
                if (c) {
                    return d[a].identity
                }
            }
        }
    };
    this.searchVersion = function (b) {
        var a = b.indexOf(this.versionSearchString);
        if (a == -1) {
            return
        }
        return parseFloat(b.substring(a + this.versionSearchString.length + 1))
    };
    this.initializeBrowser = function () {
        this.browser = this.searchString(this.dataBrowser) || "An unknown browser";
        this.browserVersion = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || "an unknown version";
        this.browserOS = this.searchString(this.dataOS) || "an unknown OS";
        if (this.browser == "Explorer") {
            this.isIE = true;
            this.subBrowser = true;
            this.mobileApp = false;
            if (this.browserVersion >= 9) {
                this.isVML = false
            } else {
                if (navigator.userAgent.toLowerCase().indexOf("chromeframe") < 0) {
                    this.isVML = true
                } else {
                    this.isVML = false
                }
            }
        } else {
            this.isIE = false;
            this.subBrowser = this.isSubstandardBrowser();
            this.mobileApp = this.isMobileApp();
            this.isVML = false
        }
        this.isGoogleChromeFrame()
    };
    this.initializeBrowser()
};
CanvasXpress.prototype.initCSS = function () {
    var a = " table.shorts {margin: 2px 3px; padding: 2px 3px; border: 1px solid #fafafa; border-collapse: collapse; font-size: x-small}";
    a += " td.k {text-align: center; padding: 2px 5px; margin: 2px 5px; border: 1px solid #cccccc;}";
    a += " td.d {padding: 2px 5px; margin: 2px 5px; border: 1px solid #cccccc;}";
    a += " th.d {padding: 2px 5px; margin: 2px 5px; border: 1px solid #cccccc;}";
    a += " th.cxx, th.cxz, th.cxb, th.cxs, th.cxv, td.cxx, td.cxz, td.cxb, td.cxs, td.cxv {border: 1px solid #cccccc; valign: center;}";
    a += " td.cxx, td.cxz, td.cxb, td.cxs, td.cxv {background: #fefefe}";
    a += " td.cxy {border: 1px solid #cccccc; valign: center; text-align: right;}";
    a += " div.cxc {left: 0px; top: 0px; margin-left: 5px; margin-top: 2px; white-space: nowrap; overflow: hidden;}";
    a += " div.accordionHead {margin-Top: 2px; height: 16px; overflow: hidden; float: left; cursor: pointer; vertical-align: middle; text-align: left; display:table-cell; -moz-user-select: none; -khtml-user-select: none; -webkit-user-select: none; -o-user-select: none; -user-select: none;}";
    a += " div.accordionContent {overflow: auto;}";
    a += " div.hoverable:hover {background-color: #dfe8f6}";
    a += " div.CanvasXpressContainer {position: relative; float: left;}";
    a += " div.CanvasXpressHandler {position: relative; float: left; background-position: 50% 50%; background-repeat: no-repeat;}";
    a += " div.CanvasXpressWrapper {position: relative; float: left; line-height: 100%;}";
    a += " div.CanvasXpressMenu {background-image: url(http://www.canvasxpress.org/images/menu.gif); background-repeat: repeat-y; border-radius: 3px; position: absolute; cursor: default;}";
    a += " ul.CanvasXpressList {padding 2px; background transparent; overflow: hidden}";
    a += " li {line-height: 100%; font: normal 11px arial,tahoma,sans-serif; white-space: nowrap;}";
    a += " li.CanvasXpressListItem {padding: 1px;}";
    a += " li.CanvasXpressListItemActive {background-color: #dbecf4; background-image: url(http://www.canvasxpress.org/images/item-over.gif); border-color: #aaccf6; background-repeat: repeat-x; background-position: left bottom; border-style: solid; border-width: 1px 0px; margin: 0px 1px; padding: 0px;}";
    a += " a.CanvasXpressListItemA {cursor: pointer; line-height: 16px; padding: 3px 21px 3px 27px; position: relative; text-decoration: none; white-space: nowrap; color: #222222}";
    a += " a.CanvasXpressListItemAActive {border-color: #aaccf6; border-style: solid; border-width: 0px 1px; margin: 0px -1px; cursor: pointer; line-height: 16px; padding : 3px 21px 3px 27px; position: relative; text-decoration: none; white-space: nowrap;}";
    a += " img.CanvasXpressListIcon {left: 3px; top: 3px; height: 13px; width 13px; vertical-align: top; position: absolute; background-position: center;}";
    a += " s.CanvasXpressListItemText {cursor: pointer; line-height: 16px; white-space: nowrap; color: #222222}";
    a += " canvas.CanvasXpress {-moz-user-select: none; -khtml-user-select: none; -webkit-user-select: none; -o-user-select: none; -user-select: none;}";
    var b = document.createElement("style");
    b.type = "text/css";
    if (b.styleSheet) {
        b.styleSheet.cssText = a
    } else {
        b.appendChild(document.createTextNode(a))
    }
    document.getElementsByTagName("head")[0].appendChild(b)
};
CanvasXpress.prototype.initConfig = function (a) {
    this.setConfigDefaults = function () {
        this.config = [];
        this.graphType = "Bar";
        this.config.push("graphType");
        this.graphOrientation = "horizontal";
        this.config.push("graphOrientation");
        this.foreground = "rgb(0,0,0)";
        this.config.push("foreground");
        this.foregroundWindow = "rgb(0,0,0)";
        this.config.push("foregroundWindow");
        this.background = "rgb(255,255,255)";
        this.config.push("background");
        this.backgroundWindow = "rgb(204,204,204)";
        this.config.push("backgroundWindow");
        this.backgroundType = "solid";
        this.config.push("backgroundType");
        this.backgroundImage = false;
        this.config.push("backgroundImage");
        this.gradientOrientation = "vertical";
        this.config.push("gradientOrientation");
        this.backgroundWindowGradientOrientation = "vertical";
        this.config.push("backgroundWindowGradientOrientation");
        this.backgroundGradient1Color = "rgb(0,0,200)";
        this.config.push("backgroundGradient1Color");
        this.backgroundGradient2Color = "rgb(0,0,36)";
        this.config.push("backgroundGradient2Color");
        this.backgroundWindowGradient1Color = "rgb(0,0,200)";
        this.config.push("backgroundWindowGradient1Color");
        this.backgroundWindowGradient2Color = "rgb(0,0,36)";
        this.config.push("backgroundWindowGradient2Color");
        this.gradient = false;
        this.config.push("gradient");
        this.gradientType = "radial";
        this.config.push("gradientType");
        this.gradientRatio = 1.3;
        this.config.push("gradientRatio");
        this.transparency = null;
        this.config.push("transparency");
        this.margin = 5;
        this.config.push("margin");
        this.marginLeft = 20;
        this.config.push("marginLeft");
        this.marginTop = 20;
        this.config.push("marginTop");
        this.marginBottom = 20;
        this.config.push("marginBottom");
        this.marginRight = 20;
        this.config.push("marginRight");
        this.showShadow = false;
        this.config.push("showShadow");
        this.shadowOffsetX = 3;
        this.config.push("shadowOffsetX");
        this.shadowOffsetY = 3;
        this.config.push("shadowOffsetY");
        this.shadowBlur = 2;
        this.config.push("shadowBlur");
        this.shadowColor = "rgba(0,0,0,0.5)";
        this.config.push("shadowColor");
        this.canvasBox = true;
        this.config.push("canvasBox");
        this.canvasBoxColor = "rgb(204,204,204)";
        this.config.push("canvasBoxColor");
        this.autoAdjust = true;
        this.config.push("autoAdjust");
        this.autoAdjustYTries = 0;
        this.autoAdjustXTries = 0;
        this.autoAdjustMax = 3;
        this.config.push("autoAdjustMax");
        this.acknowledgment = false;
        this.config.push("acknowledgment");
        this.acknowledgementIcon = "cx.png";
        this.config.push("acknowledgmentIcon");
        this.acknowledgementIconPosition = "outside";
        this.config.push("acknowledgmentIconPosition");
        this.functions = [];
        this.fonts = this.isVML || this.subBrowser ? ["Gentilis", "Helvetiker", "Optimer"] : ["Gentilis", "Helvetiker", "Optimer", "Verdana, sans-serif"];
        this.fontName = this.isVML ? "Gentilis" : this.subBrowser ? "Optimer" : "Verdana, sans-serif";
        this.config.push("fontName");
        this.fontStyle = false;
        this.config.push("fontStyle");
        this.fontSize = 12;
        this.config.push("fontSize");
        this.font = this.fontStyle ? this.fontStyle + this.fontSize + "pt " + this.fontName : this.fontSize + "pt " + this.fontName;
        this.align = "center";
        this.config.push("align");
        this.baseline = "middle";
        this.config.push("baseline");
        this.maxTextSize = 14;
        this.config.push("maxTextSize");
        this.minTextSize = 4;
        this.config.push("minTextSize");
        this.autoScaleFont = true;
        this.config.push("autoScaleFont");
        this.scaleTextConstantMult = 40;
        this.scaleTextConstantAdd = 2.5;
        this.title = false;
        this.config.push("title");
        this.titleHeight = 30;
        this.config.push("titleHeight");
        this.titleColor = "rgb(0,0,0)";
        this.config.push("titleColor");
        this.subtitle = false;
        this.config.push("subtitle");
        this.subtitleHeight = 16;
        this.config.push("subtitleHeight");
        this.subtitleColor = "rgb(0,0,0)";
        this.config.push("subtitleColor");
        this.citation = false;
        this.config.push("citation");
        this.citationColor = "rgb(0,0,0)";
        this.config.push("citationColor");
        this.citationFontSize = 6;
        this.config.push("citationSize");
        this.citationFont = (this.citationFontSize) + "Pt " + this.fontName;
        this.citationScaleFontFactor = 1;
        this.config.push("citationScaleFontFactor");
        this.dashLength = 8;
        this.config.push("dashLength");
        this.dotLength = 1;
        this.config.push("dotLength");
        this.arrowPointSize = 10;
        this.config.push("arrowPointSize");
        this.capType = "butt";
        this.config.push("capType");
        this.outlineWidth = 1;
        this.config.push("outlineWidth");
        this.lines = [];
        this.colorScheme = "user";
        this.config.push("colorScheme");
        this.colors0 = ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(0,255,0)", "rgb(255,255,0)", "rgb(0,255,255)", "rgb(255,0,255)", "rgb(153,51,0)", "rgb(0,0,128)", "rgb(128,128,0)", "rgb(255,102,0)", "rgb(0,128,128)", "rgb(102,0,102)", "rgb(255,153,204)", "rgb(102,102,153)", "rgb(51,51,0)", "rgb(255,204,153)", "rgb(204,255,255)", "rgb(153,153,255)", "rgb(255,128,128)", "rgb(51,102,255)", "rgb(51,153,102)", "rgb(255,204,0)", "rgb(0,204,255)", "rgb(208,32,144)", "rgb(153,51,102)", "rgb(0,102,204)", "rgb(153,204,0)", "rgb(255,153,0)", "rgb(51,204,204)", "rgb(204,153,255)", "rgb(128,0,0)", "rgb(51,51,153)", "rgb(0,128,0)", "rgb(255,255,204)", "rgb(153,204,255)", "rgb(128,0,128)"];
        this.colors1 = ["rgb(0,0,255)", "rgb(255,0,77)", "rgb(255,191,0)", "rgb(116,255,0)", "rgb(164,0,255)", "rgb(255,116,0)", "rgb(255,255,0)", "rgb(0,255,255)", "rgb(255,0,0)", "rgb(255,211,0)", "rgb(61,0,255)", "rgb(0,255,0)", "rgb(255,0,255)", "rgb(255,146,0)", "rgb(211,255,0)", "rgb(0,144,255)", "rgb(109,0,255)", "rgb(255,73,0)", "rgb(255,232,0)", "rgb(0,255,146)", "rgb(255,0,144)", "rgb(255,170,0)", "rgb(170,255,0)", "rgb(0,77,255)"];
        this.colors2 = ["rgb(60,60,157)", "rgb(157,60,90)", "rgb(157,133,60)", "rgb(104,157,60)", "rgb(122,60,157)", "rgb(157,104,60)", "rgb(157,157,60)", "rgb(60,157,157)", "rgb(157,60,60)", "rgb(157,140,60)", "rgb(83,60,157)", "rgb(60,157,60)", "rgb(157,60,157)", "rgb(157,115,60)", "rgb(140,157,60)", "rgb(60,115,157)", "rgb(102,60,157)", "rgb(157,88,60)", "rgb(157,148,60)", "rgb(60,157,115)", "rgb(157,60,115)", "rgb(157,125,60)", "rgb(125,157,60)", "rgb(60,90,157)"];
        this.colors3 = ["rgb(0,0,117)", "rgb(117,0,36)", "rgb(117,88,0)", "rgb(53,117,0)", "rgb(76,0,117)", "rgb(117,53,0)", "rgb(117,117,0)", "rgb(0,117,117)", "rgb(117,0,0)", "rgb(117,97,0)", "rgb(28,0,117)", "rgb(0,117,0)", "rgb(117,0,117)", "rgb(117,67,0)", "rgb(97,117,0)", "rgb(0,66,117)", "rgb(50,0,117)", "rgb(117,33,0)", "rgb(117,107,0)", "rgb(0,117,67)", "rgb(117,0,66)", "rgb(117,78,0)", "rgb(78,117,0)", "rgb(0,36,117)"];
        this.colors4 = ["rgb(101,101,255)", "rgb(255,101,147)", "rgb(255,216,101)", "rgb(171,255,101)", "rgb(200,101,255)", "rgb(255,171,101)", "rgb(255,255,101)", "rgb(101,255,255)", "rgb(255,101,101)", "rgb(255,229,101)", "rgb(137,101,255)", "rgb(101,255,101)", "rgb(255,101,255)", "rgb(255,189,101)", "rgb(229,255,101)", "rgb(101,188,255)", "rgb(167,101,255)", "rgb(255,145,101)", "rgb(255,241,101)", "rgb(101,255,189)", "rgb(255,101,188)", "rgb(255,204,101)", "rgb(204,255,101)", "rgb(101,147,255)"];
        this.colors5 = ["rgb(181,181,255)", "rgb(255,181,203)", "rgb(255,237,181)", "rgb(215,255,181)", "rgb(229,181,255)", "rgb(255,215,181)", "rgb(255,255,181)", "rgb(181,255,255)", "rgb(255,181,181)", "rgb(255,242,181)", "rgb(199,181,255)", "rgb(181,255,181)", "rgb(255,181,255)", "rgb(255,223,181)", "rgb(242,255,181)", "rgb(181,223,255)", "rgb(213,181,255)", "rgb(255,202,181)", "rgb(255,248,181)", "rgb(181,255,223)", "rgb(255,181,223)", "rgb(255,230,181)", "rgb(230,255,181)", "rgb(181,203,255)"];
        this.colors6 = ["rgb(254,41,108)", "rgb(72,126,182)", "rgb(167,206,49)", "rgb(248,204,3)", "rgb(255,140,2)", "rgb(105,150,150)", "rgb(183,120,68)", "rgb(131,172,208)", "rgb(194,224,118)", "rgb(250,220,90)", "rgb(255,84,159)", "rgb(255,175,84)", "rgb(154,184,183)", "rgb(210,166,131)", "rgb(61,105,155)", "rgb(135,172,34)", "rgb(205,169,8)", "rgb(208,33,88)", "rgb(208,115,0)", "rgb(86,118,118)"];
		
	    this.colors = this.colors6;
        this.config.push("colors");
        this.colorHSV = [0, 0, 1];
        this.colorRGB = [1, 1, 1];
        this.shapes = ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"];
        this.config.push("shapes");
        this.sizes = [4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34];
        this.config.push("sizes");
        this.images = [];
        this.config.push("images");
        this.timeFormat = "isoDate";
        this.config.push("timeFormat");
        this.oddColor = this.background;
        this.config.push("oddColor");
        this.evenColor = "rgb(240,240,240)";
        this.config.push("evenColor");
        this.maxSmpStringLen = 50;
        this.config.push("maxSmpStringLen");
        this.smpLabelDescription = false;
        this.config.push("smpLabelDescription");
        this.smpTitle = false;
        this.config.push("smpTitle");
        this.smpTitleFontSize = 10;
        this.config.push("smpTitleFontSize");
        this.smpTitleFont = (this.smpTitleFontSize) + "Pt " + this.fontName;
        this.smpTitleColor = this.foreground;
        this.config.push("smpTitleColor");
        this.smpTitleScaleFontFactor = 1;
        this.config.push("smpTitleScaleFontFactor");
        this.smpLabelFontSize = 10;
        this.config.push("smpLabelFontSize");
        this.smpLabelFont = (this.smpLabelFontSize) + "Pt " + this.fontName;
        this.smpLabelColor = this.foreground;
        this.config.push("smpLabelColor");
        this.smpLabelScaleFontFactor = 1;
        this.config.push("smpLabelScaleFontFactor");
        this.smpLabelRotate = 0;
        this.config.push("smpLabelRotate");
        this.smpLabelInterval = 1;
        this.config.push("smpLabelInterval");
        this.showSampleNames = true;
        this.config.push("showSampleNames");
        this.smpLabelCircular = false;
        this.config.push("smpLabelCircular");
        this.highlightSmp = [];
        this.config.push("highlightSmp");
        this.smpHighlightColor = "rgb(255,0,0)";
        this.config.push("smpHighlightColor");
        this.filterSmpBy = [];
        this.config.push("filterSmpBy");
        this.filterSmpByOp = [];
        this.filterSmpByValue = [];
        this.filterSmpByCase = [];
        this.filteredSmpIndices = [];
        this.maxVarStringLen = 30;
        this.config.push("maxVarStringLen");
        this.varLabelDescription = false;
        this.config.push("varLabelDescription");
        this.varTitle = false;
        this.config.push("varTitle");
        this.varTitleFontSize = 10;
        this.config.push("varTitleFontSize");
        this.varTitleFont = (this.varTitleFontSize) + "Pt " + this.fontName;
        this.varTitleColor = this.foreground;
        this.config.push("varTitleColor");
        this.varTitleScaleFontFactor = 1;
        this.config.push("varTitleScaleFontFactor");
        this.varLabelFontSize = 10;
        this.config.push("varLabelFontSize");
        this.varLabelFont = (this.varLabelFontSize) + "Pt " + this.fontName;
        this.varLabelColor = this.foreground;
        this.config.push("varLabelColor");
        this.varLabelScaleFontFactor = 1;
        this.config.push("varLabelScaleFontFactor");
        this.varLabelRotate = 0;
        this.config.push("varLabelRotate");
        this.varLabelInterval = 1;
        this.config.push("varLabelInterval");
        this.showVariableNames = true;
        this.config.push("showVariableNames");
        this.varTitleLabelOverlayPosition = "bottom";
        this.config.push("varTitleLabelOverlayPosition");
        this.highlightVar = [];
        this.config.push("highlightVar");
        this.varHighlightColor = "rgb(255,0,0)";
        this.config.push("varHighlightColor");
        this.filterVarBy = [];
        this.config.push("filterVarBy");
        this.filterVarByOp = [];
        this.filterVarByValue = [];
        this.filterVarByCase = [];
        this.filteredVarIndices = [];
        this.overlaysWidth = 30;
        this.config.push("overlaysWidth");
        this.smpOverlays = [];
        this.config.push("smpOverlays");
        this.varOverlays = [];
        this.config.push("varOverlays");
        this.showOverlays = true;
        this.config.push("showOverlays");
        this.showLevelOverlays = false;
        this.config.push("showLevelOverlays");
        this.overlayFontSize = 6;
        this.config.push("overlayFontSize");
        this.overlayFont = (this.overlayFontSize) + "Pt " + this.fontName;
        this.overlayFontColor = this.foreground;
        this.config.push("overlayFontColor");
        this.overlayScaleFontFactor = 1;
        this.config.push("overlayScaleFontFactor");
        this.smpOverlayRecycleColors = false;
        this.config.push("smpOverlayRecycleColors");
        this.varOverlayRecycleColors = false;
        this.config.push("varOverlayRecycleColors");
        this.showLegend = true;
        this.config.push("showLegend");
        this.legendPosition = "right";
        this.config.push("legendPosition");
        this.legendColor = this.foreground;
        this.config.push("legendColor");
        this.legendBox = true;
        this.config.push("legendBox");
        this.legendBoxColor = "rgb(204,204,204)";
        this.config.push("legendBoxColor");
        this.legendBackgroundColor = this.background;
        this.config.push("legendBackgroundColor");
        this.legendFontSize = 10;
        this.config.push("legendFontSize");
        this.legendFont = (this.legendFontSize) + "Pt " + this.fontName;
        this.legendScaleFontFactor = 1;
        this.config.push("legendScaleFontFactor");
        this.showIndicators = true;
        this.config.push("showIndicators");
        this.indicatorsPosition = "bottom";
        this.config.push("indicatorsPosition");
        this.showDecorations = false;
        this.config.push("showDecorations");
        this.decorationsPosition = "bottom";
        this.config.push("decorationsPosition");
        this.decorationsColor = this.foreground;
        this.config.push("decorationsColor");
        this.decorationFontSize = 10;
        this.config.push("decorationFontSize");
        this.decorationFont = (this.decorationFontSize) + "Pt " + this.fontName;
        this.decorationScaleFontFactor = 1;
        this.config.push("decorationScaleFontFactor");
        this.decorationsWidth = 10;
        this.config.push("decorationsWidth");
        this.decorationsHeight = 20;
        this.config.push("decorationsHeight");
        this.decorationsType = "bar";
        this.config.push("decorationsType");
        this.decorations = [];
        this.config.push("decorations");
        this.decorationsColors = [];
        this.config.push("decorationsColors");
        this.decorationsProperties = {};
        this.config.push("decorationsProperties");
        this.axisTickColor = this.foreground;
        this.config.push("axisTickColor");
        this.axisTickFontSize = 10;
        this.config.push("axisTickFontSize");
        this.axisTickFont = (this.axisTickFontSize) + "Pt " + this.fontName;
        this.tickScaleFontFactor = 1;
        this.config.push("tickScaleFontFactor");
        this.tickRotate = 0;
        this.config.push("tickRotate");
        this.axisTitleColor = this.foreground;
        this.config.push("axisTitleColor");
        this.axisTitleFontSize = 10;
        this.config.push("axisTitleFontSize");
        this.axisTitleFont = (this.axisTitleFontSize) + "Pt " + this.fontName;
        this.axisTitleScaleFontFactor = 1;
        this.config.push("axisTitleScaleFontFactor");
        this.isGroupedData = false;
        this.isTransformedData = false;
        this.isBoxPlotCalc = false;
        this.isMarketDataFormated = false;
        this.isMarketSwitched = false;
        this.isGraphTime = false;
        this.config.push("isGraphTime");
        this.groupingFactors = [];
        this.config.push("groupingFactors");
        this.segregateSamplesBy = false;
        this.config.push("segregateSamplesBy");
        this.segregateVariablesBy = false;
        this.config.push("segregateVariablesBy");
        this.isLogData = false;
        this.config.push("isLogData");
        this.smpSort = -1;
        this.varSort = -1;
        this.tmpAsciiArray = [];
        this.sortDir = "ascending";
        this.config.push("sortDir");
        this.transformBase = 2;
        this.config.push("transformBase");
        this.transformType = false;
        this.config.push("transformType");
        this.ratioReference = 0;
        this.config.push("ratioReference");
        this.zscoreAxis = "samples";
        this.config.push("zscoreAxis");
        this.showErrorBars = true;
        this.config.push("showErrorBars");
        this.randomData = false;
        this.config.push("randomData");
        this.randomDataMean = 100;
        this.config.push("randomDataMean");
        this.randomDataSigma = 50;
        this.config.push("randomDataSigma");
        this.randomDataVariables = 6;
        this.config.push("randomDataVariables");
        this.randomDataSamples = 12;
        this.config.push("randomDataSamples");
        this.randomDataVariableAnnotations = 2;
        this.config.push("randomDataVariableAnnotations");
        this.randomDataSampleAnnotations = 3;
        this.config.push("randomDataSampleAnnotations");
        this.randomDataVariableAnnotationRatio = 2;
        this.config.push("randomDataVariableAnnotationRatio");
        this.randomDataSampleAnnotationRatio = 2;
        this.config.push("randomDataSampleAnnotationRatio");
        this.randomMissingDataPercentage = 0;
        this.config.push("randomMissingDataPercentage");
        this.missingDataColor = "rgb(255,255,0)";
        this.config.push("missingDataColor");
        this.zoom = 1;
        this.config.push("zoom");
        this.zoomGlobal = 1;
        this.zoomStep = 0.2;
        this.config.push("zoomStep");
        this.zoomVariablesDisable = false;
        this.config.push("zoomVariablesDisable");
        this.zoomSamplesDisable = false;
        this.config.push("zoomSamplesDisable");
        this.panningX = 0;
        this.config.push("panningX");
        this.panningY = 0;
        this.config.push("panningY");
        this.panningGlobalX = 0;
        this.panningGlobalY = 0;
        this.panningStep = 0.2;
        this.config.push("panningStep");
        this.filterType = "and";
        this.config.push("filterType");
        this.distance = "euclidian";
        this.config.push("distance");
        this.linkage = "single";
        this.config.push("linkage");
        this.clusterAxis = "samples";
        this.config.push("clusterAxis");
        this.kmeansClusters = 3;
        this.config.push("kmeansClusters");
        this.maxIterations = 10;
        this.config.push("maxIterations");
        this.imputeMethod = "mean";
        this.config.push("imputeMethod");
        this.centerData = false;
        this.config.push("centerData");
        this.useSmpVarIndexOnClustering = false;
        this.config.push("useSmpVarIndexOnClustering");
        this.xAxisAbsMax = null;
        this.xAxisAbsMin = null;
        this.xAxis2AbsMax = null;
        this.xAxis2AbsMin = null;
        this.yAxisAbsMax = null;
        this.yAxisAbsMin = null;
        this.zAxisAbsMax = null;
        this.zAxisAbsMin = null;
        this.rAxisAbsMax = null;
        this.rAxisAbsMin = null;
        this.xAxisMaxStrLength = false;
        this.xAxis2MaxStrLength = false;
        this.yAxisMaxStrLength = false;
        this.zAxisMaxStrLength = false;
        this.rAxisMaxStrLength = false;
        this.setMax = null;
        this.config.push("setMax");
        this.setMin = null;
        this.config.push("setMin");
        this.setMax2 = null;
        this.config.push("setMax2");
        this.setMin2 = null;
        this.config.push("setMin2");
        this.setMaxX = null;
        this.config.push("setMaxX");
        this.setMinX = null;
        this.config.push("setMinX");
        this.setMaxY = null;
        this.config.push("setMaxY");
        this.setMinY = null;
        this.config.push("setMinY");
        this.setMaxZ = null;
        this.config.push("setMaxZ");
        this.setMinZ = null;
        this.config.push("setMinZ");
        this.setMaxR = null;
        this.config.push("setMaxR");
        this.setMinR = null;
        this.config.push("setMinR");
        this.xAxisCurrent = 0;
        this.config.push("xAxisCurrent");
        this.yAxisCurrent = 0;
        this.config.push("yAxisCurrent");
        this.zAxisCurrent = 0;
        this.config.push("zAxisCurrent");
        this.rAxisCurrent = 0;
        this.config.push("rAxisCurrent");
        this.xAxisTitle = false;
        this.config.push("xAxisTitle");
        this.yAxisTitle = false;
        this.config.push("yAxisTitle");
        this.zAxisTitle = false;
        this.config.push("zAxisTitle");
        this.rAxisTitle = false;
        this.config.push("rAxisTitle");
        this.xAxis = [];
        this.config.push("xAxis");
        this.xAxis2 = [];
        this.config.push("xAxis2");
        this.yAxis = [];
        this.config.push("yAxis");
        this.zAxis = [];
        this.config.push("zAxis");
        this.xAxisTickStyle = "solid";
        this.config.push("xAxisTickStyle");
        this.yAxisTickStyle = "solid";
        this.config.push("yAxisTickStyle");
        this.zAxisTickStyle = "solid";
        this.config.push("zAxisTickStyle");
        this.rAxisTickStyle = "solid";
        this.config.push("rAxisTickStyle");
        this.xAxisTickFormat = false;
        this.config.push("xAxisTickFormat");
        this.xAxis2TickFormat = false;
        this.config.push("xAxis2TickFormat");
        this.yAxisTickFormat = false;
        this.config.push("yAxisTickFormat");
        this.zAxisTickFormat = false;
        this.config.push("zAxisTickFormat");
        this.rAxisTickFormat = false;
        this.config.push("rAxisTickFormat");
        this.xAxisTickColor = "rgb(204,204,204)";
        this.config.push("xAxisTickColor");
        this.yAxisTickColor = "rgb(204,204,204)";
        this.config.push("yAxisTickColor");
        this.zAxisTickColor = "rgb(204,204,204)";
        this.config.push("zAxisTickColor");
        this.rAxisTickColor = "rgb(204,204,204)";
        this.config.push("rAxisTickColor");
        this.axisExtension = 0.1;
        this.config.push("axisExtension");
        this.axisExact = false;
        this.config.push("axisExact");
        this.xAxisExact = false;
        this.config.push("xAxisExact");
        this.xAxis2Exact = false;
        this.config.push("xAxis2Exact");
        this.yAxisExact = false;
        this.config.push("yAxisExact");
        this.zAxisExact = false;
        this.config.push("zAxisExact");
        this.rAxisExact = false;
        this.config.push("rAxisExact");
        this.timeValues = [];
        this.config.push("timeValues");
        this.timeValueIndices = [];
        this.config.push("timeValueIndices");
        this.xAxisValues = [];
        this.config.push("xAxisValues");
        this.xAxis2Values = [];
        this.config.push("xAxis2Values");
        this.yAxisValues = [];
        this.config.push("yAxisValues");
        this.zAxisValues = [];
        this.config.push("zAxisValues");
        this.rAxisValues = [];
        this.config.push("rAxisValues");
        this.xAxisMinorValues = [];
        this.config.push("xAxisMinorValues");
        this.xAxis2MinorValues = [];
        this.config.push("xAxis2MinorValues");
        this.yAxisMinorValues = [];
        this.config.push("yAxisMinorValues");
        this.zAxisMinorValues = [];
        this.config.push("zAxisMinorValues");
        this.rAxisMinorValues = [];
        this.config.push("rAxisMinorValues");
        this.xAxisTransform = false;
        this.config.push("xAxisTransform");
        this.yAxisTransform = false;
        this.config.push("yAxisTransform");
        this.zAxisTransform = false;
        this.config.push("zAxisTransform");
        this.rAxisTransform = false;
        this.config.push("rAxisTransform");
        this.xAxisTransformTicks = true;
        this.config.push("xAxisTransformTicks");
        this.yAxisTransformTicks = true;
        this.config.push("yAxisTransformTicks");
        this.zAxisTransformTicks = true;
        this.config.push("zAxisTransformTicks");
        this.rAxisTransformTicks = true;
        this.config.push("rAxisTransformTicks");
        this.xAxisShow = true;
        this.config.push("xAxisShow");
        this.yAxisShow = true;
        this.config.push("yAxisShow");
        this.zAxisShow = true;
        this.config.push("zAxisShow");
        this.rAxisShow = true;
        this.config.push("rAxisShow");
        this.ticks = 50;
        this.config.push("ticks");
        this.timeTicksFirst = false;
        this.config.push("timeTicksFirst");
        this.xAxisTicks = 5;
        this.config.push("xAxisTicks");
        this.xAxis2Ticks = 5;
        this.config.push("xAxis2Ticks");
        this.yAxisTicks = 5;
        this.config.push("yAxisTicks");
        this.zAxisTicks = 5;
        this.config.push("zAxisTicks");
        this.rAxisTicks = 5;
        this.config.push("rAxisTicks");
        this.xAxisMinorTicks = true;
        this.config.push("xAxisMinorTicks");
        this.xAxis2MinorTicks = true;
        this.config.push("xAxis2MinorTicks");
        this.yAxisMinorTicks = true;
        this.config.push("yAxisMinorTicks");
        this.zAxisMinorTicks = false;
        this.config.push("zAxisMinorTicks");
        this.rAxisMinorTicks = false;
        this.config.push("rAxisMinorTicks");
        this.smpHairline = "dotted";
        this.config.push("smpHairline");
        this.smpHairlineWidth = 0.3;
        this.config.push("smpHairlineWidth");
        this.smpHairlineColor = "rgb(204,204,204)";
        this.config.push("smpHairlineColor");
        this.blockContrast = false;
        this.config.push("blockContrast");
        this.seriesSeparationFactor = 2;
        this.config.push("seriesSeparationFactor");
        this.blockSeparationFactor = 1;
        this.config.push("blockSeparationFactor");
        this.blockFactor = 1;
        this.config.push("blockFactor");
        this.plotByVariable = false;
        this.config.push("plotByVariable");
        this.is3DPlot = false;
        this.config.push("is3DPlot");
        this.showDataValues = false;
        this.config.push("showDataValues");
        this.lineDecoration = "symbol";
        this.config.push("lineDecoration");
        this.coordinateLineColor = true;
        this.config.push("coordinateLineColor");
        this.lineThickness = 1;
        this.config.push("lineThickness");
        this.lineType = "rect";
        this.config.push("lineType");
        this.tension = 0.3;
        this.config.push("tension");
        this.dotPlotJitter = false;
        this.config.push("dotPlotJitter");
        this.dotPlotDataPointRatio = 2;
        this.config.push("dotPlotDataPointRatio");
        this.dotPlotDataPointTransparency = 0.5;
        this.config.push("dotPlotDataPointTransparency");
        this.boxPlotOutliersRatio = 8;
        this.config.push("boxPlotOutliersRatio");
        this.showBoxplotOriginalData = false;
        this.config.push("showBoxplotOriginalData");
        this.areaIsCumulative = false;
        this.config.push("areaIsCumulative");
        this.colorBy = false;
        this.config.push("colorBy");
        this.shapeBy = false;
        this.config.push("shapeBy");
        this.shapeByData = false;
        this.config.push("shapeByData");
        this.shapeByShape = false;
        this.config.push("shapeByShape");
        this.sizeBy = false;
        this.config.push("sizeBy");
        this.sizeByData = false;
        this.config.push("sizeByData");
        this.outlineBy = false;
        this.config.push("outlineBy");
        this.outlineByData = false;
        this.config.push("outlineByData");
        this.scatterType = false;
        this.config.push("scatterType");
        this.scatterSeries = "y";
        this.config.push("scatterSeries");
        this.selectDataMode = "area";
        this.config.push("selectDataMode");
        this.selectDataModeDescription = false;
        this.config.push("selectDataModeDescription");
        this.selectDataPoint = [];
        this.hideDataPoint = [];
        this.isSelectDataPoints = 0;
        this.isHistogram = false;
        this.config.push("isHistogram");
        this.histogramBarWidth = 0.5;
        this.config.push("histogramBarWidth");
        this.histogramBins = 20;
        this.config.push("histogramBins");
        this.isCreateHistogram = false;
        this.allVsAll = false;
        this.config.push("allVsAll");
        this.allVsAllType = "both";
        this.config.push("allVsAllType");
        this.functionIntervals = 20;
        this.config.push("functionIntervals");
        this.xRotate = 45;
        this.config.push("xRotate");
        this.yRotate = 0;
        this.config.push("yRotate");
        this.zRotate = 0;
        this.config.push("zRotate");
        this.x3DRatio = 1;
        this.config.push("x3DRatio");
        this.y3DRatio = 1;
        this.config.push("y3DRatio");
        this.z3DRatio = 1;
        this.config.push("z3DRatio");
        this.bar3DInverseWeight = 1;
        this.config.push("bar3DInverseWeight");
        this.minRotate = null;
        this.config.push("minRotate");
        this.maxRotate = null;
        this.config.push("maxRotate");
        this.show3DGrid = true;
        this.config.push("show3DGrid");
        this.rotationDelay = 100;
        this.config.push("rotationDelay");
        this.rotationSensitivity = 45;
        this.config.push("rotationSensitivity");
        this.rotationStep = 2;
        this.config.push("rotationStep");
        this.cullingThreshold = 10000;
        this.config.push("cullingThreshold");
        this.indicatorCenter = "white";
        this.config.push("indicatorCenter");
        this.indicatorHeight = 8;
        this.config.push("indicatorHeight");
        this.indicatorWidth = 1;
        this.config.push("indicatorWidth");
        this.heatmapType = "blue-red";
        this.config.push("heatmapType");
        this.varIndicesStart = -1;
        this.smpIndicesStart = -1;
        this.isMultidimensionalHeatmap = false;
        this.correlationAxis = "samples";
        this.config.push("correlationAxis");
        this.correlationAnchorLegend = false;
        this.config.push("correlationAnchorLegend");
        this.correlationAnchorLegendAlignWidth = 40;
        this.config.push("correlationAnchorLegendAlignWidth");
        this.correlationLabelInterval = 1;
        this.config.push("correlationLabelInterval");
        this.showSmpDendrogram = false;
        this.config.push("showSmpDendrogram");
        this.showVarDendrogram = false;
        this.config.push("showVarDendrogram");
        this.varDendrogramPosition = "top";
        this.config.push("varDendrogramPosition");
        this.smpDendrogramPosition = "left";
        this.config.push("smpDendrogramPosition");
        this.dendrogramSpace = 6;
        this.config.push("dendrogramSpace");
        this.dendrogramHang = false;
        this.config.push("dendrogramHang");
        this.dendrogramHeight = false;
        this.config.push("dendrogramHeight");
        this.dendrogramColor = "rgb(204,204,204)";
        this.config.push("dendrogramColor");
        this.vennGroups = 4;
        this.config.push("vennGroups");
        this.vennCompartments = ["A", "B", "AB", "C", "AC", "BC", "ABC", "D", "AD", "BD", "CD", "ABD", "ACD", "BCD", "ABCD"];
        this.vennColors = [];
        this.config.push("vennColors");
        this.pieType = "separated";
        this.config.push("pieType");
        this.pieSegmentPrecision = 0;
        this.config.push("pieSegmentPrecision");
        this.pieSegmentSeparation = 3;
        this.config.push("pieSegmentSeparation");
        this.pieSegmentLabels = "inside";
        this.config.push("pieSegmentLabels");
        this.maxPieSectors = 20;
        this.config.push("maxPieSectors");
        this.showPieGrid = true;
        this.config.push("showPieGrid");
        this.showPieValues = true;
        this.config.push("showPieValues");
        this.showPieSampleLabel = true;
        this.config.push("showPieSampleLabel");
        this.startPieSectors = 0;
        this.config.push("startPieSectors");
        this.donutProportion = 0.3;
        this.config.push("donutProportion");
        this.ringSegmentSeparation = 4;
        this.config.push("ringSegmentSeparation");
        this.ringType = [];
        this.config.push("ringType");
        this.ringWeight = [];
        this.config.push("ringWeight");
        this.rAxis = false;
        this.config.push("rAxis");
        this.rAxisZero = true;
        this.config.push("rAxisZero");
        this.circularLetterSeparationFactor = 2;
        this.config.push("circularLetterSeparationFactor");
        this.showVolume = true;
        this.config.push("showVolume");
        this.stockIndicators = ["Sma5", "Sma10", "Sma25"];
        this.config.push("stockIndicators");
        this.sma5Color = "rgb(255,0,0)";
        this.config.push("sma5Color");
        this.sma10Color = "rgb(0,255,0)";
        this.config.push("sma1Color");
        this.sma20Color = "rgb(0,0,255)";
        this.config.push("sma20Color");
        this.sma25Color = "rgb(255,0,255)";
        this.config.push("sma25Color");
        this.sma50Color = "rgb(0,0,0)";
        this.config.push("sma50Color");
        this.calculateLayout = true;
        this.config.push("calculateLayout");
        this.networkFreeze = false;
        this.config.push("networkFreeze");
        this.networkFreezeOnLoad = false;
        this.config.push("networkFreezeOnLoad");
        this.networkStack = [];
        this.subNetworks = false;
        this.networkStackStates = 8;
        this.config.push("networkStackStates");
        this.networkStackIndex = 0;
        this.approximateNodePositions = false;
        this.config.push("approximateNodePositions");
        this.networkLayoutType = "forceDirected";
        this.config.push("networkLayoutType");
        this.networkForceConstant = 0;
        this.config.push("networkForceConstant");
        this.temperature = 0;
        this.config.push("temperature");
        this.initialTemperature = 0;
        this.config.push("initialTemperature");
        this.networkNodeMinDistance = 4;
        this.config.push("networkNodeMinDistance");
        this.attractiveForceFunction = "FruchtermanReingold";
        this.config.push("attractiveForceFunction");
        this.repulsiveForceFunction = "square";
        this.config.push("repulsiveForceFunction");
        this.networkRoot = false;
        this.config.push("networkRoot");
        this.showNetworkRadialLayout = false;
        this.config.push("showNetworkRadialLayout");
        this.networkDepth = 0;
        this.networkDivisions = 0;
        this.preScaleNetwork = false;
        this.config.push("preScaleNetwork");
        this.showNetworkNodesLegend = true;
        this.config.push("showNetworkNodesLegend");
        this.showNetworkEdgesLegend = true;
        this.config.push("showNetworkEdgesLegend");
        this.showNetworkTextLegend = true;
        this.config.push("showNetworkTextLegend");
        this.showNetworkDecorationsLegend = true;
        this.config.push("showNetworkDecorationsLegend");
        this.highlightNode = [];
        this.config.push("highlightNode");
        this.nodeHighlightColor = "rgb(255,0,0)";
        this.config.push("nodeHighlightColor");
        this.selectNode = {};
        this.isSelectNodes = 0;
        this.showNodeNameThreshold = 50;
        this.config.push("showNodeNameThreshold");
        this.showHiddenChildEdges = true;
        this.config.push("showHiddenChildEdges");
        this.nodeSize = this.preScaleNetwork ? 10 : 20;
        this.config.push("nodeSize");
        this.edgeWidth = 1;
        this.config.push("edgeWidth");
        this.layoutTime = 15;
        this.config.push("layoutTime");
        this.nodeFontSize = this.nodeSize;
        this.config.push("nodeFontSize");
        this.nodeFont = this.nodeFontSize + "Pt " + this.fontName;
        this.nodeFontColor = this.foreground;
        this.config.push("nodeFontColor");
        this.nodeScaleFontFactor = 1;
        this.config.push("nodeScaleFontFactor");
        this.randomNetwork = false;
        this.config.push("randomNetwork");
        this.reduceRandomNetwork = false;
        this.config.push("reduceRandomNetwork");
        this.randomNetworkNodes = 50;
        this.config.push("randomNetworkNodes");
        this.randomNetworkNodeEdgesMax = 5;
        this.config.push("randomNetworkNodeEdgesMax");
        this.colorNodeBy = false;
        this.config.push("colorNodeBy");
        this.shapeNodeBy = false;
        this.config.push("shapeNodeBy");
        this.sizeNodeBy = false;
        this.config.push("sizeNodeBy");
        this.colorEdgeBy = false;
        this.config.push("colorEdgeBy");
        this.shapeEdgeBy = false;
        this.config.push("shapeEdgeBy");
        this.sizeEdgeBy = false;
        this.config.push("sizeEdgeBy");
        this.sizeDecorationBy = false;
        this.config.push("sizeDecorationBy");
        this.is3DNetwork = false;
        this.config.push("is3DNetwork");
        this.network2DRotate = 0;
        this.skipClick = false;
        this.autoHideOnDecorationsCenter = false;
        this.config.push("autoHideOnDecorationsCenter");
        this.networkNodesOnTop = true;
        this.config.push("networkNodesOnTop");
        this.overrideEventlessNodes = false;
        this.config.push("overrideEventlessNodes");
        this.moveParentsWithChildren = false;
        this.config.push("moveParentsWithChildren");
        this.nodeConfigurableProperties = ["x", "y", "z", "shape", "color", "outline", "size", "width", "height", "pattern", "rotate", "outlineWidth", "imagePath", "zIndex", "eventless"];
        this.config.push("nodeConfigurableProperties");
        this.edgeConfigurableProperties = ["width", "cap", "exact", "type"];
        this.config.push("edgeConfigurableProperties");
        this.filterNodeBy = [];
        this.config.push("filterNodeBy");
        this.filterNodeByOp = [];
        this.filterNodeByValue = [];
        this.filterNodeByCase = [];
        this.filterEdgeBy = [];
        this.config.push("filterEdgeBy");
        this.filterEdgeByOp = [];
        this.filterEdgeByValue = [];
        this.filterEdgeByCase = [];
        this.trackNameFontSize = 10;
        this.config.push("trackNameFontSize");
        this.trackNameFont = (this.trackNameFontSize) + "Pt " + this.fontName;
        this.trackNameFontColor = this.background;
        this.config.push("trackNameFontColor");
        this.subtracksMaxDefault = 8;
        this.config.push("subtracksMaxDefault");
        this.showFeatureNameThereshold = 20;
        this.config.push("showFeatureNameThereshold");
        this.featureNameFontSize = 8;
        this.config.push("featureNameFontSize");
        this.featureNameFont = (this.featureNameFontSize) + "Pt " + this.fontName;
        this.featureNameFontColor = this.background;
        this.config.push("featureNameFontColor");
        this.maxFeatureStringLen = 50;
        this.config.push("maxFeatureStringLen");
        this.featureWidthDefault = 3;
        this.config.push("featureWidthDefault");
        this.featureHeightDefault = 14;
        this.config.push("featureHeightDefault");
        this.featureTraceHeight = 40;
        this.config.push("featureTraceHeight");
        this.featureTraceTrim = 1;
        this.config.push("featureTraceTrim");
        this.featureTracesShow = true;
        this.config.push("featureTracesShow");
        this.featureQualityHeight = 12;
        this.config.push("featureQualityHeight");
        this.featureQualityValues = false;
        this.config.push("featureQualityValues");
        this.featureQualityShow = true;
        this.config.push("featureQualityShow");
        this.featureSignalToNoiseHeight = 12;
        this.config.push("featureSignalToNoiseHeight");
        this.featureSignalToNoiseValues = false;
        this.config.push("featureSignalToNoiseValues");
        this.featureSignalToNoiseShow = true;
        this.config.push("featureSignalToNoiseShow");
        this.featureCoordinateHeight = 12;
        this.config.push("featureCoordinateHeight");
        this.featureCoordinateShow = true;
        this.config.push("featureCoordinateShow");
        this.featureTranslateHeight = 12;
        this.config.push("featureTranslateHeight");
        this.featureTranslateShow = true;
        this.config.push("featureTranslateShow");
        this.featureTypeDefault = "line";
        this.config.push("featureTypeDefault");
        this.featureStaggered = false;
        this.config.push("featureStaggered");
        this.sequenceFontSize = 10;
        this.config.push("sequenceFontSize");
        this.sequenceFont = (this.sequenceFontSize) + "Pt " + this.fontName;
        this.sequenceFill = false;
        this.config.push("sequenceFill");
        this.sequenceAColor = "rgb(0,103,0)";
        this.config.push("sequenceAColor");
        this.sequenceBColor = "rgb(0,0,0)";
        this.config.push("sequenceBColor");
        this.sequenceCColor = "rgb(0,0,255)";
        this.config.push("sequenceCColor");
        this.sequenceDColor = "rgb(0,0,0)";
        this.config.push("sequenceDColor");
        this.sequenceEColor = "rgb(0,0,0)";
        this.config.push("sequenceEColor");
        this.sequenceFColor = "rgb(0,0,255)";
        this.config.push("sequenceFColor");
        this.sequenceGColor = "rgb(0,0,0)";
        this.config.push("sequenceGColor");
        this.sequenceHColor = "rgb(255,0,0)";
        this.config.push("sequenceHColor");
        this.sequenceIColor = "rgb(0,103,0)";
        this.config.push("sequenceIColor");
        this.sequenceKColor = "rgb(255,0,0)";
        this.config.push("sequenceKColor");
        this.sequenceLColor = "rgb(0,103,0)";
        this.config.push("sequenceLColor");
        this.sequenceMColor = "rgb(0,103,0)";
        this.config.push("sequenceMColor");
        this.sequenceNColor = "rgb(0,0,0)";
        this.config.push("sequenceNColor");
        this.sequencePColor = "rgb(255,165,0)";
        this.config.push("sequencePColor");
        this.sequenceQColor = "rgb(0,0,0)";
        this.config.push("sequenceQColor");
        this.sequenceRColor = "rgb(255,0,0)";
        this.config.push("sequenceRColor");
        this.sequenceSColor = "rgb(255,165,0)";
        this.config.push("sequenceSColor");
        this.sequenceTColor = "rgb(255,0,0)";
        this.config.push("sequenceTColor");
        this.sequenceUColor = "rgb(255,0,0)";
        this.config.push("sequenceUColor");
        this.sequenceVColor = "rgb(0,103,0)";
        this.config.push("sequenceVColor");
        this.sequenceWColor = "rgb(0,0,255)";
        this.config.push("sequenceWColor");
        this.sequenceXColor = "rgb(0,0,0)";
        this.config.push("sequenceXColor");
        this.sequenceYColor = "rgb(0,0,255)";
        this.config.push("sequenceYColor");
        this.sequenceZColor = "rgb(0,0,0)";
        this.config.push("sequenceZColor");
        this.sequenceStartColor = "rgb(0,204,0)";
        this.config.push("sequenceStartColor");
        this.sequenceEndColor = "rgb(255,0,0)";
        this.config.push("sequenceEndColor");
        this.wireColor = this.isVML ? "rgb(204,204,204)" : "rgba(204,204,204,0.1)";
        this.config.push("wireColor");
        this.periodTicksLabels = 5;
        this.config.push("periodTicksLabels");
        this.genomeResolution = "low";
        this.trackConfigurableProperties = ["name", "hideName", "hideFeatureNames", "type", "height", "fill", "outline", "hide", "connect", "subtracksMax", "highlight"];
        this.config.push("trackConfigurableProperties");
        this.featureConfigurableProperties = ["id", "name", "hideName", "fill", "outline", "dir", "showDir", "connect", "offset", "data", "subtype", "quality", "signalToNoise", "coordinate", "sequence", "trace", "gaps", "translate", "hide", "counter"];
        this.config.push("featureConfigurableProperties");
        this.filterFeatureBy = [];
        this.config.push("filterFeatureBy");
        this.filterFeatureByOp = [];
        this.filterFeatureByValue = [];
        this.filterFeatureByCase = [];
        this.errors = [];
        this.debug = false;
        this.config.push("debug");
        this.showVersion = true;
        this.config.push("showVersion");
        this.showCode = false;
        this.config.push("showCode");
        this.codeType = "pretty";
        this.config.push("codeType");
        this.skin = "grey";
        this.config.push("skin");
        this.skinProperties = ["skinBackgroundColor", "skinBorderColor", "skinColor", "skinShadowColor"];
        this.skinPropertiesBlue = ["rgb(223,232,246)", "rgb(224,224,224)", "rgb(68,68,68)", "rgba(204,204,204,0.2)"];
        this.skinPropertiesGrey = ["rgb(240,240,240)", "rgb(113,139,183)", "rgb(34,34,34)", "rgba(154,154,154,0.2)"];
        this.skinHighlight;
        this.selectedBackgroundColor = "rgb(255,0,0)";
        this.config.push("selectedBackgroundColor");
        this.toolbarPermanent = false;
        this.config.push("toolbarPermanent");
        this.disableConfigurator = false;
        this.config.push("disableConfigurator");
        this.resizable = true;
        this.config.push("resizable");
        this.dockable = true;
        this.config.push("dockable");
        this.showAdvancedConfiguration = false;
        this.config.push("showAdvancedConfiguration");
        this.configuratorWidth = 300;
        this.config.push("configuratorWidth");
        this.dataFilterWidth = 300;
        this.config.push("dataFilterWidth");
        this.disableEvents = false;
        this.config.push("disableEvents");
        this.eventKeys = true;
        this.config.push("eventKeys");
        this.eventArrowKeys = true;
        this.config.push("eventArrowKeys");
        this.eventPlusMinusKeys = false;
        this.config.push("eventPlusMinusKeys");
        this.helpKeyEvents = true;
        this.config.push("helpKeyEvents");
        this.infoTimeOut = 3000;
        this.config.push("infoTimeOut");
        this.infoStartTime = new Date().getTime();
        this.infoTimeIn = 50;
        this.config.push("infoTimeIn");
        this.dataEvent = [];
        this.broadcast = true;
        this.config.push("broadcast");
        this.broadcastType = "var";
        this.config.push("broadcastType");
        this.destroyCanvasXpressZombies = true;
        this.config.push("destroyCanvasXpressZombies");
        this.monitorCanvasXpressZombiesTime = 30000;
        this.config.push("monitorCanvasXpressZombiesTime");
        this.resizerBackgroundColor = this.isIE ? "rgb(204,204,204)" : "rgba(204,204,204,0.7)";
        this.config.push("resizerBackgroundColor");
        this.resizerBackgroundColorCurrent = "rgb(237,247,255)";
        this.config.push("resizerBackgroundColorCurrent");
        this.resizerBackgroundColorOutlineCurrent = "rgb(59,138,229)";
        this.config.push("resizerBackgroundColorOutlineCurrent");
        this.resizerTransparency = true;
        this.config.push("resizerTransparency");
        this.resizerType = false;
        this.config.push("resizerType");
        this.resizerDraw = false;
        this.config.push("resizerDraw");
        this.resizerPosition = "bottom";
        this.config.push("resizerPosition");
        this.resizerWidth = 50;
        this.config.push("resizerWidth");
        this.resizerBackgroundImage = false;
        this.config.push("resizerBackgroundImage");
        this.resizerDataIndex = 0;
        this.config.push("resizerDataIndex");
        this.resizerEventData = {};
        this.showAnimation = false;
        this.config.push("showAnimation");
        this.showAnimationFontSize = 10;
        this.config.push("showAnimationFontSize");
        this.showAnimationFont = (this.showAnimationFontSize) + "Pt " + this.fontName;
        this.showAnimationFontColor = this.background;
        this.config.push("showAnimationFontColor");
        this.animationTime = 30;
        this.config.push("animationTime");
        this.animationType = "grow";
        this.config.push("animationType");
        this.animationCycles = 20;
        this.config.push("animationCycles");
        this.snapshotCopyChangeOnly = true;
        this.config.push("snapshotCopyChangeOnly");
        this.snapshots = [];
        this.isAnimation = false;
        this.weight = 1;
        this.scaleX = 1;
        this.scaleY = 1;
        this.translateX = 0;
        this.translateY = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.layoutWidth = 0;
        this.layoutHeight = 0;
        this.layout = "1X1";
        this.config.push("layout");
        this.layoutComb = false;
        this.config.push("layoutComb");
        this.layoutAdjust = false;
        this.config.push("layoutAdjust");
        this.layoutCurrent = 0;
        this.layoutMaxVarLegend = 0;
        this.layoutMulticolor = true;
        this.config.push("layoutMulticolor");
        this.layoutAxis = 3;
        this.imageDir = "http://canvasxpress.org/images/";
        this.config.push("imageDir");
        this.playButton = "control_play_blue.png";
        this.config.push("playButton");
        this.stopButton = "control_stop_blue.png";
        this.config.push("stopButton");
        this.previousButton = "control_rewind_blue.png";
        this.config.push("previousButton");
        this.nextButton = "control_forward_blue.png";
        this.config.push("nextButton");
        this.dropdownButton = "menu_dropdown.png";
        this.config.push("dropdownButton");
        this.remoteService = false;
        this.config.push("remoteService");
        this.remoteParams = {};
        this.config.push("remoteParams");
        this.remoteDirection = "next";
        this.config.push("remoteDirection");
        this.remoteParentId = "";
        this.remoteDataIndex = 0;
        this.remoteIds = [];
        this.remoteWindow = 1;
        this.config.push("remoteWindow");
        this.remoteAutoPlay = false;
        this.config.push("remoteAutoPlay");
        this.remoteAutoPlayDelay = 3000;
        this.config.push("remoteAutoPlayDelay");
        this.remoteUpdating = false;
        this.remoteUpdate = false;
        this.config.push("remoteUpdate");
        this.remoteUpdateDelay = 10000;
        this.config.push("remoteUpdateDelay");
        this.showDataTable = false;
        this.config.push("showDataTable");
        this.dataTableTransposed = true;
        this.config.push("dataTableTransposed");
        this.maxRows = 10;
        this.config.push("maxRows");
        this.maxCols = 10;
        this.config.push("maxCols");
        this.colWidth = 50;
        this.config.push("colWidth");
        this.rowHeight = 15;
        this.config.push("rowHeight");
        this.freezeColLeft = 0;
        this.config.push("freezeColLeft");
        this.freezeColRight = 0;
        this.config.push("freezeColRight");
        this.freezeRowTop = 0;
        this.config.push("freezeRowTop");
        this.freezeRowBottom = 0;
        this.config.push("freezeRowBottom");
        this.refresehDataTableOnDraw = false;
        this.config.push("refresehDataTableOnDraw");
        this.showDataTableOnSelect = false;
        this.config.push("showDataTableOnSelect");
        this.networkShowDataTable = "nodes";
        this.config.push("networkShowDataTable");
        this.startCol = 1;
        this.startRow = 1;
        this.dataTableColumnWidth = [];
        this.dataTableRowHeight = []
    };
    this.setInitialConfig = function () {
        if (a) {
            for (var b in a) {
                this[b] = a[b]
            }
        }
    };
    this.resetConfig = function (b) {
        var d = {};
        if (b) {
            for (var c = 0; c < b.length; c++) {
                d[b[c]] = this[b[c]]
            }
        }
        this.setConfigDefaults();
        for (var c in d) {
            this[c] = d[c]
        }
    };
    this.updateConfig = function (c) {
        if (c) {
            this.userConfig = c;
            for (var b in c) {
                this[b] = c[b]
            }
        }
    };
    this.getConfig = function () {
        var d = {};
        for (var c = 0; c < this.config.length; c++) {
            var b = this.config[c];
            if (this[b] != undefined) {
                d[b] = this[b]
            }
        }
        return d
    };
    this.getUserConfig = function () {
        return this.userConfig
    };
    this.setSkin = function (c) {
        if (!c) {
            c = this.skin
        }
        for (var b = 0; b < this.skinProperties.length; b++) {
            if (c == "blue") {
                this[this.skinProperties[b]] = this.skinPropertiesBlue[b]
            } else {
                this[this.skinProperties[b]] = this.skinPropertiesGrey[b]
            }
        }
        if (c == "blue") {
            this.skinHighlight = "rgb(250,250,250)"
        } else {
            this.skinHighlight = "rgb(223,232,246)"
        }
    };
    this.setPath = function () {
        var d = document.getElementsByTagName("script");
        if (d) {
            for (var c = 0; c < d.length; c++) {
                if (!d[c].src) {
                    continue
                }
                var e = d[c].src;
                var b = e.lastIndexOf("/");
                var h = e.substring(0, b + 1);
                var g = e.substring(b + 1);
                if (g.match(/canvasXpress/)) {
                    this.path = h
                }
            }
        }
    };
    this.setCanvas = function () {
        var b = this.$(this.target);
        if (b) {
            if (this.browser == "Explorer" && (this.browserVersion < 9 && navigator.userAgent.toLowerCase().indexOf("chromeframe") < 0)) {
                this.canvas = window.G_vmlCanvasManager.initElement(b)
            } else {
                this.canvas = b
            }
            this.ctx = this.canvas.getContext("2d")
        }
    };
    this.inititalizeConfig = function () {
        this.setConfigDefaults();
        if (a.graphType == "Network") {
            if (!a.backgroundType) {
                this.backgroundType = "gradient";
                this.nodeFontColor = this.background
            }
        }
        if (a) {
            for (var b = 0; b < this.config.length; b++) {
                var c = this.config[b];
                if (a.hasOwnProperty(c)) {
                    this[c] = a[c]
                }
            }
        }
        if (this.isVML) {
            this.showAnimation = false
        }
        this.setSkin();
        this.setPath();
        this.setCanvas()
    };
    this.inititalizeConfig()
};
CanvasXpress.prototype.initColor = function () {
    this.validateColor = function (b, a) {
		
        b = b.toString();
        if (b.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i)) {
            if (RegExp.$2) {
                b = "rgba(" + RegExp.$1 + "," + RegExp.$2 + ")"
            } else {
                b = "rgb(" + RegExp.$1 + ")"
            }
        } else {
            if (b.match(/^#?[0-9abcdef]/i)) {
                b = this.hexToRgb(b)
            } else {
                b = false
            }
        }
        return b && a != null ? this.addColorTransparency(b, a) : b
    };
    this.darkenLightenColor = function (j, e) {
        j = this.rgbToHex(j).substring(1, 7);
        var i = parseInt(j, 16);
        var h = (i >> 16) + e;
        h = h > 255 ? 255 : h < 0 ? 0 : h;
        var f = ((i >> 8) & 255) + e;
        f = f > 255 ? 255 : f < 0 ? 0 : f;
        var d = (i & 255) + e;
        d = d > 255 ? 255 : d < 0 ? 0 : d;
        j = d | (f << 8) | (h << 16);
        return this.hexToRgb(j.toString(16))
    };
    this.rgbToHex = function (b) {
        var a = function (c) {
            c = parseInt(c, 10);
            if (isNaN(c)) {
                return "00"
            }
            c = Math.max(0, Math.min(c, 255));
            return "0123456789ABCDEF".charAt((c - c % 16) / 16) + "0123456789ABCDEF".charAt(c % 16)
        };
        if (b.substr(0, 1) === "#") {
            return b
        }
        if (b.match(/^rgb\((\d{1,3}),(\d{1,3}),(\d{1,3})\)/)) {
            return "#" + a(RegExp.$1) + a(RegExp.$2) + a(RegExp.$3)
        } else {
            return b
        }
    };
    this.hexToRgb = function (c) {
        var b = function () {
            return parseInt(c.substring(0, 2), 16)
        };
        var a = function () {
            return parseInt(c.substring(2, 4), 16)
        };
        var d = function () {
            return parseInt(c.substring(4, 6), 16)
        };
        c = c.charAt(0) == "#" ? c.substring(1, 7) : c;
        return "rgb(" + b() + "," + a() + "," + d() + ")"
    };
    this.addColorTransparency = function (b, a) {
        if (b && b.match(/^rgba?\((\d{1,3},\d{1,3},\d{1,3})(?:,([0-9\.]+))?/i)) {
            if (RegExp.$2) {
                return "rgba(" + RegExp.$1 + "," + a + ")"
            } else {
                return "rgba(" + RegExp.$1 + "," + a + ")"
            }
        } else {
            return false
        }
    };
    this.disableGradientTransparency = function () {
        this.gradientTemp = this.gradient;
        this.transparencyTemp = this.transparency;
        this.gradient = false;
        this.transparency = null
    };
    this.enableGradientTransparency = function () {
        this.gradient = this.gradientTemp;
        this.transparency = this.transparencyTemp
    };
    this.getGradientColor = function (h) {
        if (h.match(/^rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(?:,([0-9\.]+))?/i)) {
            var f = Math.floor(parseInt(RegExp.$1) / this.gradientRatio);
            var e = Math.floor(parseInt(RegExp.$2) / this.gradientRatio);
            var a = Math.floor(parseInt(RegExp.$3) / this.gradientRatio);
            var d = RegExp.$4 ? parseFloat(RegExp.$4) : false;
            if (d) {
                return "rgba(" + f + "," + e + "," + a + "," + d + ")"
            } else {
                return "rgb(" + f + "," + e + "," + a + ")"
            }
        } else {
            return false
        }
    };
    this.setGradient = function (e, d, c, b, a) {
        if (this.gradientType == "radial") {
            this.setRadialGradient(e, d, c, b, false, false, true)
        } else {
            this.setLinearGradient(e, d, c, b, a, false, true)
        }
    };
    this.setLinearGradient = function (c, i, a, f, e, b, d) {
        if (!d) {
            this.ctx.save()
        }
        var h = this.ctx.createLinearGradient(c, i, a, f);
        if (!b) {
            b = this.getGradientColor(e);
            h.addColorStop(0, b);
            h.addColorStop(0.6, e);
            h.addColorStop(1, e)
        } else {
            h.addColorStop(0, e);
            h.addColorStop(1, b)
        }
		this.ctx.fillStyle = h
    };
    this.setRadialGradient = function (j, h, a, e, d, c, i) {
        if (!i) {
            this.ctx.save()
        }
        var b = a / 5.5;
        var f = this.ctx.createRadialGradient(j - b, h - b, 1, j, h, a);
        if (!d) {
            if (this.transparency != null) {
                d = "rgba(0,0,0," + this.transparency + ")"
            } else {
                d = "rgb(0,0,0)"
            }
        }
        if (!c) {
            c = "rgba(0,0,0,0)"
        }
        f.addColorStop(0, e);
        f.addColorStop(1, d);
        f.addColorStop(1, c);
		this.ctx.fillStyle = f
    }
};
CanvasXpress.prototype.initText = function () {
    this.drawTextMultiple = function (v, u, p, n, o, r, q, d, e, w) {
        var h = v.split(/\n/);
        if (!n) {
            n = this.font
        }
        var k = this.getFontPt(n) + 4;
        if (h.length % 2) {
            p -= (parseInt(h.length / 2) * k) + (k / 2)
        } else {
            p = (p - parseInt(h.length / 2) * k)
        }
        for (var j = 0; j < h.length; j++) {
            this.drawText(h[j], u, p, n, o, r, q, d, e, w);
            p += k
        }
    };
    this.drawArcText = function (C, B, z, d, D, u, p, v, k, w, g, j) {
        var q = [];
        if (C == null) {
            return
        }
        if (!this.ctx) {
            if (this.debug) {
                alert("Dude, there is no canvas")
            }
            return
        }
        if (isNaN(B) || isNaN(z)) {
            if (this.debug) {
                alert("Not a valid coordinate (" + B + ", " + z + ") to draw " + C)
            }
            return
        }
        if (!j && !isNaN(C)) {
            C = this.formatNumber(C)
        }
        if (!B) {
            B = 0
        }
        if (!z) {
            z = 0
        }
        if (!p) {
            p = this.font
        }
        if (!v) {
            v = this.foreground
        }
        if (!k) {
            k = this.align
        }
        if (!w) {
            w = this.baseline
        }
        this.ctx.save();
        this.ctx.strokeStyle = v;
		this.ctx.fillStyle = v;
        this.ctx.font = p;
        this.ctx.textAlign = k;
        this.ctx.textBaseline = w;
        if (this.showShadow) {
            this.ctx.shadowOffsetX = this.shadowOffsetX;
            this.ctx.shadowOffsetY = this.shadowOffsetY;
            this.ctx.shadowBlur = this.shadowBlur;
            this.ctx.shadowColor = this.shadowColor
        }
        var o = u / (C.length * this.circularLetterSeparationFactor);
        var A = D + (u / 2) + (o / 2) - (o * (C.length / 2));
        this.ctx.translate(B, z);
        this.ctx.rotate(A);
        for (var n = 0; n < C.length; n++) {
            this.ctx.save();
            this.ctx.rotate((n * o) + (Math.PI / 2));
            this.ctx.fillText(C[n], 0, - d);
            this.ctx.restore()
        }
        this.ctx.restore();
        if (this.showShadow) {
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;
            this.ctx.shadowBlur = 0;
            this.ctx.shadowColor = this.background
        }
        return q
    };
    this.drawText = function (o, l, k, z, B, D, C, g, q, p, i) {
        var j = 0;
        var r = function (c) {
            c.shift();
            var f = [];
            var m = (Math.PI / 2) + g == 0 ? -Math.PI / 2 : g - Math.PI / 2;
            var b = ["poly"];
            var t = c.shift() - l;
            var h = c.shift() - k;
            var a = c.shift() - l;
            var s = c.shift() - k;
            f.push((h * Math.sin(m)) - (t * Math.cos(m)));
            f.push((h * Math.cos(m)) + (t * Math.sin(m)));
            f.push((s * Math.sin(m)) - (t * Math.cos(m)));
            f.push((s * Math.cos(m)) + (t * Math.sin(m)));
            f.push((s * Math.sin(m)) - (a * Math.cos(m)));
            f.push((s * Math.cos(m)) + (a * Math.sin(m)));
            f.push((h * Math.sin(m)) - (a * Math.cos(m)));
            f.push((h * Math.cos(m)) + (a * Math.sin(m)));
            while (f.length > 1) {
                b.push(f.shift() + l);
                b.push(f.shift() + k)
            }
            return b
        };
        var E = [];
        if (o == null) {
            return
        }
        if (this.isMultipleLines(o)) {
            return this.drawTextMultiple(o, l, k, z, B, D, C, g, q, p)
        }
        if (!this.ctx) {
            if (this.debug) {
                alert("Dude, there is no canvas")
            }
            return
        }
        if (isNaN(l) || isNaN(k)) {
            if (this.debug) {
                alert("Not a valid coordinate (" + l + ", " + k + ") to draw " + o)
            }
            return
        }
        if (g < (Math.PI / -2) || g > (Math.PI / 2)) {
            if (this.debug) {
                alert("Dude, you can only rotate between -PI/2 and PI/2")
            }
            return
        }
        if (!i && !isNaN(o)) {
            o = this.formatNumber(o)
        }
        if (!l) {
            l = 0
        }
        if (!k) {
            k = 0
        }
        if (!z) {
            z = this.font
        }
        if (!B) {
            B = this.foreground
        }
        if (!D) {
            D = this.align
        }
        if (!C) {
            C = this.baseline
        }
        var n = this.measureText(o, z);
        var u = this.getFontPt(z);
        if (q) {
            while (n > q && j < 10) {
                o = o.substring(0, o.length - 1);
                n = this.measureText(o, z);
                j++
            }
        }
        var A, e, v, d;
        if (D == "left") {
            A = l;
            v = A + n
        } else {
            if (D == "right") {
                A = l - n;
                v = l
            } else {
                A = l - (n / 2);
                v = l + (n / 2)
            }
        }
        if (C == "top") {
            e = k;
            d = e + u
        } else {
            if (C == "bottom") {
                e = k - u;
                d = k
            } else {
                e = k - (u / 2);
                d = k + (u / 2)
            }
        }
        E = ["rect", A, e, v, d];
        if (g) {
            E = r(E)
        }
        this.ctx.save();
		this.ctx.strokeStyle = B;
        this.ctx.fillStyle = B;
        this.ctx.font = z;
        this.ctx.save();
        this.ctx.translate(l, k);
        this.ctx.textAlign = D;
        this.ctx.textBaseline = C;
        if (this.showShadow) {
            this.ctx.shadowOffsetX = this.shadowOffsetX;
            this.ctx.shadowOffsetY = this.shadowOffsetY;
            this.ctx.shadowBlur = this.shadowBlur;
            this.ctx.shadowColor = this.shadowColor
        }
        if (g) {
            this.ctx.rotate(g)
        }
        if (p) {
            this.ctx.strokeText(o, 0, 0)
        } else {
            this.ctx.fillText(o, 0, 0)
        }
        this.ctx.restore();
        if (this.showShadow) {
            this.ctx.shadowOffsetX = 0;
            this.ctx.shadowOffsetY = 0;
            this.ctx.shadowBlur = 0;
            this.ctx.shadowColor = this.background
        }
        return E
    };
    this.isMultipleLines = function (b) {
        var a = b.toString().split(/\n/);
        return a.length - 1
    };
    this.capitalize = function (a) {
        if (a) {
            return a.charAt(0).toUpperCase() + a.slice(1)
        }
    };
    this.measureTextMultiple = function (d, e) {
        var b = d.split(/\n/);
        var a = 0;
        if (!this.ctx) {
            return 0
        }
        if (!e) {
            e = this.font
        }
        this.ctx.font = e;
        for (var c = 0; c < b.length; c++) {
            a = Math.max(a, this.ctx.measureText(b[c]).width)
        }
        return a
    };
    this.measureText = function (a, b) {
        if (!a || !this.ctx) {
            return 0
        }
        a = a.toString();
        if (!b) {
            b = this.font
        }
        if (!CanvasXpress.cacheText[b]) {
            CanvasXpress.cacheText[b] = {}
        }
        if (!CanvasXpress.cacheText[b][a]) {
            this.ctx.font = b;
            if (this.isMultipleLines(a)) {
                CanvasXpress.cacheText[b][a] = this.measureTextMultiple(a, b)
            } else {
                //CanvasXpress.cacheText[b][a] = this.ctx.measureText(a).width
            }
        }
        return CanvasXpress.cacheText[b][a]
    };
    this.scaleTextToFont = function (b, d, a) {
        var c = d + "pt " + this.fontName;
        if (b) {
            while (this.measureText(b, c) > a && d >= this.minTextSize) {
                d -= 2;
                c = d + "pt " + this.fontName
            }
        }
        return c
    };
    this.getFontPt = function (a) {
        return Math.max(1, parseInt(a.match(/^[\-\d]+/)[0]))
    };
    this.scaleTextToSize = function (a) {
        var d = this.scaleTextConstantMult;
        if (!a) {
            a = 1
        }
        return Math.ceil(1 / Math.sqrt(a) * d)
    };
    this.formatNumber = function (g, c) {
        if (!c) {
            c = 2
        }
        if (g.toString().length >= 7) {
            var b = sprintf("%." + c + "e", Number(g));
            var a = sprintf("%." + c + "f", Number(g));
            if (a.toString().length > b.toString().length) {
                return b.toString()
            } else {
                return a.toString()
            }
        } else {
            return g.toString()
        }
    };
    this.bestFormatNumber = function (b, a) {
        if (a < 1) {
            return sprintf("%.0f", Number(b))
        } else {
            if (Math.abs(b) < 0.001) {
                return sprintf("%.2e", Number(b))
            } else {
                return sprintf("%.3f", Number(b))
            }
        }
    };
    this.getMaxText = function (d) {
        var f = "";
        var b = 0;
        for (var e = 0; e < d.length; e++) {
            var g = this.measureText(d[e].toString(), this.font);
            if (g > b) {
                f = d[e].toString();
                b = g
            }
        }
        return f
    };
    this.shortenText = function (c, b, a) {
        if (!c) {
            return ""
        }
        c = c.toString();
        if (a) {
            return c.substring(0, Math.max(parseInt(a * 1 / b) - 2, 1)) + ".."
        } else {
            if (c.length <= b) {
                return c
            } else {
                return c.substring(0, b - 3) + "..."
            }
        }
    };
    this.convertToNumber = function (a) {
        if (!isNaN(a)) {
            return parseFloat(a)
        } else {
            return a
        }
    }
};
CanvasXpress.prototype.initTime = function () {
    Date.prototype.getWeek = function () {
        var a = new Date(this.getFullYear(), 0, 1);
        return Math.ceil((((this - a) / 86400000) + a.getDay() + 1) / 7)
    };
    this.getMillisecond = function (a) {
        return a.getMilliseeconds()
    };
    this.getSecond = function (a) {
        return a.getSeconds()
    };
    this.getMinuteSecond = function (a) {
        return a.getMinutes() + ":" + a.getSeconds()
    };
    this.getMinute = function (a) {
        return a.getMinutes()
    };
    this.getHourMinute = function (a) {
        return a.getHours() + ":" + a.getMinutes()
    };
    this.getHour = function (a) {
        return a.getHours()
    };
    this.getYearWeek = function (a) {
        return a.getFullYear() + "-" + a.getWeek()
    };
    this.getYearMonth = function (a) {
        return a.getFullYear() + "-" + a.getMonth()
    };
    this.getYear = function (a) {
        return a.getFullYear()
    };
    this.times = {
        second: 1000,
        minute: 60000,
        hour: 3600000,
        day: 86400000,
        week: 604800000,
        month: 2592000000,
        year: 31556952000
    };
    this.parseDate = function (j) {
        var f = 0;
        var c = 0;
        var e = 0;
        var k = parseInt(j.toString().substring(0, 4));
        var a = parseInt(j.toString().substring(4, 6).replace(/^0/, ""));
        var g = parseInt(j.toString().substring(6, 8).replace(/^0/, ""));
        var b = j.toString().match(/\:/) ? j.toString().substring(10).split(":") : false;
        if (b) {
            f = b[0] ? parseInt(b[0].replace(/^0/, "")) : 0;
            c = b[1] ? parseInt(b[1].replace(/^0/, "")) : 0;
            e = b[2] ? parseInt(b[2].replace(/^0/, "")) : 0
        }
        return new Date(k, a - 1, g, f, c, e)
    };
    this.setTimeAxis = function () {
        var h = this.validateTimeAxis();
        if (h) {
            var g = Date.parse(h[h.length - 1]) - Date.parse(h[0]);
            var d;
            var b = {};
            var c = [];
            this.timeValues = [];
            this.timeValueIndices = [];
            if (g > this.times.year * 2) {
                d = "getYear"
            } else {
                if (g > this.times.month * 2) {
                    d = "getYearMonth"
                } else {
                    if (g > this.times.week * 2) {
                        d = "getYearWeek"
                    } else {
                        if (g < this.times.second) {
                            d = "getMillisecond"
                        } else {
                            if (g < this.times.minute) {
                                d = "getSecond"
                            } else {
                                if (g < this.times.hour / 4) {
                                    d = "getMinuteSecond"
                                } else {
                                    if (g < this.times.hour) {
                                        d = "getMinute"
                                    } else {
                                        if (g < this.times.day / 4) {
                                            d = "getHourMinute"
                                        } else {
                                            if (g < this.times.day) {
                                                d = "getHour"
                                            } else {
                                                d = false
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (d) {
                if (this.timeTicksFirst) {
                    for (var a = 0; a < h.length; a++) {
                        var e = this[d](h[a]);
                        if (!b.hasOwnProperty(e)) {
                            c.push(h[a]);
                            this.timeValueIndices.push(a);
                            b[e] = true
                        }
                    }
                } else {
                    for (var a = h.length - 1; a >= 0; a--) {
                        var e = this[d](h[a]);
                        if (!b.hasOwnProperty(e)) {
                            c.unshift(h[a]);
                            this.timeValueIndices.unshift(a);
                            b[e] = true
                        }
                    }
                }
            } else {
                for (var a = 0; a < h.length; a++) {
                    this.timeValues.push(dateFormat(h[a], this.timeFormat));
                    this.timeValueIndices.push(a)
                }
            }
            var g = Date.parse(c[c.length - 1]) - Date.parse(c[c.length - 2]);
            if (d == "getYear" && g < this.times.month * 3) {
                this.timeValues.pop();
                this.timeValueIndices.pop()
            } else {
                if (d == "getYearMonth" && g < this.times.week * 4) {
                    this.timeValues.pop();
                    this.timeValueIndices.pop()
                } else {
                    if (d == "getYearWeek" && g < this.times.day * 7) {
                        this.timeValues.pop();
                        this.timeValueIndices.pop()
                    }
                }
            }
            for (var a = 0; a < c.length; a++) {
                this.timeValues.push(dateFormat(c[a], this.timeFormat))
            }
        }
    };
    this.createRandomTimes = function (b) {
        var e;
        var g = new Date();
        var a = g.getTime();
        var f = [new Date(a)];
        var h = this.isGroupedData ? this.data.w : this.data.y;
        if (!b || !this.times[b]) {
            b = "day"
        }
        for (var c = 0; c < h.smps.length; c++) {
            e = Date.parse(h.smps[c]);
            if (!isNaN(e)) {
                a = e
            } else {
                a -= this.times[b]
            }
            f.unshift(new Date(a))
        }
        return f
    };
    this.validateTimeAxis = function () {
        var f = this.isGroupedData ? this.data.w : this.data.y;
        var a = false;
        var e = [];
        for (var b = 0; b < this.smpIndices.length; b++) {
            var c = this.smpIndices.length != f.smps.length ? Date.parse(f.smps[this.smpIndices[b]]) : Date.parse(f.smps[b]);
            if (isNaN(c)) {
                if (this.isExample) {
                    e = this.createRandomTimes();
                    return e
                } else {
                    a = true;
                    break
                }
            } else {
                e.push(new Date(c))
            }
        }
        return a ? false : e
    }
};
CanvasXpress.prototype.initAttributes = function () {
    this.validateNumbers = function (b) {
        for (var c = 0; c < b.length; c++) {
            if (isNaN(b[c])) {
                return false
            }
        }
        return true
    };
    this.lineTo = function (b, d, a, c) {
        if (b == a) {
            b = Math.round(b) + 0.5;
            a = b
        } else {
            if (d == c) {
                d = Math.round(d) + 0.5;
                c = d
            }
        }
        this.ctx.moveTo(b, d);
        this.ctx.lineTo(a, c);
        this.ctx.stroke()
    };
    this.clip = function (q, f, i) {
        var d, c, n, k, g, m, q;
        var o, e, a, j;
        var p = [];
        if (i && i.length == 4) {
            e = i[0];
            o = i[1];
            a = e + i[2];
            j = o + i[3]
        } else {
            e = this.marginLeft + this.offsetX + this.left;
            o = this.marginTop + this.offsetY + this.top;
            a = e + this.x;
            j = o + this.y
        }
        if (q == "rect") {
            d = parseInt(f[0]);
            n = parseInt(f[1]);
            c = parseInt(d + f[2]);
            k = parseInt(n + f[3]);
            if (d > a + this.outlineWidth || k > j + this.outlineWidth || c < e || n < o) {
                return false
            }
            if (d < e) {
                d = e
            }
            if (c > a) {
                c = a
            }
            if (k < o) {
                k = o
            }
            if (n > j) {
                n = j
            }
            p = [d, n, c - d, k - n]
        } else {
            if (q == "poly") {} else {
                if (q == "circle") {
                    d = parseInt(f[0]);
                    n = parseInt(f[1]);
                    if (d > a || d < e || n < o || n > j) {
                        return false
                    }
                    p = [d, n]
                } else {
                    if (q == "line") {
                        d = parseFloat(f[0]);
                        n = parseFloat(f[1]);
                        c = parseFloat(f[2]);
                        k = parseFloat(f[3]);
                        if (d == c) {
                            if (d < e || d > a) {
                                return false
                            } else {
                                if (n > k) {
                                    if (n < o) {
                                        return false
                                    } else {
                                        if (n > j) {
                                            n = j
                                        }
                                    }
                                    if (k > j) {
                                        return false
                                    } else {
                                        if (k < o) {
                                            k = o
                                        }
                                    }
                                } else {
                                    if (n > j) {
                                        return false
                                    } else {
                                        if (n < o) {
                                            n = o
                                        }
                                    }
                                    if (k < o) {
                                        return false
                                    } else {
                                        if (k > j) {
                                            k = j
                                        }
                                    }
                                }
                            }
                        } else {
                            if (n == k) {
                                if (n < o || n > j) {
                                    return false
                                } else {
                                    if (d > c) {
                                        if (d < e) {
                                            return false
                                        } else {
                                            if (d > a) {
                                                d = a
                                            }
                                        }
                                        if (c > a) {
                                            return false
                                        } else {
                                            if (c < e) {
                                                c = e
                                            }
                                        }
                                    } else {
                                        if (d > a) {
                                            return false
                                        } else {
                                            if (d < e) {
                                                d = e
                                            }
                                        }
                                        if (c < e) {
                                            return false
                                        } else {
                                            if (c > a) {
                                                c = a
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (d > c) {
                                    if (d < e || c > a) {
                                        return false
                                    } else {
                                        if (n > k) {
                                            if (n < o || k > j) {
                                                return false
                                            } else {
                                                g = n - k;
                                                m = d - c;
                                                if (d > a) {
                                                    n -= (d - a) * g / m;
                                                    d = a
                                                }
                                                if (n > j) {
                                                    d -= (n - j) * m / g;
                                                    n = j
                                                }
                                                if (c < e) {
                                                    k += (e - c) * g / m;
                                                    c = e
                                                }
                                                if (k < o) {
                                                    c += (o - k) * m / g;
                                                    k = o
                                                }
                                            }
                                        } else {
                                            if (k < o || n > j) {
                                                return false
                                            } else {
                                                g = k - n;
                                                m = d - c;
                                                if (d > a) {
                                                    n += (d - a) * g / m;
                                                    d = a
                                                }
                                                if (n < o) {
                                                    d -= (o - n) * m / g;
                                                    n = o
                                                }
                                                if (c < e) {
                                                    k -= (e - c) * g / m;
                                                    c = e
                                                }
                                                if (k > j) {
                                                    c += (k - j) * m / g;
                                                    k = j
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (c < e || d > a) {
                                        return false
                                    } else {
                                        if (n > k) {
                                            if (n < o || k > j) {
                                                return false
                                            } else {
                                                g = n - k;
                                                m = c - d;
                                                if (d < e) {
                                                    n -= (e - d) * g / m;
                                                    d = e
                                                }
                                                if (n > j) {
                                                    d += (n - j) * m / g;
                                                    n = j
                                                }
                                                if (c > a) {
                                                    k += (c - a) * g / m;
                                                    c = a
                                                }
                                                if (k < o) {
                                                    c -= (o - k) * m / g;
                                                    k = o
                                                }
                                            }
                                        } else {
                                            if (k < o || n > j) {
                                                return false
                                            } else {
                                                g = k - n;
                                                m = c - d;
                                                if (d < e) {
                                                    n += (e - d) * g / m;
                                                    d = e
                                                }
                                                if (n < o) {
                                                    d += (o - n) * m / g;
                                                    n = o
                                                }
                                                if (c > a) {
                                                    k -= (c - a) * g / m;
                                                    c = a
                                                }
                                                if (k > j) {
                                                    c -= (k - j) * m / g;
                                                    k = j
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        p = [d, n, c, k]
                    } else {
                        return false
                    }
                }
            }
        }
        return p
    };
    this.lineLength = function (b, d, a, c) {
        return Math.sqrt(Math.pow(a - b, 2) + Math.pow(c - d, 2))
    };
    this.shortenLine = function (b, j, a, i, k, f, l) {
        if (this.validateNumbers([b, j, a, i, k, f])) {
            if (l.match(/bezier/)) {
                if (l.match(/beziery/i)) {
                    return i > j ? [b, j + k, a, i - f] : [b, j - k, a, i + f]
                } else {
                    return a > b ? [b + k, j, a - f, i] : [b - k, j, a + f, i]
                }
            } else {
                if (l.match(/curved/)) {
                    return [b, j, a, i]
                } else {
                    var c = Math.atan2(i - j, a - b);
                    var d = Math.cos(c);
                    var h = Math.sin(c);
                    var g = this.lineLength(b, j, a, i);
                    if (g) {
                        while (g < (k + f)) {
                            k /= 1.1;
                            f /= 1.1
                        }
                        b += d * k;
                        j += h * k;
                        a -= d * f;
                        i -= h * f
                    }
                }
            }
            return [b, j, a, i]
        }
    };
    this.errorBar = function (e, g, d, f, a, h) {
        if (!this.isGroupedData && this.isRawData) {}
        if (this.showErrorBars && this.validateNumbers([a])) {
            var b = this.drawLine("line", e, g, d, f, h, false, false, false, false, true);
            if (a > 0) {
                this.drawLine("line", d, f - a / 2, d, f + a / 2, h, false, false, false, false, true)
            } else {
                this.drawLine("line", d - a / 2, f, d + a / 2, f, h, false, false, false, false, true)
            }
            return b
        }
    };
    this.splineControlPoint = function (e, m, d, l, c, k) {
        var n = Math.sqrt(Math.pow(d - e, 2) + Math.pow(l - m, 2));
        var h = Math.sqrt(Math.pow(c - d, 2) + Math.pow(k - l, 2));
        var g = this.tension * n / (n + h);
        var f = this.tension - g;
        var b = d + g * (e - c);
        var a = l + g * (m - k);
        var j = d - f * (e - c);
        var i = l - f * (m - k);
        return [b, a, j, i]
    };
    this.drawLine = function (Z, G, a, D, ar, al, Y, ad, ab, an, ao, aq) {
        var S = this;
        var ag;
        var N = [];
        var U = false;
        var z = false;
        var v = false;
        var T = function () {
            S.ctx.save();
            if (S.transparency != null) {
                if (al) {
                    al = S.validateColor(al, S.transparency) || S.addColorTransparency(S.foreground, S.transparency)
                } else {
                    al = S.addColorTransparency(S.foreground, S.transparency)
                }
            } else {
                if (al) {
                    al = S.validateColor(al) || S.foreground
                } else {
                    al = S.foreground
                }
            }
			
		    S.ctx.fillStyle = al;
            S.ctx.strokeStyle = al;
            S.ctx.lineWidth = Y ? Y : S.outlineWidth;
            S.ctx.lineCap = ad ? ad : S.capType;
            if (S.showShadow) {
                S.ctx.shadowOffsetX = S.shadowOffsetX;
                S.ctx.shadowOffsetY = S.shadowOffsetY;
                S.ctx.shadowBlur = S.shadowBlur;
                S.ctx.shadowColor = S.shadowColor
            }
        };
        var I = function () {
            if (S.showShadow) {
                S.ctx.shadowOffsetX = 0;
                S.ctx.shadowOffsetY = 0;
                S.ctx.shadowBlur = 0;
                S.ctx.shadowColor = S.background
            }
            S.ctx.restore()
        };
        var h = function () {
            var b;
            b = G;
            G = D;
            D = b;
            b = a;
            a = ar;
            ar = b
        };
        var H = function (n) {
            var ax = function (aC, aF, aA, aG) {
                var aB = [];
				for (var aD = 0; aD < aC.length; aD++) {
                    aB.push([(aC[aD][0] * Math.cos(aF)) - (aC[aD][1] * Math.sin(aF)), (aC[aD][0] * Math.sin(aF)) + (aC[aD][1] * Math.cos(aF))])
                }
                var aE = [];
                for (var aD = 0; aD < aB.length; aD++) {
                    aE.push([aB[aD][0] + aA, aB[aD][1] + aG])
                }
                return aE
            };
            var at = S.arrowPointSize;
            var c = Math.max((at / 2) - 1, 1);
            var x = Y ? Y / 2 : S.outlineWidth / 2;
            var y = n ? [
                [0, - at],
                [0, at]
            ] : [
                [Math.floor((at / 2.5)), 0],
                [-at, - c * Y],
                [-at, c * Y]
            ];
            var w = D - G;
            var p = ar - a;
            if (z) {
                if (z == "Y") {
                    if (Math.abs(p) > Math.abs(w)) {
                        w = 0
                    } else {
                        w = D > G ? S.arrowPointSize : -S.arrowPointSize
                    }
                } else {
                    if (Math.abs(w) > Math.abs(p)) {
                        p = 0
                    } else {
                        p = ar > a ? S.arrowPointSize : -S.arrowPointSize
                    }
                }
            } else {
                if (v) {
                    var s = S.lineLength(G, a, D, ar);
                    var az = S.shortenLine(G, a, D, ar, 0, s / 2, "line");
                    var t = az[2];
                    var ay = az[3];
                    var au = s / 2;
                    var e = v / au;
                    var av = D > G ? Math.asin((ay - a) / au) : Math.asin(-(ay - a) / au);
                    var b = av - (Math.PI / 20);
                    if (D > G) {
                        G = t + au * Math.cos(b - e);
                        a = ay + au * Math.sin(b - e);
                        D = t + au * Math.cos(av - e);
                        ar = ay + au * Math.sin(av - e)
                    } else {
                        G = t + au * Math.cos((b - e) + Math.PI);
                        a = ay + au * Math.sin((b - e) + Math.PI);
                        D = t + au * Math.cos((av - e) + Math.PI);
                        ar = ay + au * Math.sin((av - e) + Math.PI)
                    }
                    w = D - G;
                    p = ar - a
                }
            }
            var f = ax(y, Math.atan2(p, w), D, ar);
            T();
            S.ctx.beginPath();
            S.ctx.moveTo(f[0][0], f[0][1]);
            for (var aw = 1; aw < f.length; aw++) {
                if (!isNaN(f[aw][0]) && !isNaN(f[aw][1])) {
                    S.ctx.lineTo(f[aw][0], f[aw][1])
                }
            }
            if (!n) {
                if (!isNaN(f[0][0]) && !isNaN(f[0][1])) {
                    S.ctx.lineTo(f[0][0], f[0][1])
                }
                S.ctx.closePath();
                S.ctx.fill()
            } else {
                S.ctx.closePath();
                S.ctx.stroke()
            }
            I()
        };
        if (Z == "spline") {
            if (G.length < 3) {
                return false
            }
            var aa = [];
            var ap = [];
            var ac = [];
            var af = 0;
            N = ["poly"];
            for (var aj = 0; aj < G.length; aj++) {
                if (this.validateNumbers([G[aj], a[aj]])) {
                    ap.push(G[aj], a[aj]);
                    N.push(G[aj], a[aj] - 2);
                    ac.push(a[aj] + 2, G[aj]);
                    af += 2
                } else {
                    return false
                }
            }
            N = N.concat(ac.reverse());
            T();
            for (var aj = 0; aj < af - 4; aj += 2) {
                aa = aa.concat(this.splineControlPoint(ap[aj], ap[aj + 1], ap[aj + 2], ap[aj + 3], ap[aj + 4], ap[aj + 5]))
            }
            this.ctx.beginPath();
            this.ctx.moveTo(ap[0], ap[1]);
            this.ctx.quadraticCurveTo(aa[0], aa[1], ap[2], ap[3]);
            for (var aj = 2; aj < af - 5; aj += 2) {
                this.ctx.bezierCurveTo(aa[2 * aj - 2], aa[2 * aj - 1], aa[2 * aj], aa[2 * aj + 1], ap[aj + 2], ap[aj + 3])
            }
            this.ctx.moveTo(ap[af - 2], ap[af - 1]);
            this.ctx.quadraticCurveTo(aa[2 * af - 10], aa[2 * af - 9], ap[af - 4], ap[af - 3]);
            this.ctx.stroke();
            I();
            return N
        } else {
            if (this.validateNumbers([G, a, D, ar])) {
                if (!ab) {
                    ab = 0
                }
                if (!an) {
                    an = 0
                }
                if (Z.match(/bezier/i)) {
                    if (Z.match(/beziery/i)) {
                        ag = "bezierLine";
                        z = "Y";
                        U = "Y";
                        if (ab || an) {
                            if (ar > a) {
                                if (a + ab > ar - an) {
                                    Z = Z.replace(/beziery/i, "");
                                    ag = "line";
                                    z = false;
                                    U = false
                                }
                            } else {
                                if (a - ab < ar + an) {
                                    Z = Z.replace(/beziery/i, "");
                                    ag = "line";
                                    z = false;
                                    U = false
                                }
                            }
                        }
                    } else {
                        ag = "bezierLine";
                        z = "X";
                        U = "X";
                        if (ab || an) {
                            if (D > G) {
                                if (G + ab > D - an) {
                                    Z = Z.replace(/bezier[x]?/i, "");
                                    ag = "line";
                                    z = false;
                                    U = false
                                }
                            } else {
                                if (G - ab < D + an) {
                                    Z = Z.replace(/bezier[x]?/i, "");
                                    ag = "line";
                                    z = false;
                                    U = false
                                }
                            }
                        }
                    }
                } else {
                    if (Z.match(/curved/i)) {
                        if (Z.match(/curvedc/i)) {
                            ag = "curvedLine";
                            v = true;
                            U = true
                        } else {
                            ag = "curvedLine";
                            v = true;
                            U = false
                        }
                    } else {
                        if (Z.match(/dashed/i)) {
                            ag = "dashedLine"
                        } else {
                            if (Z.match(/dotted/i)) {
                                ag = "dottedLine"
                            } else {
                                ag = "line"
                            }
                        }
                    }
                }
                if (ab || an) {
                    var ae = this.shortenLine(G, a, D, ar, ab, an, Z);
                    G = ae[0];
                    a = ae[1];
                    D = ae[2];
                    ar = ae[3]
                }
                if (ao) {
                    var L = this.clip("line", [G, a, D, ar], aq);
                    if (L) {
                        G = L[0];
                        a = L[1];
                        D = L[2];
                        ar = L[3]
                    } else {
                        return false
                    }
                }
                switch (ag) {
                    case "dashedLine":
                    case "dottedLine":
                        var l = Math.atan2(ar - a, D - G);
                        var R = Math.cos(l);
                        var J = Math.sin(l);
                        var M = this.lineLength(G, a, D, ar);
                        var q = ag == "dashedLine" ? this.dashLength : this.dotLength;
                        var ai = Math.floor(M / (q * 2));
                        if (ai) {
                            var W = R * q;
                            var V = J * q;
                            var g = G;
                            var am = a;
                            var d = D;
                            var ak = ar;
                            d = g + W;
                            ak = am + V;
                            for (var aj = 0; aj < ai; aj++) {
                                this.drawLine("line", g, am, d, ak, al, Y, ad);
                                g += (W * 2);
                                am += (V * 2);
                                d = g + W;
                                ak = am + V
                            }
                            this.drawLine("line", g, am, d, ak, al, Y, ad);
                            N = ["poly", G + 2, a, D + 2, ar, D - 2, ar, G - 2, a]
                        } else {
                            return false
                        }
                        break;
                    case "bezierLine":
                        if (G == D || a == ar) {
                            return this.drawLine("line", G, a, D, ar, al, Y, ad, ab, an, ao, aq)
                        }
                        G = parseInt(G) + 0.5;
                        a = parseInt(a) + 0.5;
                        D = parseInt(D) + 0.5;
                        ar = parseInt(ar) + 0.5;
                        U = U == "Y" ? "Y" : "X";
                        var P = D > G ? true : false;
                        var o = (G + D) / 2;
                        var m = (a + ar) / 2;
                        if (P) {
                            if (U == "X") {
                                N = ["poly", G, a - 2, o + 2, a - 2, o + 2, ar - 2, D, ar - 2, D, ar + 2, o - 2, ar + 2, o - 2, a + 2, G, a + 2]
                            } else {
                                N = ["poly", G - 2, a, G - 2, m + 2, D - 2, m + 2, D - 2, ar, D + 2, ar, D + 2, m - 2, G + 2, m - 2, G + 2, a]
                            }
                        } else {
                            if (U == "X") {
                                N = ["poly", G, a - 2, o - 2, a - 2, o - 2, ar - 2, D, ar - 2, D, ar + 2, o + 2, ar + 2, o + 2, a + 2, G, a + 2]
                            } else {
                                N = ["poly", G - 2, a, G - 2, m - 2, D - 2, m - 2, D - 2, ar, D + 2, ar, D + 2, m + 2, G + 2, m + 2, G + 2, a]
                            }
                        }
                        T();
                        this.ctx.moveTo(G, a);
                        if (U == "Y") {
                            this.ctx.bezierCurveTo(G, ar, D, a, D, ar)
                        } else {
                            this.ctx.bezierCurveTo(D, a, G, ar, D, ar)
                        }
                        this.ctx.stroke();
                        I();
                        break;
                    case "curvedLine":
                        var o = 12;
                        var u = 1;
                        var M = this.lineLength(G, a, D, ar);
                        var F = this.shortenLine(G, a, D, ar, 0, M / 2, "line");
                        var Q = F[2];
                        var E = F[3];
                        var X = M / 2;
                        var O = ab / X;
                        var K = an / X;
                        var k = (Q - G);
                        var j = (E - a);
                        var C = U && G > D ? false : !U && D >= G ? true : U;
                        var r = D >= G ? Math.asin(j / X) : Math.asin(-j / X);
                        var ah = r + Math.PI;
                        var B = Math.PI / o;
                        var A = D >= G ? 0 : Math.PI;
                        N = ["poly"];
                        for (var aj = u; aj <= o - u; aj++) {
                            N.push(Q - (X + 2) * Math.cos(r + ((B * aj)) - A));
                            N.push(E - (X + 2) * Math.sin(r + ((B * aj)) - A))
                        }
                        for (var aj = o - u; aj >= u; aj--) {
                            N.push(Q - (X - 2) * Math.cos(r + ((B * aj)) - A));
                            N.push(E - (X - 2) * Math.sin(r + ((B * aj)) - A))
                        }
                        T();
                        this.ctx.beginPath();
                        if (D >= G) {
                            this.ctx.arc(Q, E, X, r - K, ah + O, C)
                        } else {
                            this.ctx.arc(Q, E, X, r + O, ah - K, C)
                        }
                        this.ctx.stroke();
                        I();
                        break;
                    case "line":
                        N = ["poly", G + 2, a, D + 2, ar, D - 2, ar, G - 2, a];
                        T();
                        this.ctx.beginPath();
                        this.lineTo(G, a, D, ar);
                        I();
                        break
                }
                if (Z.match(/arrowheadsquaretail|squaretailarrowhead/i)) {
                    v = v ? an : false;
                    H(false, z, v);
                    if (!Z.match(/curve/)) {
                        h()
                    }
                    v = v ? ab : false;
                    H(true, z, v)
                } else {
                    if (Z.match(/arrowtailsquarehead|squareheadarrowtail/i)) {
                        v = v ? an : false;
                        H(true, z, v);
                        if (!Z.match(/curve/)) {
                            h()
                        }
                        v = v ? ab : false;
                        H(false, z, v)
                    } else {
                        if (Z.match(/arrowhead/i)) {
                            v = v ? an : false;
                            H(false, z, v)
                        } else {
                            if (Z.match(/squarehead/i)) {
                                v = v ? an : false;
                                H(true, z, v)
                            } else {
                                if (Z.match(/arrowtail/i)) {
                                    if (!Z.match(/curve/)) {
                                        h()
                                    }
                                    v = v ? ab : false;
                                    H(false, z, v)
                                } else {
                                    if (Z.match(/squaretail/i)) {
                                        if (!Z.match(/curve/)) {
                                            h()
                                        }
                                        v = v ? ab : false;
                                        H(true, z, v)
                                    } else {
                                        if (Z.match(/arrow/i)) {
                                            v = v ? an : false;
                                            H(false, z, v);
                                            if (!Z.match(/curve/)) {
                                                h()
                                            }
                                            v = v ? ab : false;
                                            H(false, z, v)
                                        } else {
                                            if (Z.match(/square/i)) {
                                                v = v ? ab : false;
                                                H(true, z, v);
                                                if (!Z.match(/curve/)) {
                                                    h()
                                                }
                                                v = v ? an : false;
                                                H(true, z, v)
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                return N
            } else {
                return false
            }
        }
    };
    this.polygon = function (l, k, g, e, d, a, i, h, j) {
        return this.drawShape("polygon", l, k, false, false, g, e, d, a, i, h, j)
    };
    this.circle = function (n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("circle", n, m, q, g, i, e, d, a, k, j, l)
    };
    this.rectangle = function (n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("rectangle", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
    };
    this.rectangleHM = function (n, m, q, g, i, e, d, a, k, j, l) {
        return this.drawShape("rectangleHM", n + (q / 2), m + (g / 2), q, g, i, e, d, a, k, j, l)
    };
    this.drawShape = function (P, L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai) {
		
        var I = this;
        var T = function () {
            I.ctx.save();
            I.ctx.translate(L, K);
            if (R) {
                I.ctx.rotate(R)
            }
            if (I.transparency != null) {
                if (ad) {
                    ad = I.validateColor(ad, I.transparency) || I.addColorTransparency(I.foreground, I.transparency)
                } else {
                    ad = I.addColorTransparency(I.foreground, I.transparency)
                }
            } else {
                if (ad) {
                    ad = I.validateColor(ad) || I.foreground
                } else {
                    ad = I.foreground
                }
            }
            if (I.gradient) {
                if (I.gradientType == "radial") {
                    I.setGradient(0, 0, Math.max(Math.abs(N), Math.abs(ac)), ad)
                } else {
                    I.setGradient(0, 0, N, ac, ad)
                }
            } else {
				//alert("ad " + ad); //Color
                I.ctx.fillStyle = ad
            }
            if (W) {
                W = I.validateColor(W) || I.foreground
            }
            I.ctx.strokeStyle = W ? W : I.foreground;
            I.ctx.lineWidth = J ? J : I.outlineWidth;
            if (I.showShadow) {
                I.ctx.shadowOffsetX = I.shadowOffsetX;
                I.ctx.shadowOffsetY = I.shadowOffsetY;
                I.ctx.shadowBlur = I.shadowBlur;
                I.ctx.shadowColor = I.shadowColor
            }
        };
        var ap = function (f, d, o) {
			if (P == "image") 
				{} 
			else {
				if (P == "rectangleHM") {
                    if (f) {
                        f[0][0] = Math.round(f[0][0]) + 0.5;
                        f[3][0] = f[0][0];
                        f[1][0] = Math.round(f[1][0]) + 1.5;
                        f[2][0] = f[1][0];
                        f[0][1] = Math.round(f[0][1]) + 0.5;
                        f[1][1] = f[0][1];
                        f[2][1] = Math.round(f[2][1]) + 1.5;
                        f[3][1] = f[2][1];
                        I.ctx.beginPath();
                        I.ctx.moveTo(f[0][0], f[0][1]);
                        for (var e = 1; e < f.length; e++) {
                            I.ctx.lineTo(f[e][0], f[e][1])
                        }
                        if (!d) {
                            I.ctx.closePath()
                        }
                        if (V && V == "open") {
                            I.ctx.stroke()
                        } else {
                            I.ctx.stroke();
                            I.ctx.fill()
                        }
                    }
                } 
				else {
                    if (P == "spline") {
                        var h = [];
                        var c = [];
                        var b = [];
                        c.push(o.shift());
                        c.push(o.shift());
                        b.push(o.pop());
                        b.unshift(o.pop());
                        var p = o.length;
                        for (var e = 0; e < p - 4; e += 2) {
                            h = h.concat(I.splineControlPoint(o[e], o[e + 1], o[e + 2], o[e + 3], o[e + 4], o[e + 5]))
                        }
                        I.ctx.beginPath();
                        I.ctx.moveTo(c[0], c[1]);
                        I.ctx.lineTo(o[0], o[1]);
                        I.ctx.quadraticCurveTo(h[0], h[1], o[2], o[3]);
                        for (var e = 2; e < p - 5; e += 2) {
                            I.ctx.bezierCurveTo(h[2 * e - 2], h[2 * e - 1], h[2 * e], h[2 * e + 1], o[e + 2], o[e + 3])
                        }
                        I.ctx.quadraticCurveTo(h[2 * p - 10], h[2 * p - 9], o[p - 2], o[p - 1]);
                        I.ctx.lineTo(b[0], b[1]);
                        I.ctx.lineTo(c[0], c[1]);
                        if (V && V == "open") {
                            I.ctx.stroke()
                        } else {
                            I.ctx.stroke();
                            I.ctx.fill()
                        }
                    } 
					else {
                        if (P == "arc3") {
                            I.ctx.stroke()
                        } 
					else {
							if (f) {
								I.ctx.beginPath();
								
                                I.ctx.moveTo(f[0][0] + 0.5, f[0][1] + 0.5);
                                for (var e = 1; e < f.length; e++) {
                                    I.ctx.lineTo(f[e][0] + 0.5, f[e][1] + 0.5)
                                }
                                if (!d) {
                                    I.ctx.closePath()
                                }
								
                            }
                            if (V && V == "open") {
								I.ctx.stroke()
                            } else {
								I.ctx.fill()
                            }
                        }
                    }
                }
            }
            if (I.showShadow) {
                I.ctx.shadowOffsetX = 0;
                I.ctx.shadowOffsetY = 0;
                I.ctx.shadowBlur = 0;
                I.ctx.shadowColor = I.background
            }
			I.ctx.restore()
			
			
        };
        var ae = function (p) {
            if (p) {
                if (p[0] == "circle") {
                    return p
                }
                var e = p.shift();
                var i = [];
                if (e == "rect") {
                    var o = p.shift() - L;
                    var r = p.shift() - K;
                    var d = p.shift() - L;
                    var f = p.shift() - K;
                    i.push((r * Math.sin(R)) - (o * Math.cos(R)));
                    i.push((r * Math.cos(R)) + (o * Math.sin(R)));
                    i.push((f * Math.sin(R)) - (o * Math.cos(R)));
                    i.push((f * Math.cos(R)) + (o * Math.sin(R)));
                    i.push((f * Math.sin(R)) - (d * Math.cos(R)));
                    i.push((f * Math.cos(R)) + (d * Math.sin(R)));
                    i.push((r * Math.sin(R)) - (d * Math.cos(R)));
                    i.push((r * Math.cos(R)) + (d * Math.sin(R)))
                } else {
                    while (p.length > 1) {
                        var h = p.shift() - L;
                        var b = p.shift() - K;
                        i.push((b * Math.sin(R)) - (h * Math.cos(R)));
                        i.push((b * Math.cos(R)) + (h * Math.sin(R)))
                    }
                }
                var c = ["poly"];
                while (i.length > 1) {
                    c.push(i.shift() + L);
                    c.push(i.shift() + K) 
                }
                return c
            }
        };
        var G, H;
		
		if (P == "polygon" || P == "path" || P == "spline") {
        	var Z = Number.MAX_VALUE;
            var E = Number.MAX_VALUE * -1;
            var Y = Number.MAX_VALUE;
            var D = Number.MAX_VALUE * -1;
            var F = P == "polygon" ? false : true;
            var U = [];
            var ak = [];
            G = [];
            H = ["poly"];
            if (L.length == K.length) {
                if (P == "spline" && L.length < 5) {
                    return false
                }
                for (var ab = 0; ab < L.length; ab++) {
                    if (this.validateNumbers([L[ab], K[ab]])) {
                        Z = Math.min(Z, L[ab]);
                        E = Math.max(E, L[ab]);
                        Y = Math.min(Y, K[ab]);
                        D = Math.max(D, K[ab]);
                        G.push([L[ab], K[ab]]);
                        if (P == "spline") {
                            H.push(L[ab], K[ab] - 2);
                            U.push(K[ab] + 2, L[ab])
                        } else {
                            H.push(L[ab], K[ab])
                        }
                    } else {
                        return false
                    }
                }
                L = (Z + E) / 2;
                K = (Y + D) / 2;
                for (var ab = 0; ab < G.length; ab++) {
                    G[ab][0] -= L;
                    G[ab][1] -= K;
                    ak.push(G[ab][0], G[ab][1])
                }
                if (R) {
                    H = ae(H)
                }
                if (G) {
                    if (P == "spline") {
                        H = H.concat(U.reverse())
                    }
                    T(F);
                    ap(G, F, ak);
                    return H
                } else {
                    return false
                }
            } else {
                return false
            }
        } 
		else {
            if (this.validateNumbers([L, K, N, ac])) {
                if (aj) {
                    G = P.match(/rectangle/) ? this.clip("rect", [L - (N / 2), K - (ac / 2), N, ac], al) : this.clip("circle", [L, K], al);
                    if (G) {
                        if (P.match(/rectangle/)) {
                            N = G[2];
                            ac = G[3];
                            L = G[0] + (N / 2);
                            K = G[1] + (ac / 2)
                        } else {
                            L = G[0];
                            K = G[1]
                        }
                    } else {
                        return false
                    }
                }
                var j = N / 2;
                var am = ac / 2;
                var S = ac / N;
                var X = 1.5;
                var H = ["rect", L - j, K - am, L + j, K + am];
				switch (P) {
                    case "image":
                        G = false;
                        this.ctx.save();
                        this.ctx.translate(L, K);
                        if (R) {
                            this.ctx.rotate(R)
                        }
                        this.drawImage(CanvasXpress.cacheImages[O], - j * this.zoom, - am * this.zoom, N * this.zoom, ac * this.zoom);
                        H = ["rect", L - (j * this.zoom), K - (am * this.zoom), L + (j * this.zoom), K + (am * this.zoom)];
                        this.ctx.restore();
                        break;
                    case "circle":
                    case "sphere":
						H = ["circle", L, K,  N / 2];
						var isInd= false;
						//alert(ad);
						if(ad == colorCombination('INDIVIDUAL')){
							isInd = true;
							drawArrow(I.ctx,(L - 10),(K-5),(L-40),(K-40),0,2);
						}
						G = false;
						T();
						this.ctx.beginPath();
						if(isInd == true)
							this.ctx.arc(0, 0, N , 0, Math.PI * 2, true);
						else	
							this.ctx.arc(0, 0, N/2 , 0, Math.PI * 2, true);
						this.ctx.closePath();
						
						
						ap();
						break;
                    case "box":
                    case "rect":
                    case "rectangle":
                    case "rectangleHM":
                        G = [
                            [-j, - am],
                            [j, - am],
                            [j, am],
                            [-j, am]
                        ];
                        break;
                    case "rect2":
                        return this.drawShape("rectangle", L, K, N, N / 2, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "rect3":
                        return this.drawShape("rectangle", L, K, N, N / 3, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "roundrect":
                        var M = N > ac ? ac / 4 : N / 4;
                        G = false;
                        T();
                        this.ctx.beginPath();
                        ctx.moveTo(-j, - am + M);
                        ctx.lineTo(-j, am - M);
                        ctx.quadraticCurveTo(-j, am, - j + M, am);
                        ctx.lineTo(j - M, am);
                        ctx.quadraticCurveTo(j, am, j, am - M);
                        ctx.lineTo(j, - am + M);
                        ctx.quadraticCurveTo(j, - am, j - M, - am);
                        ctx.lineTo(-j + M, - am);
                        ctx.quadraticCurveTo(-j, - am, - j, - am + M);
                        this.ctx.closePath();
                        ap();
                        break;
                    case "square":
                        G = [
                            [-j, - j],
                            [j, - j],
                            [j, j],
                            [-j, j]
                        ];
                        break;
                    case "triangle":
                        if (N == ac) {
                            return this.drawShape("equilateral", L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai)
                        }
                        H = ["poly", L, K - am, L + j, K + am, L - j, K + am];
                        G = [
                            [0, - am],
                            [j, am],
                            [-j, am]
                        ];
                        break;
                    case "triangle2":
                        if (N == ac) {
                            return this.drawShape("equilateral2", L, K, N, ac, ad, W, V, R, J, aj, al, Q, ag, O, ai)
                        }
                        H = ["poly", L, K + am, L + j, K - am, L - j, K - am];
                        G = [
                            [0, am],
                            [j, - am],
                            [-j, - am]
                        ];
                        break;
                    case "equilateral":
                        var M = N * Math.sqrt(3) / 6;
                        var g = M / 2;
                        var v = Math.sqrt((M * M) - (g * g));
                        H = ["poly", L, K - M, L + v, K + g, L - v, K + g];
                        G = [
                            [0, - am],
                            [j, am],
                            [-j, am]
                        ];
                        break;
                    case "equilateral2":
                        var M = N * Math.sqrt(3) / 6;
                        var g = M / 2;
                        var v = Math.sqrt((M * M) - (g * g));
                        H = ["poly", L, K + M, L + v, K - g, L - v, K - g];
                        G = [
                            [0, am],
                            [j, - am],
                            [-j, - am]
                        ];
                        break;
                    case "diamond":
                    case "rhombus":
                        H = ["poly", L, K - am, L + j, K, L, K + am, L - j, K];
                        G = [
                            [0, - am],
                            [j, 0],
                            [0, am],
                            [-j, 0]
                        ];
                        break;
                    case "hexagon":
                        var ah = N / 3;
                        var l = ah - j;
                        G = [
                            [l, - am],
                            [-l, - am],
                            [j, 0],
                            [-l, am],
                            [l, am],
                            [-j, 0]
                        ];
                        break;
                    case "octagon":
                        var an = N / 4;
                        var aa = ac / 4;
                        G = [
                            [-an, - am],
                            [an, - am],
                            [j, - aa],
                            [j, aa],
                            [an, am],
                            [-an, am],
                            [-j, aa],
                            [-j, - aa]
                        ];
                        break;
                    case "oval":
                        G = false;
                        T();
                        this.ctx.scale(1, S);
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, 0, Math.PI * 2, true);
                        this.ctx.closePath();
                        ap();
                        break;
                    case "oval2":
                        return this.drawShape("oval", L, K, N, N / 2, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "oval3":
                        return this.drawShape("oval", L, K, N, N / 3, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "arc":
                        G = false;
                        T();
                        this.ctx.scale(1, S);
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, 0, Math.PI, true);
                        if (V != "open") {
                            this.ctx.closePath()
                        }
                        ap();
                        break;
                    case "arc2":
                        G = false;
                        var B = ac * Math.cos(Q);
                        var aq = ac * Math.sin(Q);
                        var A = ac * Math.cos(ag);
                        var ao = ac * Math.sin(ag);
                        var q = this.shortenLine(0, 0, B, aq, 0, N, "line");
                        var m = this.shortenLine(0, 0, A, ao, 0, N, "line");
                        T();
                        this.ctx.beginPath();
                        this.ctx.moveTo(q[2], q[3]);
                        this.ctx.lineTo(B, aq);
                        this.ctx.arc(0, 0, ac, Q, ag, false);
                        this.ctx.lineTo(m[2], m[3]);
                        this.ctx.arc(0, 0, ac - N, ag, Q, true);
                        this.ctx.closePath();
                        ap();
                        break;
                    case "arc3":
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, Q, ag, false);
                        ap();
                        break;
                    case "ellipse":
                        var a = j * 0.5522848;
                        var af = am * 0.5522848;
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, am);
                        this.ctx.bezierCurveTo(0, am - af, j - a, 0, j, 0);
                        this.ctx.bezierCurveTo(j + a, 0, N, am - af, N, am);
                        this.ctx.bezierCurveTo(N, am + af, j + a, ac, j, ac);
                        this.ctx.bezierCurveTo(j - a, ac, 0, am + af, 0, am);
                        this.ctx.closePath();
                        ap();
                        break;
                    case "ellipse2":
                        return this.drawShape("ellipse", L, K, N, N / 2, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "ellipse3":
                        return this.drawShape("ellipse", L, K, N, N / 3, ad, W, V, R, J, aj, al, Q, ag, O, ai);
                        break;
                    case "plus":
                        G = [
                            [-X, - am],
                            [X, - am],
                            [X, - X],
                            [j, - X],
                            [j, X],
                            [X, X],
                            [X, am],
                            [-X, am],
                            [-X, X],
                            [-j, X],
                            [-j, - X],
                            [-X, - X],
                            [-X, - am]
                        ];
                        break;
                    case "minus":
                        G = [
                            [-j, - X],
                            [j, - X],
                            [j, X],
                            [-j, X],
                            [-j, - X]
                        ];
                        break;
                    case "mdavid":
                        var ah = N / 3;
                        var n = Math.PI / 6;
                        H = ["circle", L, K, N / 2];
                        G = false;
                        T();
                        this.ctx.beginPath();
                        this.ctx.moveTo(ah, 0);
                        for (var ab = 0; ab < 11; ab++) {
                            this.ctx.rotate(n);
                            if (ab % 2 == 0) {
                                this.ctx.lineTo((ah / 0.55), 0)
                            } else {
                                this.ctx.lineTo(ah, 0)
                            }
                            this.ctx.closePath()
                        }
                        ap();
                        break;
                    case "star":
                        var k = (N / 4);
                        var C = Math.PI / 5;
                        H = ["circle", L, K, N / 2];
                        G = false;
                        T();
                        this.ctx.save();
                        this.ctx.scale(0.7, 0.7);
                        this.ctx.rotate(C * 0.45);
                        this.ctx.beginPath();
                        this.ctx.moveTo(k, 0);
                        for (var ab = 0; ab < 9; ab++) {
                            this.ctx.rotate(C);
                            if (ab % 2 == 0) {
                                this.ctx.lineTo((k / 0.35), 0)
                            } else {
                                this.ctx.lineTo(k, 0)
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.restore();
                        ap();
                        break;
                    case "pie":
                        if (typeof (Q) == "undefined") {
                            Q = 0
                        }
                        if (typeof (ag) == "undefined") {
                            ag = Math.PI * 2
                        }
                        G = false;
                        T();
                        this.ctx.scale(1, S);
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, N / 2, Q, ag, false);
                        this.ctx.closePath();
                        ap();
                        break;
                    case "pie0":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 5, O, ai);
                        break;
                    case "pie1":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 3.5, O, ai);
                        break;
                    case "pie2":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 2, O, ai);
                        break;
                    case "pie3":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI / 1.5, O, ai);
                        break;
                    case "pie4":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI, O, ai);
                        break;
                    case "pie5":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.2, O, ai);
                        break;
                    case "pie6":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.4, O, ai);
                        break;
                    case "pie7":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.6, O, ai);
                        break;
                    case "pie8":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 1.8, O, ai);
                        break;
                    case "pie9":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, 0, Math.PI * 2, O, ai);
                        break;
                    case "pacman":
                        return this.drawShape("pie", L, K, N, N / 2, ad, W, V, R, J, aj, al, Math.PI * 5 / 4, Math.PI * 3 / 4, O, ai);
                        break
                }
                if (R) {
					H = ae(H)
                }
                if (G) {
                    T();
                    ap(G)
                }
				return H
            } else {
                return false
            }
        }
    };
    this.drawImage = function (d, b, c, a, f) {
        try {
            this.ctx.drawImage(d, b, c, a, f)
        } catch (g) {}
    };
    this.setRGB = function () {
        this.reds = [];
        this.greens = [];
        this.blues = [];
        this.yellows = [];
        this.cyans = [];
        this.purples = [];
        this.greys = [];
        this.indicatorBins = this.allVsAll ? Math.min(this.x, this.y) / (this.layoutRows * 2) : Math.min(this.x, this.y) / 4;
        this.indicatorBins = this.indicatorBins > 512 ? 1 : this.indicatorBins > 256 ? 2 : this.indicatorBins > 128 ? 4 : 8;
        var e = this.indicatorBins;
        var c = parseInt(256 / e);
        var d;
        var b = 255;
        for (var a = 0; a < c; a++) {
            this.greys.push("rgb(" + b + "," + b + "," + b + ")");
            b -= e
        }
        if (this.indicatorCenter == "rainbow-green") {
            d = e - 1;
            b = 255;
            for (var a = 0; a < c; a++) {
                this.greens.push("rgb(0,255," + d + ")");
                this.cyans.push("rgb(0," + b + ",255)");
                this.blues.push("rgb(" + d + ",0,255)");
                this.purples.push("rgb(255,0," + b + ")");
                this.reds.push("rgb(255," + d + ",0)");
                this.yellows.push("rgb(" + b + ",255,0)");
                d += e;
                b -= e
            }
        } else {
            if (this.indicatorCenter.match("rainbow")) {
                d = e - 1;
                b = 255;
                for (var a = 0; a < c; a++) {
                    this.reds.push("rgb(255,0," + d + ")");
                    this.purples.push("rgb(" + b + ",0,255)");
                    this.blues.push("rgb(0," + d + ",255)");
                    this.cyans.push("rgb(0,255," + b + ")");
                    this.greens.push("rgb(" + d + ",255,0)");
                    this.yellows.push("rgb(255," + b + ",0)");
                    d += e;
                    b -= e
                }
            } else {
                if (this.indicatorCenter == "black") {
                    d = 255;
                    for (var a = 0; a < c; a++) {
                        this.reds.push("rgb(" + d + ",0,0)");
                        this.purples.push("rgb(" + d + ",0," + d + ")");
                        this.blues.push("rgb(0,0," + d + ")");
                        this.cyans.push("rgb(0," + d + "," + d + ")");
                        this.greens.push("rgb(0," + d + ",0)");
                        this.yellows.push("rgb(" + d + "," + d + ",0)");
                        d -= e
                    }
                } else {
                    this.reds.push("rgb(255,0,0)");
                    this.purples.push("rgb(255,0,255)");
                    this.blues.push("rgb(0,0,255)");
                    this.cyans.push("rgb(0,255,255)");
                    this.greens.push("rgb(0,255,0)");
                    this.yellows.push("rgb(255,255,0)");
                    d = e - 1;
                    for (var a = 0; a < c - 1; a++) {
                        this.reds.push("rgb(255," + d + "," + d + ")");
                        this.purples.push("rgb(255," + d + ",255)");
                        this.blues.push("rgb(" + d + "," + d + ",255)");
                        this.cyans.push("rgb(" + d + ",255,255)");
                        this.greens.push("rgb(" + d + ",255," + d + ")");
                        this.yellows.push("rgb(255,255," + d + ")");
                        d += e
                    }
                }
            }
        }
    };
    this.setLineTypes = function () {
        this.lines = this.getLineTypes()
    };
    this.setCodonTable = function () {
        this.codon = {
            TTT: ["F", "Phe", "Phenylalanine"],
            TCT: ["S", "Ser", "Serine"],
            TAT: ["Y", "Tyr", "Tyrosine"],
            TGT: ["C", "Cys", "Cysteine"],
            TTC: ["F", "Phe", "Phenylalanine"],
            TCC: ["S", "Ser", "Serine"],
            TAC: ["Y", "Tyr", "Tyrosine"],
            TGC: ["C", "Cys", "Cysteine"],
            TTA: ["L", "Leu", "Leucine"],
            TCA: ["S", "Ser", "Serine"],
            TAA: ["*", "Stop", "Ochre"],
            TGA: ["*", "Stop", "Opal"],
            TTG: ["L", "Leu", "Leucine"],
            TCG: ["S", "Ser", "Serine"],
            TAG: ["*", "Stop", "Amber"],
            TGG: ["W", "Trp", "Tryptophan"],
            CTT: ["L", "Leu", "Leucine"],
            CCT: ["P", "Pro", "Proline"],
            CAT: ["H", "His", "Histidine"],
            CGT: ["R", "Arg", "Arginine"],
            CTC: ["L", "Leu", "Leucine"],
            CCC: ["P", "Pro", "Proline"],
            CAC: ["H", "His", "Histidine"],
            CGC: ["R", "Arg", "Arginine"],
            CTA: ["L", "Leu", "Leucine"],
            CCA: ["P", "Pro", "Proline"],
            CAA: ["Q", "Gln", "Glutamine"],
            CGA: ["R", "Arg", "Arginine"],
            CTG: ["L", "Leu", "Leucine"],
            CCG: ["P", "Pro", "Proline"],
            CAG: ["Q", "Gln", "Glutamine"],
            CGG: ["R", "Arg", "Arginine"],
            ATT: ["I", "Ile", "Isoleucine"],
            ACT: ["T", "Thr", "Threonine"],
            AAT: ["N", "Asn", "Asparagine"],
            AGT: ["S", "Ser", "Serine"],
            ATC: ["I", "Ile", "Isoleucine"],
            ACC: ["T", "Thr", "Threonine"],
            AAC: ["N", "Asn", "Asparagine"],
            AGC: ["S", "Ser", "Serine"],
            ATA: ["I", "Ile", "Isoleucine"],
            ACA: ["T", "Thr", "Threonine"],
            AAA: ["K", "Lys", "Lysine"],
            AGA: ["R", "Arg", "Arginine"],
            ATG: ["M", "Met", "Methionine"],
            ACG: ["T", "Thr", "Threonine"],
            AAG: ["K", "Lys", "Lysine"],
            AGG: ["R", "Arg", "Arginine"],
            GTT: ["V", "Val", "Valine"],
            GCT: ["A", "Ala", "Alanine"],
            GAT: ["D", "Asp", "Aspartic acid"],
            GGT: ["G", "Gly", "Glycine"],
            GTC: ["V", "Val", "Valine"],
            GCC: ["A", "Ala", "Alanine"],
            GAC: ["D", "Asp", "Aspartic acid"],
            GGC: ["G", "Gly", "Glycine"],
            GTA: ["V", "Val", "Valine"],
            GCA: ["A", "Ala", "Alanine"],
            GAA: ["E", "Glu", "Glutamic acid"],
            GGA: ["G", "Gly", "Glycine"],
            GTG: ["V", "Val", "Valine"],
            GCG: ["A", "Ala", "Alanine"],
            GAG: ["E", "Glu", "Glutamic acid"],
            GGG: ["G", "Gly", "Glycine"]
        }
    };
    this.setReverseComplement = function () {
        this.reverseComplement = {
            a: "t",
            c: "g",
            g: "c",
            t: "a",
            u: "a",
            A: "T",
            C: "G",
            G: "C",
            T: "A",
            "/": "/",
            "[": "[",
            "]": "]"
        }
    };
    this.initializeAttributes = function () {
        this.setLineTypes();
        this.setRGB();
        this.setCodonTable();
        this.setReverseComplement()
    };
    this.initializeAttributes()
};
CanvasXpress.prototype.initPrimitives = function () {
    this.initText();
    this.initTime();
    this.initColor();
    this.initAttributes()
};
CanvasXpress.prototype.initDimensions = function () {
    this.resizeCanvas = function (d, a, b) {
        if (this.ctx) {
            this.disableGradientTransparency();
            if (d || a || b) {
                if (a || b) {
                    if (a) {
                        this.width = a;
                        this.originalWidth = a
                    }
                    if (b) {
                        this.height = b;
                        this.originalHeight = b
                    }
                } else {
                    if (d) {
                        this.width = this.originalWidth;
                        this.height = this.originalHeight
                    }
                }
                this.top = this.margin;
                if (this.title) {
                    this.top += this.titleHeight + this.margin;
                    if (this.subtitle) {
                        this.top += this.subtitleHeight + this.margin
                    }
                }
                this.left = this.margin;
                this.right = this.margin;
                this.bottom = this.margin;
                this.dataEvent = []
            }
            this.canvas.width = this.width;
            this.canvas.height = this.height;
            if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
                this.ctx.save();
                this.ctx.translate(0, 0);
                this.drawImage(CanvasXpress.cacheImages[this.backgroundImage], 0, 0, this.width, this.height);
                this.ctx.restore()
            } else {
                if (this.backgroundType == "solid" || this.backgroundType == "window" || this.backgroundType == "windowSolidGradient") {
                    this.rectangle(0, 0, this.width, this.height, this.background, this.background)
                } else {
                    this.setLinearGradient(0, 0, 0, this.height, this.backgroundGradient1Color, this.backgroundGradient2Color);
                    this.ctx.fillRect(0, 0, this.width, this.height)
                }
            }
            this.enableGradientTransparency()
        }
    };
    this.setWidth = function (a) {
        if (!a) {
            a = 1000
        }
        this.draw(a)
    };
    this.setHeight = function (a) {
        if (!a) {
            a = 8000
        }
        this.draw(false, a)
    };
    this.setDimensions = function (a, b) {
        if (!a) {
            a = 1000
        }
        if (!b) {
            b = 1000
        }
        this.draw(a, b)
    };
    this.initializeDimensions = function () {
        if (this.canvas.width) {
            this.originalWidth = this.canvas.width;
            this.width = this.canvas.width
        } else {
            if (this.width) {
                this.originalWidth = this.width;
                this.canvas.width = this.width
            } else {
                this.width = 600;
                this.originalWidth = this.width;
                this.canvas.width = this.width
            }
        }
        if (this.canvas.height) {
            this.originalHeight = this.canvas.height;
            this.height = this.canvas.height
        } else {
            if (this.height) {
                this.originalHeight = this.height;
                this.canvas.height = this.height
            } else {
                this.height = 600;
                this.originalHeight = this.height;
                this.canvas.height = this.height
            }
        }
        this.top = this.margin;
        if (this.title) {
            this.top += this.titleHeight + this.margin;
            if (this.subtitle) {
                this.top += this.subtitleHeight + this.margin
            }
        }
        this.left = this.margin;
        this.right = this.margin;
        this.bottom = this.margin;
        this.x = this.width - (this.leftMargin + this.left + this.rightMargin + this.right);
        this.y = this.height - (this.topMargin + this.top + this.bottomMargin + this.bottom)
    };
    this.initializeDimensions()
};
CanvasXpress.prototype.initPlotUtils = function () {
    this.drawCanvasBox = function () {
        if (this.canvasBox && this.graphType != "Network") {
            this.rectangle(0, 0, this.width - 1, this.height - 1, false, this.canvasBoxColor, "open")
        }
    };
    this.drawPlotWindow = function () {
        if (this.backgroundType.match("window")) {
            this.disableGradientTransparency();
            var a = this.marginLeft + this.offsetX;
            var b = this.marginTop + this.offsetY;
            if (this.backgroundType == "windowGradient2" || this.backgroundType == "windowSolidGradient") {
                this.ctx.save();
                if (this.backgroundWindowGradientOrientation == "horizontal") {
                    this.setLinearGradient(a + this.left, b, a + this.left + this.x, b, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
                } else {
                    this.setLinearGradient(a, b + this.top, a, b + this.top + this.y, this.backgroundWindowGradient1Color, this.backgroundWindowGradient2Color)
                }
                this.ctx.fillRect(a + this.left, b + this.top, this.x, this.y)
            } else {
                this.rectangle(a + this.left, b + this.top, this.x, this.y, this.backgroundWindow, this.backgroundWindow)
            }
            this.enableGradientTransparency()
        }
    };
    this.maskArea = function (q) {
        this.disableGradientTransparency();
        var n = function (i, e, t, l) {
            this.ctx.fillRect(i, e, t, l)
        };
        var r;
        var g = this.marginLeft + this.offsetX;
        var u = this.marginTop + this.offsetY;
        var o = this.outlineWidth + 1;
        var a = [0, 0, this.width, this.marginTop];
        var j = [0, 0, this.marginLeft, this.height];
        var s = [0, this.height - this.marginBottom, this.width, this.marginBottom];
        var d = [this.width - this.marginRight, 0, this.marginRight, this.height];
        var h = q ? [g, u, this.left, this.top - o] : [g, u, (this.left + this.x + this.right), this.top - o];
        var p = q ? [g, u + this.top + this.y, this.left - o, this.bottom] : [g, u, this.left - o, (this.top + this.y + this.bottom)];
        var b = q ? [g + this.left + this.x, u + this.top + this.y + o, this.right, this.bottom] : [g, u + this.top + this.y + o, (this.left + this.x + this.right), this.bottom];
        var m = q ? [g + this.left + this.x + o, u, this.right, this.top] : [g + this.left + this.x + o, u, this.right, (this.top + this.y + this.bottom)];
        var f = [a, j, s, d, h, p, b, m];
        if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
            this.ctx.save();
            this.ctx.translate(0, 0);
            for (var k = 0; k < f.length; k++) {
                f[k].unshift(CanvasXpress.cacheImages[this.backgroundImage])
            }
            r = this.drawImage
        } else {
            if (this.backgroundType == "solid" || this.backgroundType == "window" || this.backgroundType == "windowSolidGradient") {
                for (var k = 0; k < f.length; k++) {
                    f[k].push(this.background);
                    f[k].push(this.background)
                }
                r = this.rectangle
            } else {
                this.setLinearGradient(0, 0, 0, this.height, this.backgroundGradient1Color, this.backgroundGradient2Color);
                r = n
            }
        }
        if (this.marginTop) {
            r.apply(this, a)
        }
        if (this.marginLeft) {
            r.apply(this, j)
        }
        if (this.marginBottom) {
            r.apply(this, s)
        }
        if (this.marginRight) {
            r.apply(this, d)
        }
        r.apply(this, h);
        r.apply(this, p);
        r.apply(this, b);
        r.apply(this, m);
        if (this.backgroundType == "image" || this.backgroundType == "windowImage") {
            this.ctx.restore()
        }
        this.enableGradientTransparency()
    };
    this.maskPlotArea = function () {
        this.maskArea()
    };
    this.maskTreeArea = function () {
        this.maskArea(true)
    };
    this.setTrees = function () {
        if (this.showSmpDendrogram && this.data.t.smps) {
            this.smpDendrogram = {};
            this.smpDendrogram.data = [];
            this.smpDendrogram.nodes = [];
            this.smpDendrogram.idxs = [];
            this.smpDendrogram.heights = [];
            this.parseNewick(this.data.t.smps, "smpDendrogram")
        }
        if (this.showVarDendrogram && this.data.t.vars) {
            this.varDendrogram = {};
            this.varDendrogram.data = [];
            this.varDendrogram.nodes = [];
            this.varDendrogram.idxs = [];
            this.varDendrogram.heights = [];
            this.parseNewick(this.data.t.vars, "varDendrogram")
        }
    };
    this.setOverlayColors = function () {
        var l = 0;
        if (this.smpOverlays.length > 0 && !this.isGroupedData) {
            if (!this.smpOverlayColors) {
                this.smpOverlayColors = {}
            }
            for (var g = 0; g < this.smpOverlays.length; g++) {
                var f = this.smpOverlays[g];
                if (!this.smpOverlayColors[f]) {
                    this.smpOverlayColors[f] = {}
                }
                if (this.smpOverlayRecycleColors) {
                    l = 0
                }
                if (this.data.x.hasOwnProperty(f)) {
                    if (this.isNumeric(this.data.x[f], true)) {
                        var h = this.range(this.data.x[f], true);
                        for (var e = 0; e < this.smpIndices.length; e++) {
                            var k = this.smpIndices[e];
                            var b = this.data.x[f][k];
                            var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                            this.smpOverlayColors[f][b.toString()] = d
                        }
                    } else {
                        for (var e = 0; e < this.smpIndices.length; e++) {
                            var k = this.smpIndices[e];
                            var a = this.data.x[f][k];
                            if (!this.smpOverlayColors[f][a]) {
                                this.smpOverlayColors[f][a] = this.colors[l % this.colors.length];
                                l++
                            }
                        }
                    }
                }
            }
        }
        l = 0;
        if (this.varOverlays.length > 0 && this.graphType == "Heatmap") {
            if (!this.varOverlayColors) {
                this.varOverlayColors = {}
            }
            for (var g = 0; g < this.varOverlays.length; g++) {
                var f = this.varOverlays[g];
                if (!this.varOverlayColors[f]) {
                    this.varOverlayColors[f] = {}
                }
                if (this.varOverlayRecycleColors) {
                    l = 0
                }
                if (this.data.z.hasOwnProperty(f)) {
                    if (this.isNumeric(this.data.z[f], true)) {
                        var h = this.range(this.data.z[f], true);
                        for (var e = 0; e < this.varIndices.length; e++) {
                            var k = this.varIndices[e];
                            var b = this.data.z[f][k];
                            var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                            this.varOverlayColors[f][b.toString()] = d
                        }
                    } else {
                        for (var e = 0; e < this.varIndices.length; e++) {
                            var k = this.varIndices[e];
                            var a = this.data.z[f][k];
                            if (!this.varOverlayColors[f][a]) {
                                this.varOverlayColors[f][a] = this.colors[l % this.colors.length];
                                l++
                            }
                        }
                    }
                }
            }
        }
    };
    this.setOverlayFont = function () {
        var a = Math.min(this.overlayScaleFontFactor * this.overlayFontSize, this.maxTextSize);
        a = parseInt(Math.max(a, this.minTextSize));
        this.overlayFont = (a) + "Pt " + this.fontName
    };
    this.setValidDataColorShapeSize = function () {
        var b = ["color", "shape", "size"];
        for (var a = 0; a < b.length; a++) {
            if (this[b[a] + "By"]) {
                if (this.data.x && !this.data.x[this[b[a] + "By"]] && this.data.z && !this.data.z[this[b[a] + "By"]] && !this.isMultidimensionalHeatmap) {
                    this[b[a] + "By"] = false
                }
            }
        }
        if ((this.shapeBy || this.sizeBy) && !this.colorBy && !this.isMultidimensionalHeatmap) {
            this.colorBy = "variable"
        } else {
            if (!this.shapeBy && !this.sizeBy && this.colorBy == "variable") {
                this.colorBy = false
            }
        }
    };
    this.parseNewick = function (b, e) {
        var p = b.split(/,/);
        var v = 0;
        var f = 0;
        var g = 0;
        var m = 1;
        var l = 0;
        var u = 0;
        var a = 0;
        var k = 0;
        for (var s = 0; s < p.length; s++) {
            var q = p[s];
            var h = q.split(/:(?=[0-9\.]+)/);
            var w = h.shift();
            w = w.replace(/[\(\)]/g, "");
            if (this.useSmpVarIndexOnClustering) {
                this[e].nodes.push(e == "smpDendrogram" ? this.data.y.smps[w] : this.data.y.vars[w]);
                this[e].idxs.push(w)
            } else {
                this[e].nodes.push(w);
                this[e].idxs.push(e == "smpDendrogram" ? this.getSampleIndices(w) : this.getVariableIndices(w))
            }
            for (var r = 0; r < h.length; r++) {
                var d = h[r].replace(/[\(\)]/g, "");
                u = Math.max(u, d);
                this[e].heights.push(d)
            }
            this[e].max = u;
            var t = p[s].split("");
            f = 0;
            for (var r = 0; r < t.length; r++) {
                if (t[r] == "(") {
                    v++;
                    f++
                }
                if (t[r] == ")") {
                    v--;
                    f--
                }
            }
            k += f;
            if (g > v) {
                this[e].data.push([m, g, f, k])
            } else {
                this[e].data.push([m, v, f, k])
            }
            g = v;
            a = Math.max(a, g);
            l += f;
            m++
        }
        this[e].unit = u > 0 ? (a * this.dendrogramSpace) / u : 0;
        this[e].depth = a;
        if (l > 0) {
            alert("Dude! Malformed newick tree. There are " + l + " additional right parenthesis!")
        } else {
            if (l < 0) {
                alert("Dude! Malformed newick tree. There are " + Math.abs(l) + " additional left parenthesis!")
            }
        }
        if (e == "varDendrogram") {
            if (this.varIndicesStart < 0) {
                if (this[e].nodes.length != this.data.y.vars.length) {
                    alert("Dude! The length of the variable nodes in the dendrogram (" + this[e].nodes.length + ") is different to that one in the data (" + this.data.y.vars.length + "). This ain't gonna work!");
                    this.showVarDendrogram = false
                } else {
                    if (this[e].nodes.length != this.varIndices.length) {
                        alert("Ooops! Cannot show dendrogram with " + this[e].nodes.length + " nodes when only " + this.varIndices.length + " variables are visible.");
                        this.showVarDendrogram = false
                    } else {
                        this.varIndices = this[e].idxs
                    }
                }
            } else {
                var o = this.varIndicesStart + this.varIndices.length;
                this.varIndices = [];
                for (var s = this.varIndicesStart; s < o; s++) {
                    this.varIndices.push(this[e].idxs[s])
                }
            }
        } else {
            if (this.smpIndicesStart < 0) {
                if (this[e].nodes.length != this.data.y.smps.length) {
                    alert("Dude! The length of the sample nodes in the dendrogram (" + this[e].nodes.length + ") is different to that one in the data (" + this.data.y.smps.length + "). This ain't gonna work!");
                    this.showSmpDendrogram = false
                } else {
                    if (this[e].nodes.length != this.smpIndices.length) {
                        alert("Ooops! Cannot show dendrogram with " + this[e].nodes.length + " nodes when only " + this.smpIndices.length + " samples visible.");
                        this.showSmpDendrogram = false
                    } else {
                        this.smpIndices = this[e].idxs
                    }
                }
            } else {
                var o = this.smpIndicesStart + this.smpIndices.length;
                this.smpIndices = [];
                for (var s = this.smpIndicesStart; s < o; s++) {
                    this.smpIndices.push(this[e].idxs[s])
                }
            }
        }
    }
};
CanvasXpress.prototype.initGeneralUtils = function () {
    this.modifyObjectArray = function (g, b, h) {
        var a = this[h];
        if (b) {
            var e = {};
            var d = [];
            if (this.isArray(g)) {
                for (var f = 0; f < g.length; f++) {
                    e[g[f]] = 1
                }
            } else {
                e[g] = 1
            }
            for (var f = 0; f < a.length; f++) {
                if (!e.hasOwnProperty(a[f])) {
                    d.push(a[f])
                }
            }
            this[h] = d
        } else {
            if (this.isArray(g)) {
                for (var f = 0; f < g.length; f++) {
                    a.push(g[f])
                }
            } else {
                a.push(g)
            }
        }
    };
    this.getObjectArray = function (a) {
        var b = {};
        if (a && this.isArray(a)) {
            for (var d = 0; d < a.length; d++) {
                b[a[d]] = 1
            }
        }
        return b
    };
    this.isInArray = function (e, b) {
        if (b && !(b.propertyIsEnumerable("length")) && typeof b === "object" && typeof b.length === "number") {
            for (var d = 0; d < b.length; d++) {
                if (b[d] == e) {
                    return true
                }
            }
        }
        return false
    };
    this.isArray = function (a) {
        if (a && !(a.propertyIsEnumerable("length")) && typeof a === "object" && typeof a.length === "number") {
            return true
        } else {
            return false
        }
    };
    this.isObject = function (a) {
        return a instanceof Object
    };
    this.toArray = function (a) {
        return this.isArray(a) ? a : [a]
    };
    this.getKeys = function (d) {
        var b = [];
        if (this.isObject(d)) {
            for (var a in d) {
                b.push(a)
            }
        }
        return b
    };
    this.getUniqueKeys = function (d) {
        var b = {};
        if (this.isArray(d)) {
            d = this.getObjectArray(d)
        }
        if (this.isObject(d)) {
            for (var a in d) {
                b[a] = true
            }
        }
        return this.getKeys(b)
    };
    this.toNumber = function (b, g) {
        var h = [];
        var d = this.isArray(b);
        b = this.toArray(b);
        for (var e = 0; e < b.length; e++) {
            if (g) {
                h.push(parseFloat(b[e]))
            } else {
                h.push(parseInt(b[e]))
            }
        }
        return d ? h : h[0]
    };
    this.cloneObject = function (d) {
        if (d == null || typeof (d) != "object") {
            return d
        }
        var a = new d.constructor();
        for (var b in d) {
            a[b] = this.cloneObject(d[b])
        }
        return a
    };
    this.isSameObject = function (e, d) {
        if (e === d) {
            return true
        }
        if (typeof (e) != "object" || typeof (d) != "object") {
            return false
        }
        for (var f in e) {
            if (e[f] === d[f]) {
                continue
            }
            if (d[f] === undefined || typeof (e[f]) != typeof (d[f])) {
                return false
            }
            if (!this.isSameObject(e[f], d[f])) {
                return false
            }
        }
        for (var f in d) {
            if (e[f] === undefined) {
                return false
            }
        }
        return true
    }
};
CanvasXpress.prototype.initConfigUtils = function () {
    this.getPixelImage = function () {
        if (navigator.onLine) {
            return this.imageDir + "canvasXpress.gif"
        } else {
            if (this.path) {
                return this.path + "canvasXpress.gif"
            } else {
                alert("Dude! I couldn't find canvasXpress.js")
            }
        }
    };
    this.drawTitle = function () {
        
    };
    this.drawCitation = function (a, e, b) {
        
    };
    this.drawSelectedBackgroundLabel = function (b, d, a, e) {
        
    };
    this.drawSelectedBackground = function (g, j, k, b, e, f, d, a, i) {
        
    };
    this.isInSelectedDataPoints = function (a, b) {
        
    };
    this.isVisibleSelectedDataPoint = function (a, b) {
        if (this.isSelectDataPoints) {
            if (this.hideDataPoint.length > 0 && this.hideDataPoint[a]) {
                if (this.broadcastType == "var") {
                    return false
                } else {
                    if (this.hideDataPoint[a].hasOwnProperty(b)) {
                        return false
                    }
                }
            }
        }
        return true
    };
    this.getVarColor = function (a) {
        
    };
    this.getNodeColor = function (d, a) {
        if (this.isArray(this.highlightNode)) {
            for (var b = 0; b < this.highlightNode.length; b++) {
                if (this.highlightNode[b] == d) {
                    return this.nodeHighlightColor
                }
            }
        } else {
            if (this.highlightNode == d) {
                return this.nodeHighlightColor
            }
        }
        return this.selectNode.hasOwnProperty(d) ? this.nodeHighlightColor : a ? a : this.nodeFontColor
    };
    this.getTechnicalIndicatorColor = function (a) {
        
    };
    this.setPieData = function (h, a) {
        
    };
    this.drawBarPlot = function (K, J, F, x, k, C, p, g, E, D, L, N) {
       
    };
    this.drawLinePlot = function (M, L, F, y, v, H, x, E, C, N, A, P) {
        
    };
    this.drawBoxPlot = function (K, F, x, g, B, n, E, D, L, C, N) {
        
    };
    this.drawCandlestickPlot = function (G, B, q, f, F, n, A, x, y, H, J) {
        
    };
    this.drawDotPlot = function (P, O, I, B, x, L, D, A, H, C, F, Q, E, N, S) {
        
    };
    this.drawHeatmap = function (u, k, D, B, q, j, A, s, z, r) {
        
    }
};
CanvasXpress.prototype.init3dUtils = function () {
    this.set3DRotation = function () {
        var a;
        var d = 0;
        var b = 0;
        if (this.graphType == "Network") {
            d = this.maxRotate != null ? this.maxRotate : 360;
            b = this.minRotate != null ? this.minRotate : 360
        } else {
            if (this.graphType == "Scatter3D" || this.is3DPlot) {
                d = this.maxRotate != null ? this.maxRotate : 90;
                b = this.minRotate != null ? this.minRotate : 0
            }
        }
        if (this.xRotate > d) {
            this.xRotate = d
        }
        if (this.xRotate < 0) {
            this.xRotate = b
        }
        if (this.yRotate > d) {
            this.yRotate = d
        }
        if (this.yRotate < 0) {
            this.yRotate = b
        }
        if (this.zRotate > d) {
            this.zRotate = d
        }
        if (this.zRotate < 0) {
            this.zRotate = b
        }
        if (this.xRotate > 0) {
            a = 180 / this.xRotate;
            this.ry = Math.PI / a
        } else {
            this.ry = 0
        }
        if (this.yRotate > 0) {
            a = 180 / this.yRotate;
            this.rx = Math.PI / a
        } else {
            this.rx = 0
        }
        if (this.zRotate > 0) {
            a = 180 / this.zRotate;
            this.rz = Math.PI / a
        } else {
            this.rz = 0
        }
    };
    this.set3DParams = function () {
        this.perspective = this.x * 1.5;
        this.lenX = this.x / 4 * this.zoom * this.x3DRatio;
        this.lenY = this.x / 4 * this.zoom * this.y3DRatio;
        this.lenZ = this.x / 4 * this.zoom * this.z3DRatio;
        if (this.padX == null || !this.padX) {
            this.padX = this.x / 2
        }
        if (this.padY == null || !this.padY) {
            this.padY = this.y / 2
        }
        if (this.padZ == null || !this.padZ) {
            this.padZ = this.y / 2
        }
    };
    this.get3DTransfrom = function (f, g, h) {
        var e, d, b;
        var a = [];
        d = g;
        b = h;
        g = d * Math.cos(this.rx) - b * Math.sin(this.rx);
        h = d * Math.sin(this.rx) + b * Math.cos(this.rx);
        e = f;
        b = h;
        f = b * Math.sin(this.ry) + e * Math.cos(this.ry);
        h = b * Math.cos(this.ry) - e * Math.sin(this.ry);
        e = f;
        d = g;
        f = e * Math.cos(this.rz) - d * Math.sin(this.rz);
        g = e * Math.sin(this.rz) + d * Math.cos(this.rz);
        f = f * (this.perspective / (h + this.perspective));
        g = g * (this.perspective / (h + this.perspective));
        h = h * (this.perspective / (h + this.perspective));
        a.push(f + this.padX);
        a.push(g + this.padY);
        a.push(h + this.padZ);
        return a
    };
    this.backfaceCulling = function (s) {
        var y = [];
        var w = [];
        var u = [];
        var r = [];
        var q = [];
        var p = [];
        for (var o = 0; o < s.length; o++) {
            var k = s[o][1][0] - s[o][0][0];
            var x = s[o][1][1] - s[o][0][1];
            var n = s[o][1][2] - s[o][0][2];
            var j = s[o][2][0] - s[o][0][0];
            var v = s[o][2][1] - s[o][0][1];
            var m = s[o][2][2] - s[o][0][2];
            var h = s[o][3][0] - s[o][0][0];
            var t = s[o][3][1] - s[o][0][1];
            var l = s[o][3][2] - s[o][0][2];
            y[o] = x * m - v * n;
            w[o] = j * n - k * m;
            u[o] = k * v - j * x;
            r[o] = t * m - v * l;
            q[o] = j * l - h * m;
            p[o] = h * v - j * t
        }
        return [y, w, u, r, q, p]
    }
};
CanvasXpress.prototype.initLegendUtils = function () {
    this.drawDecorationData = function () {
        var ab = this.marginLeft + this.offsetX + this.left;
        var R = this.marginTop + this.offsetY + this.top;
        var ai = this.data.d;
        if (this.showDecorations && ai) {
            if (ai.nlfit) {
                var af, D, ah;
                var m = this.varIndices;
                var A, a;
                for (var ae = 0; ae < ai.nlfit.length; ae++) {
                    var K = [];
                    var J = [];
                    var n = ae % this.colors.length;
                    var aa = this.transformValue(this.yAxisTransform, ai.nlfit[ae].param[0]);
                    var Y = this.transformValue(this.yAxisTransform, ai.nlfit[ae].param[1]);
                    var U = ai.nlfit[ae].param[2];
                    var S = ai.nlfit[ae].param[3];
                    var L = this.xAxisIndices.length == 1 ? this.xAxisIndices[0] : this.xAxisIndices[ae];
                    var M = this.getDataForSmpGrpAtIndex(L);
                    if (this.xAxisTransform == "percentile") {
                        af = this.range(M);
                        ah = af[0];
                        D = af[1]
                    }
                    m.sort(function (i, d) {
                        return M[i] - M[d]
                    });
                    n = ai.nlfit[ae].color ? ai.nlfit[ae].color : this.colors[n];
                    for (var ad = 0; ad < m.length; ad++) {
                        var s = m[ad];
                        var P = this.getDataAtPos(s, L);
                        var O;
                        var v = [];
                        if (P > 0) {
                            if (ad > 0) {
                                var b = m[ad - 1];
                                var N = this.getDataAtPos(b, L);
                                if (N > 0) {
                                    var e = (P - N) / this.functionIntervals;
                                    for (var ac = 0; ac < this.functionIntervals; ac++) {
                                        v.push(N);
                                        N += e
                                    }
                                }
                            } else {
                                v = [P]
                            }
                            for (var ac = 0; ac < v.length; ac++) {
                                if (ai.nlfit[ae].type == "reg") {
                                    O = aa + ((Y - aa) / (1 + U / (Math.pow(v[ac], S))))
                                } else {
                                    O = aa + ((Y - aa) / (1 + (Math.pow((v[ac] / U), S))))
                                }
                                if (this.xAxisTransform) {
                                    v[ac] = this.xAxisTransform == "percentile" ? this.percentile(ah, D, v[ac]) : this.transformValue(this.xAxisTransform, v[ac])
                                }
                                A = ab + ((v[ac] - this.xAxisMin) * this.xAxisUnit);
                                a = (R + this.y) - ((O - this.yAxisMin) * this.yAxisUnit);
                                K.push(A);
                                J.push(a)
                            }
                        }
                    }
                    if (K.length > 0) {
                        this.drawShape("path", K, J, false, false, n, n, "open");
                        if (ai.nlfit[ae].type == "reg") {
                            O = aa + ((Y - aa) / (1 + U / (Math.pow(U, S))))
                        } else {
                            O = aa + ((Y - aa) / (1 + (Math.pow((U / U), S))))
                        }
                        if (this.xAxisTransform) {
                            U = this.xAxisTransform == "percentile" ? this.percentile(ah, D, U) : this.transformValue(this.xAxisTransform, U)
                        }
                        A = ab + ((U - this.xAxisMin) * this.xAxisUnit);
                        a = (R + this.y) - ((O - this.yAxisMin) * this.yAxisUnit);
                        this.drawLine("dottedLine", ab, a, A, a, n);
                        this.drawLine("dottedLine", A, a, A, (R + this.y), n)
                    }
                }
            }
            if (ai.line) {
                for (var ae = 0; ae < ai.line.length; ae++) {
                    if (ai.line[ae].x || ai.line[ae].y) {
                        var n = ai.line[ae].color ? ai.line[ae].color : this.colors[ae % this.colors.length];
                        var al = ai.line[ae].type ? ai.line[ae].type : "line";
                        var P = ai.line[ae].x ? ai.line[ae].x : false;
                        var O = ai.line[ae].y ? ai.line[ae].y : false;
                        var A, a, w, am;
                        if (P) {
                            A = ab + (P * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                            a = R;
                            w = A;
                            am = a + this.y;
                            this.drawLine(al, A, a, w, am, n)
                        }
                        if (O) {
                            A = ab;
                            a = R + (O * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                            w = A + this.x;
                            am = a;
                            this.drawLine(al, A, a, w, am, n)
                        }
                    }
                }
            }
            if (ai.lines) {
                for (var ae = 0; ae < ai.lines.length; ae++) {
                    var A, a, w, am;
                    var aj = true;
                    var al = ai.lines[ae].type || "line";
                    var H = ai.lines[ae].color;
                    var Q = ai.lines[ae].value || 0;
                    var V = ai.lines[ae].label || false;
                    if (this.graphOrientation == "vertical") {
                        A = this.marginLeft + this.offsetX + this.left;
                        w = A + this.x;
                        a = this.marginTop + this.offsetY + this.top + this.y - ((Q - this.xAxisMin) * this.xAxisUnit);
                        am = a;
                        aj = a <= this.marginTop + this.offsetY + this.top + this.y && a >= this.marginTop + this.offsetY + this.top ? true : false
                    } else {
                        A = this.marginLeft + this.offsetX + this.left + ((Q - this.xAxisMin) * this.xAxisUnit);
                        w = A;
                        a = this.marginTop + this.offsetY + this.top;
                        am = a + this.y;
                        aj = A <= this.marginLeft + this.offsetX + this.left + this.x && this.marginLeft + this.offsetX + this.left ? true : false
                    }
                    if (aj) {
                        if (V) {
                            if (this.graphOrientation == "vertical") {
                                this.drawText(V, w - this.margin, am - this.margin, this.decorationFont, this.decorationColor, "right", "bottom")
                            } else {
                                this.drawText(V, w + this.margin, am - this.margin, this.decorationFont, this.decorationColor, "left", "bottom")
                            }
                        }
                        this.drawLine(al, A, a, w, am, H)
                    }
                }
            }
            if (ai.reg) {
                for (var ae = 0; ae < ai.reg.length; ae++) {
                    if (ai.reg[ae].slope && ai.reg[ae].intercept) {
                        var n = ae % this.colors.length;
                        var al = ai.reg[ae].type ? ai.reg[ae].type : "line";
                        var C = ai.reg[ae].slope;
                        var X = ai.reg[ae].intercept;
                        var g = ai.reg[ae].cor;
                        var A = ai.reg[ae].start ? ai.reg[ae].start : this.xAxisMin;
                        var a = (C * A) + X;
                        var w = ai.reg[ae].end ? ai.reg[ae].end : this.xAxisMax;
                        var am = (C * w) + X;
                        A = ab + (A * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        a = (R + this.y) - (a * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        w = ab + (w * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        am = (R + this.y) - (am * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        n = ai.reg[ae].color ? ai.reg[ae].color : this.colors[n];
                        this.drawLine(al, A, a, w, am, n)
                    }
                }
            }
            if (ai.nor) {
                for (var ae = 0; ae < ai.nor.length; ae++) {
                    if (ai.nor[ae].mu && ai.nor[ae].sigma) {
                        var Z = [];
                        var W = [];
                        var I = [];
                        var A, a;
                        var n = ae % this.colors.length;
                        var o = ai.nor[ae].mu;
                        var f = ai.nor[ae].sigma;
                        var F = ai.nor[ae].start ? ai.nor[ae].start : ai.nor[ae].yAxis ? this.yAxisMin : this.xAxisMin;
                        var B = ai.nor[ae].end ? ai.nor[ae].end : ai.nor[ae].yAxis ? this.yAxisMax : this.xAxisMax;
                        var h = 120;
                        if (F < o && o < B) {
                            var N, z, E, ag;
                            var e = (o - F) / h;
                            var ak = f * f;
                            var T = ak * 2;
                            var G = 1 / Math.sqrt(2 * Math.PI * ak);
                            if (ai.nor[ae].yAxis) {
                                E = ai.nor[ae].max ? ai.nor[ae].max * this.xAxisUnit : this.x - (this.x * this.axisExtension);
                                ag = E / G;
                                N = F;
                                for (var ad = 0; ad < h - 1; ad++) {
                                    z = (G * Math.pow(Math.E, - Math.pow(N - o, 2) / ak));
                                    I.push([N, z]);
                                    A = ab + (z * ag);
                                    a = (R + this.y) - (N * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                                    Z.push(A);
                                    W.push(a);
                                    N += e
                                }
                                e = (B - o) / h;
                                N = o;
                                for (var ad = 0; ad < h; ad++) {
                                    z = (G * Math.pow(Math.E, - Math.pow(N - o, 2) / ak));
                                    I.push([N, z]);
                                    A = ab + (z * ag);
                                    a = (R + this.y) - (N * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                                    Z.push(A);
                                    W.push(a);
                                    N += e
                                }
                                n = ai.nor[ae].color ? ai.nor[ae].color : this.colors[n];
                                this.drawShape("path", Z, W, false, false, n, n, "open")
                            } else {
                                E = ai.nor[ae].max ? ai.nor[ae].max * this.yAxisUnit : this.y - (this.y * this.axisExtension);
                                ag = E / G;
                                N = F;
                                for (var ad = 0; ad < h - 1; ad++) {
                                    z = (G * Math.pow(Math.E, - Math.pow(N - o, 2) / ak));
                                    I.push([N, z]);
                                    A = ab + (N * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                                    a = (R + this.y) - (z * ag);
                                    Z.push(A);
                                    W.push(a);
                                    N += e
                                }
                                e = (B - o) / h;
                                N = o;
                                for (var ad = 0; ad < h; ad++) {
                                    z = (G * Math.pow(Math.E, - Math.pow(N - o, 2) / ak));
                                    I.push([N, z]);
                                    A = ab + (N * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                                    a = (R + this.y) - (z * ag);
                                    Z.push(A);
                                    W.push(a);
                                    N += e
                                }
                                n = ai.nor[ae].color ? ai.nor[ae].color : this.colors[n];
                                this.drawShape("path", Z, W, false, false, n, n, "open")
                            }
                        }
                    }
                }
            }
            if (ai.area) {
                for (var ae = 0; ae < ai.area.length; ae++) {
                    if (ai.area[ae].type && ai.area[ae].x && ai.area[ae].y && ai.area[ae].size) {
                        if (this.isValidShape(ai.area[ae].type)) {
                            var A = ab + (ai.area[ae].x * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                            var a = (R + this.y) - (ai.area[ae].y * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                            var n = ai.area[ae].color ? ai.area[ae].color : this.colors[ae % this.colors.length];
                            this[ai.area[ae].type](A, a, n, ai.area[ae].size)
                        }
                    }
                }
            }
            if (ai.kaplanMeier) {
                var A, a, w, am, u, r, q, p, n;
                for (var ae = 0; ae < ai.kaplanMeier.length; ae++) {
                    n = ai.kaplanMeier[ae].color;
                    A = ab;
                    a = (R + this.y) - (this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    w = ab + (ai.kaplanMeier[ae].data.times[0] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                    am = (R + this.y) - (ai.kaplanMeier[ae].data.data[0][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    r = (R + this.y) - (ai.kaplanMeier[ae].data.data[0][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    p = (R + this.y) - (ai.kaplanMeier[ae].data.data[0][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                    this.drawLine("line", A, a, w, a, n);
                    this.drawLine("line", w, a, w, am, n);
                    this.drawLine("dottedLine", A, a, w, a, n, 0.5);
                    this.drawLine("dottedLine", w, a, w, r, n, 0.5);
                    this.drawLine("dottedLine", A, a, w, a, n, 0.5);
                    this.drawLine("dottedLine", w, a, w, p, n, 0.5);
                    for (var ad = 1; ad < ai.kaplanMeier[ae].data.times.length; ad++) {
                        A = ab + (ai.kaplanMeier[ae].data.times[ad - 1] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        a = (R + this.y) - (ai.kaplanMeier[ae].data.data[ad - 1][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        u = (R + this.y) - (ai.kaplanMeier[ae].data.data[ad - 1][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        q = (R + this.y) - (ai.kaplanMeier[ae].data.data[ad - 1][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        w = ab + (ai.kaplanMeier[ae].data.times[ad] * this.xAxisUnit) - (this.xAxisMin * this.xAxisUnit);
                        am = (R + this.y) - (ai.kaplanMeier[ae].data.data[ad][3] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        r = (R + this.y) - (ai.kaplanMeier[ae].data.data[ad][4] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        p = (R + this.y) - (ai.kaplanMeier[ae].data.data[ad][5] * this.yAxisUnit) + (this.yAxisMin * this.yAxisUnit);
                        this.drawLine("line", A, a, w, a, n);
                        this.drawLine("line", w, a, w, am, n);
                        this.drawLine("dottedLine", A, u, w, u, n, 0.5);
                        this.drawLine("dottedLine", w, u, w, r, n, 0.5);
                        this.drawLine("dottedLine", A, q, w, q, n, 0.5);
                        this.drawLine("dottedLine", w, q, w, p, n, 0.5)
                    }
                }
            }
        }
    };
    this.setDecorationLegendDimension = function () {
        this.legendDecorationWidth = 0;
        this.legendDecorationHeight = 0;
        var g = this.data.d;
        if (this.showDecorations && g) {
            var l = this.getFontPt(this.decorationFont);
            var k = 0;
            var h = 0;
            var k = 0;
            var b = 0;
            if (g.nlfit) {
                var a = this.measureText(sprintf("%90s", "X"), this.decorationFont) + (this.margin * 5);
                var j = 0;
                for (var f = 0; f < g.nlfit.length; f++) {
                    var e = this.measureText(g.nlfit[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                k = this.margin + j + this.margin + a + this.margin;
                this.legendDecorationHeight = (g.nlfit.length * l * 2) + l + this.margin
            }
            if (g.line) {
                var j = 0;
                for (var f = 0; f < g.line.length; f++) {
                    var e = this.measureText(g.line[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                b = this.margin + j + this.margin;
                this.legendDecorationHeight += (g.line.length * l * 2) + this.margin
            }
            if (g.reg) {
                var a = this.measureText(sprintf("%45s", "X"), this.decorationFont) + (this.margin * 2);
                var j = 0;
                for (var f = 0; f < g.reg.length; f++) {
                    var e = this.measureText(g.reg[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                h = this.margin + j + this.margin + a + this.margin;
                this.legendDecorationHeight += (g.reg.length * l * 2) + l + this.margin
            }
            if (g.nor) {
                var a = this.measureText(sprintf("%30s", "X"), this.decorationFont) + (this.margin * 1);
                var j = 0;
                for (var f = 0; f < g.nor.length; f++) {
                    var e = this.measureText(g.nor[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                k = this.margin + j + this.margin + a + this.margin;
                this.legendDecorationHeight += (g.nor.length * l * 2) + l + this.margin
            }
            if (g.area) {
                var j = 0;
                for (var f = 0; f < g.area.length; f++) {
                    var e = this.measureText(g.area[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                b = this.margin + j + this.margin;
                this.legendDecorationHeight += (g.area.length * l * 2) + this.margin
            }
            if (g.kaplanMeier) {
                var j = 0;
                for (var f = 0; f < g.kaplanMeier.length; f++) {
                    var e = this.measureText(g.kaplanMeier[f].label, this.decorationFont);
                    j = Math.max(e, j)
                }
                b = this.margin + j + this.margin;
                this.legendDecorationHeight += (g.kaplanMeier.length * l * 2) + this.margin
            }
            this.legendDecorationWidth = Math.max(Math.max(Math.max(k, h), k), b)
        }
    };
    this.drawDecorationLegend = function () {
        var f = this.marginLeft + this.offsetX + this.left;
        var q = this.marginTop + this.offsetY + this.top;
        var m = this.data.d;
        if (this.showDecorations && m) {
            var r = this.getFontPt(this.decorationFont);
            var e = this.measureText(sprintf("%15s", "X"), this.decorationFont);
            var a, p, n, o;
            if (this.decorationsPosition == "right") {
                p = q + (r / 2) + ((this.y - this.legendDecorationHeight) / 2)
            } else {
                p = (q + this.y + this.bottom) - this.legendDecorationHeight
            }
            if (m.nlfit) {
                o = (this.margin * 6) + (6 * e);
                if (this.decorationsPosition == "right") {
                    n = (f + this.x + this.right + e) - o
                } else {
                    n = f + ((this.x - this.legendDecorationWidth) / 2) + (this.legendDecorationWidth - o) + e
                }
                a = n;
                this.drawText("Min", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Max", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("EC50", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Slope", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("p-Val", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("F-Chg", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                p += r + r;
                for (var k = 0; k < m.nlfit.length; k++) {
                    var g = k % this.colors.length;
                    g = m.nlfit[k].color ? m.nlfit[k].color : this.colors[g];
                    a = (n + this.margin) - e;
                    if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                        a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                    }
                    this.drawText(m.nlfit[k].label, a, p, this.decorationFont, g, "right", "middle");
                    a = n;
                    for (var h = 0; h < 6; h++) {
                        var b = m.nlfit[k].param[h];
                        if (h < 2) {
                            b = this.transformValue(this.yAxisTransform, b)
                        } else {
                            if (h == 2) {
                                b = this.transformValue(this.xAxisTransform, b)
                            }
                        }
                        this.drawText(this.formatNumber(b), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                        a += e + this.margin
                    }
                    p += r + r
                }
            }
            if (m.line) {
                for (var k = 0; k < m.line.length; k++) {
                    if (m.line[k].label) {
                        if (this.decorationsPosition == "right") {
                            a = f + this.x + this.margin
                        } else {
                            a = f + ((this.x - this.legendDecorationWidth) / 2) + this.margin
                        }
                        for (var k = 0; k < m.line.length; k++) {
                            var g = m.line[k].color ? m.line[k].color : this.colors[k % this.colors.length];
                            if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                                a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                            }
                            this.drawText(m.line[k].label, a, p, this.decorationFont, g, "left", "middle");
                            p += r + r
                        }
                    }
                }
            }
            if (m.reg) {
                o = (this.margin * 3) + (3 * e);
                if (this.decorationsPosition == "right") {
                    n = (f + this.x + this.right) - o
                } else {
                    n = f + ((this.x - this.legendDecorationWidth) / 2) + (this.legendDecorationWidth - o) + e
                }
                a = n;
                this.drawText("Slope", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Int", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Cor", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                p += r + r;
                for (var k = 0; k < m.reg.length; k++) {
                    var g = k % this.colors.length;
                    g = m.reg[k].color ? m.reg[k].color : this.colors[g];
                    a = (n + this.margin) - e;
                    if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                        a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                    }
                    this.drawText(m.reg[k].label, a, p, this.decorationFont, g, "right", "middle");
                    a = n;
                    this.drawText(this.formatNumber(m.reg[k].slope), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    this.drawText(this.formatNumber(m.reg[k].intercept), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    this.drawText(this.formatNumber(m.reg[k].cor), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    p += r + r
                }
            }
            if (m.nor) {
                o = (this.margin * 2) + (2 * e);
                if (this.decorationsPosition == "right") {
                    n = (f + this.x + this.right) - o
                } else {
                    n = f + ((this.x - this.legendDecorationWidth) / 2) + (this.legendDecorationWidth - o) + e
                }
                a = n;
                this.drawText("Mu", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                a += e + this.margin;
                this.drawText("Sigma", a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                p += r + r;
                for (var k = 0; k < m.nor.length; k++) {
                    var g = k % this.colors.length;
                    g = m.nor[k].color ? m.nor[k].color : this.colors[g];
                    a = (n + this.margin) - e;
                    if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                        a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                    }
                    this.drawText(m.nor[k].label, a, p, this.decorationFont, g, "right", "middle");
                    a = n;
                    this.drawText(this.formatNumber(m.nor[k].mu), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    this.drawText(this.formatNumber(m.nor[k].sigma), a, p, this.decorationFont, this.decorationsColor, "right", "middle");
                    a += e + this.margin;
                    p += r + r
                }
            }
            if (m.area) {
                for (var k = 0; k < m.area.length; k++) {
                    if (m.area[k].label) {
                        if (this.decorationsPosition == "right") {
                            a = f + this.x + this.margin
                        } else {
                            a = f + ((this.x - this.legendDecorationWidth) / 2) + this.margin
                        }
                        var g = m.area[k].color ? m.area[k].color : this.colors[k % this.colors.length];
                        if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                            a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                        }
                        this.drawText(m.area[k].label, a, p, this.decorationFont, g, "left", "middle");
                        p += r + r
                    }
                }
            }
            if (m.kaplanMeier) {
                for (var k = 0; k < m.kaplanMeier.length; k++) {
                    if (m.kaplanMeier[k].label) {
                        if (this.decorationsPosition == "right") {
                            a = f + this.x + this.margin
                        } else {
                            a = f + ((this.x - this.legendDecorationWidth) / 2) + this.margin
                        }
                        var g = m.kaplanMeier[k].color ? m.kaplanMeier[k].color : this.colors[k % this.colors.length];
                        if (this.graphType == "ScatterBubble2D" && this.decorationsPosition == "right" && this.zAxisShow) {
                            a += this.margin + this.getFontPt(this.axisTitleFont) + this.margin
                        }
                        this.drawText(m.kaplanMeier[k].label, a, p, this.decorationFont, g, "left", "middle");
                        p += r + r
                    }
                }
            }
        }
    };
    this.setLegendFont = function () {
        if (this.autoScaleFont) {
            if (this.layoutComb) {
                this.legendFont = (parseInt(Math.max(this.minTextSize, this.legendFontSize - Math.min(this.layoutRows, this.layoutCols)) * this.legendScaleFontFactor))
            } else {
                this.legendFont = (parseInt(this.legendFontSize * this.legendScaleFontFactor))
            }
            this.legendFont = this.legendFont + "Pt " + this.fontName
        } else {
            this.legendFont = parseInt(this.legendFontSize) + "Pt " + this.fontName
        }
    };
    this.setSampleLegendDimension = function () {
        this.legendSampleWidth = 0;
        this.legendSampleHeight = 0;
        if (this.xAxisIndices.length != this.yAxisIndices.length || this.xAxisIndices.length > 1) {
            var e = this.getFontPt(this.legendFont);
            var b = 0;
            if (this.xAxisIndices.length == this.yAxisIndices.length && this.xAxisIndices.length > 1) {
                for (var d = 0; d < this.xAxisIndices.length; d++) {
                    var a = this.measureText(this.shortenText(this.xAxis[d], this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[d], this.maxSmpStringLen), this.legendFont);
                    b = Math.max(a, b)
                }
            } else {
                if (this.xAxisIndices.length > this.yAxisIndices.length) {
                    b = this.measureText(this.shortenText(this.getMaxText(this.xAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.yAxis[0], this.maxSmpStringLen), this.legendFont)
                } else {
                    if (this.yAxisIndices.length > this.xAxisIndices.length) {
                        b = this.measureText(this.shortenText(this.getMaxText(this.yAxis), this.maxSmpStringLen) + " vs " + this.shortenText(this.xAxis[0], this.maxSmpStringLen), this.legendFont)
                    }
                }
            }
            this.legendSampleWidth = (e - 1) + b + (this.margin * 3);
            this.legendSampleHeight = (Math.max(this.xAxisIndices.length, this.yAxisIndices.length) * (e + this.margin)) + this.margin
        }
    };
    this.drawSampleLegend = function (b, k) {
        var j = b;
        var e = k;
        var p = this.getFontPt(this.legendFont);
        var o = (p - 1) / 2;
        k += this.margin + o;
        if (this.legendBox) {
            this.disableGradientTransparency();
            this.rectangle(j, e, this.legendSampleWidth, this.legendSampleHeight, this.legendBackgroundColor, this.legendBoxColor);
            this.enableGradientTransparency()
        }
        var m = Math.max(this.xAxisIndices.length, this.yAxisIndices.length);
        for (var g = 0; g < m; g++) {
            var d = g % this.colors.length;
            var n = 0;
            var h = this.xAxisIndices.length == this.yAxisIndices.length ? this.yAxis[g] : this.xAxisIndices.length > this.yAxisIndices.length ? this.yAxis[0] : this.xAxis[0];
            var l = this.shortenText(this.xAxisIndices.length < this.yAxisIndices.length ? this.yAxis[g] : this.xAxis[g], this.maxSmpStringLen) + " vs " + this.shortenText(h, this.maxSmpStringLen);
            var f = b + o + this.margin;
            var a = k + o + this.margin;
            if (this.colorBy) {
                this.drawShape(this.shapes[n], f, k, p - 1, p - 1, this.background, this.colors[d], "open")
            } else {
                this.drawShape(this.shapes[n], f, k, p - 1, p - 1, this.colors[d], this.foreground, "closed")
            }
            this.drawText(l, f + o + this.margin, k, this.legendFont, this.legendColor, "left", "middle");
            k += p + this.margin
        }
        if (this.legendBox) {
            this.rectangle(j, e, this.legendSampleWidth, this.legendSampleHeight, false, this.legendBoxColor, "open")
        }
        this.addArea(["rect", j, e, j + this.legendSampleWidth, e + this.legendSampleHeight], [-1], "-legend-sample")
    };
    this.setVariableLegendDimension = function () {
        this.legendVariableWidth = 0;
        this.legendVariableHeight = 0;
        if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable")) {
            var a = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], this.getFontPt(this.legendFont)) : this.getFontPt(this.legendFont);
            var b = this.shortenText(this.maxVarNameStr, this.maxVarStringLen);
            this.legendVariableWidth = (a - 1) + this.measureText(b, this.legendFont) + (this.margin * 3);
            this.legendVariableHeight = (this.varIndices.length * (a + this.margin)) + this.margin
        }
    };
    this.drawVariableLegend = function (d, m) {
        if ((this.colorBy && this.colorBy == "variable") || (this.shapeBy && this.shapeBy == "variable") || (this.sizeBy && this.sizeBy == "variable")) {
            var k = d;
            var f = m;
            var q = this.getFontPt(this.legendFont);
            var l = this.sizeBy && this.sizeBy == "variable" ? Math.max(this.sizes[this.varIndices.length - 1], q) : q;
            m += this.margin + (l / 2);
            if (this.legendBox && this.legendBackgroundColor) {
                this.disableGradientTransparency();
                this.rectangle(k, f, this.legendVariableWidth, this.legendVariableHeight, this.legendBackgroundColor, this.legendBoxColor);
                this.enableGradientTransparency()
            }
            for (var h = 0; h < this.varIndices.length; h++) {
                var n = this.varIndices[h];
                var e = (this.colorBy && this.colorBy == "variable") ? h % this.colors.length : 0;
                var p = this.shapeBy && this.shapeBy == "variable" ? h % this.shapes.length : 0;
                var b = this.sizeBy && this.sizeBy == "variable" ? this.sizes[h % this.sizes.length] : l;
                var o = l / 2;
                var g = d + o + this.margin;
                var a = m + o + this.margin;
                var j = this.shortenText(this.data.y.vars[n], this.maxVarStringLen);
                if (this.colorBy && this.colorBy != "variable") {
                    this.drawShape(this.shapes[p], g, m, b, b, this.background, this.foreground, "open")
                } else {
                    this.drawShape(this.shapes[p], g, m, b, b, this.colors[e], this.foreground, "closed")
                }
                this.drawText(j, g + o + this.margin, m, this.legendFont, this.legendColor, "left", "middle");
                m += l + this.margin
            }
            if (this.legendBox) {
                this.rectangle(k, f, this.legendVariableWidth, this.legendVariableHeight, false, this.legendBoxColor, "open")
            }
            this.addArea(["rect", k, f, k + this.legendVariableWidth, f + this.legendVariableHeight], [-1], "-legend-variable")
        }
    };
    this.setColorLegendIndicatorDimensions = function () {
        if (this.colorBy || this.outlineBy) {
            var a = this.heatmapType.split("-");
            if (this.heatmapType.split("-").length > 1) {
                this.legendColorIndicatorWidth = parseInt(2 * 256 * this.indicatorWidth / this.indicatorBins) + (this.margin * 4) + 1
            } else {
                this.legendColorIndicatorWidth = parseInt(1 * 256 * this.indicatorWidth / this.indicatorBins) + (this.margin * 4) + 1
            }
            this.legendColorIndicatorHeight = this.indicatorHeight + (this.margin * 3) + this.getFontPt(this.legendFont);
            this.legendColorIndicatorHeight += this.getFontPt(this.legendFont) + this.margin
        }
    };
    this.getHeatmapColor = function (e, d, f) {
        var b = Math.abs(e);
        e += b;
        d += b;
        f += b;
        var a = ((f - e) * this.heatmapColors.length / (d - e)).toFixed() - 1;
        return this.heatmapColors[Math.max(0, Math.min(this.heatmapColors.length - 1, a))]
    };
    this.drawColorIndicator = function (d, n, f, l, h, b) {
        if (this.colorBy || this.outlineBy || b) {
            var k = d;
            var e = n;
            var a = this.indicatorHeight;
            var m = this.indicatorHeight;
            if (this.indicatorsPosition == "bottom") {
                for (var g = 0; g < this.heatmapColors.length; g++) {
                    var j = this.transparency != null ? this.addColorTransparency(this.heatmapColors[g], this.transparency) : this.heatmapColors[g];
                    this.drawLine("line", d, n, d, n + m, j, this.indicatorWidth + 0.5);
                    d += this.indicatorWidth
                }
                d = k - (this.indicatorWidth / 2);
                n += m + this.margin;
                this.drawText(sprintf("%." + h + "f", f), d, n, this.legendFont, this.legendColor, "center", "top");
                d += (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                if (this.heatmapColors.length >= 10) {
                    this.drawText(sprintf("%." + h + "f", (f + l) / 2), d, n, this.legendFont, this.legendColor, "center", "top")
                }
                if (!b) {
                    this.drawText(this.colorBy || this.outlineBy, d, n + this.margin + this.getFontPt(this.legendFont), this.legendFont, this.legendColor, "center", "top")
                }
                d += (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                this.drawText(sprintf("%." + h + "f", l), d, n, this.legendFont, this.legendColor, "center", "top");
                this.addArea(["rect", k - (this.margin * 2), e - this.margin, d + (this.margin * 2), n + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-color")
            } else {
                for (var g = 0; g < this.heatmapColors.length; g++) {
                    var j = this.transparency != null ? this.addColorTransparency(this.heatmapColors[g], this.transparency) : this.heatmapColors[g];
                    this.drawLine("line", d, n, d + a, n, j, this.indicatorWidth + 0.5);
                    n -= this.indicatorWidth
                }
                d += a + this.margin;
                n = e - (this.indicatorWidth / 2);
                this.drawText(sprintf("%." + h + "f", f), d, n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                n -= (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                if (this.heatmapColors.length >= 10) {
                    this.drawText(sprintf("%." + h + "f", (f + l) / 2), d, n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2)
                }
                if (!b) {
                    this.drawText(this.colorBy || this.outlineBy, d + this.margin + this.getFontPt(this.legendFont), n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2)
                }
                n -= (this.heatmapColors.length * this.indicatorWidth / 2) - (this.indicatorWidth / 2);
                this.drawText(sprintf("%." + h + "f", l), d, n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                this.addArea(["rect", k - this.margin, n - (this.margin * 2), d + this.margin + this.getFontPt(this.legendFont), e + (this.margin * 2)], [-1], "-legend-indicator-color")
            }
        }
    };
    this.setShapeLegendIndicatorDimensions = function () {
        if (this.shapeBy) {
            this.legendShapeIndicatorWidth = (10 * (this.indicatorHeight + this.margin)) + (this.margin * 2);
            this.legendShapeIndicatorHeight = this.indicatorHeight + (this.margin * 3) + this.getFontPt(this.legendFont);
            this.legendShapeIndicatorHeight += this.getFontPt(this.legendFont) + this.margin
        }
    };
    this.drawShapeIndicator = function (b, n, f, m, j) {
        if (this.shapeBy) {
            var l = b;
            var d = n;
            var k = this.indicatorHeight / 2;
            var e = b;
            var a = n;
            if (this.indicatorsPosition == "bottom") {
                for (var g = 0; g < 10; g++) {
                    this.drawShape("pie" + g, e, a + this.margin, this.indicatorHeight, this.indicatorHeight, this.background, this.foreground, "open");
                    e += this.indicatorHeight + k
                }
                b = l;
                n += this.indicatorHeight + this.margin;
                this.drawText(sprintf("%." + j + "f", f), b, n, this.legendFont, this.legendColor, "center", "top");
                b += this.indicatorHeight * 7;
                this.drawText(sprintf("%." + j + "f", (f + m) / 2), b, n, this.legendFont, this.legendColor, "center", "top");
                this.drawText(this.shapeBy || shapeBy, b, n + this.margin + this.getFontPt(this.legendFont), this.legendFont, this.legendColor, "center", "top");
                b += this.indicatorHeight * 7;
                this.drawText(sprintf("%." + j + "f", m), b, n, this.legendFont, this.legendColor, "center", "top");
                this.addArea(["rect", l - (this.margin * 2), d - this.margin, b + (this.margin * 2), n + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-shape")
            } else {
                for (var g = 0; g < 10; g++) {
                    this.drawShape("pie" + g, e + this.margin, a, this.indicatorHeight, this.indicatorHeight, this.background, this.foreground, "open");
                    a -= this.indicatorHeight + k
                }
                b += this.indicatorHeight + this.margin;
                n = d;
                this.drawText(sprintf("%." + j + "f", f), b, n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                n -= this.indicatorHeight * 7;
                if (this.heatmapColors.length >= 10) {
                    this.drawText(sprintf("%." + j + "f", (f + m) / 2), b, n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2)
                }
                this.drawText(this.shapeBy || shapeBy, b + this.margin + this.getFontPt(this.legendFont), n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                n -= this.indicatorHeight * 7;
                this.drawText(sprintf("%." + j + "f", m), b, n, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                this.addArea(["rect", l - this.margin, n - (this.margin * 2), b + this.margin + this.getFontPt(this.legendFont), d + (this.margin * 2)], [-1], "-legend-indicator-shape")
            }
        }
    };
    this.setSizeLegendIndicatorDimensions = function () {
        if (this.sizeBy) {
            var a = 0;
            var d = this.indicatorHeight / 2;
            for (var b = 0; b < 10; b++) {
                a += this.sizes[b] + d
            }
            this.legendSizeIndicatorWidth = (a - (this.sizes[0] + this.sizes[9])) + (this.margin * 4);
            this.legendSizeIndicatorHeight = this.sizes[9] + (this.margin * 3) + this.getFontPt(this.legendFont);
            this.legendSizeIndicatorHeight += this.getFontPt(this.legendFont) + this.margin
        }
    };
    this.drawSizeIndicator = function (e, q, j, p, l) {
        if (this.sizeBy) {
            var o = e;
            var f = q;
            var m = this.indicatorHeight / 2;
            var r = this.sizes[9];
            var g = e;
            var a = q;
            var n = e;
            var d = q;
            if (this.indicatorsPosition == "bottom") {
                for (var k = 0; k < 10; k++) {
                    var b = this.sizes[k];
                    this.drawShape("sphere", g, a + (r / 2), b, b, this.background, this.foreground, "open");
                    g += b + m;
                    if (k < 4) {
                        n += b + m
                    } else {
                        if (k == 5) {
                            n += (b + m) / 2
                        }
                    }
                }
                q += r + this.margin;
                this.drawText(sprintf("%." + l + "f", j), o, q, this.legendFont, this.legendColor, "center", "top");
                this.drawText(sprintf("%." + l + "f", (j + p) / 2), n, q, this.legendFont, this.legendColor, "center", "top");
                this.drawText(this.sizeBy, o + (this.legendSizeIndicatorWidth / 2), q + this.margin + this.getFontPt(this.legendFont), this.legendFont, this.legendColor, "center", "top");
                this.drawText(sprintf("%." + l + "f", p), g - (r + m), q, this.legendFont, this.legendColor, "center", "top");
                this.addArea(["rect", o - (this.margin * 2), f - this.margin, (g - r) + (this.margin * 2), q + this.getFontPt(this.legendFont) + this.margin], [-1], "-legend-indicator-size")
            } else {
				
                for (var k = 0; k < 10; k++) {
                    var b = this.sizes[k];
                    this.drawShape("sphere", g + (r / 2), a, b, b, this.background, this.foreground, "open");
                    a -= (b + m);
                    if (k < 4) {
                        d -= (b + m)
                    } else {
                        if (k == 5) {
                            d -= ((b + m) / 2)
                        }
                    }
                }
                e += r + this.margin;
                this.drawText(sprintf("%." + l + "f", j), e, q, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                this.drawText(sprintf("%." + l + "f", (j + p) / 2), e, d, this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                this.drawText(this.sizeBy, e + this.margin + this.getFontPt(this.legendFont), f - (this.legendSizeIndicatorWidth / 2), this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                this.drawText(sprintf("%." + l + "f", p), e, a + (r + m), this.legendFont, this.legendColor, "center", "top", - Math.PI / 2);
                this.addArea(["rect", o - this.margin, (a + (r + m)) - (this.margin * 2), e + this.margin + this.getFontPt(this.legendFont), f + (this.margin * 2)], [-1], "-legend-indicator-size")
            }
        }
    };
    this.setDataColorShapeSizeIndicatorDimensions = function () {
        this.setColorLegendIndicatorDimensions();
        this.setShapeLegendIndicatorDimensions();
        this.setSizeLegendIndicatorDimensions()
    };
    this.getDiameterLegend = function () {
        return this.x >= 600 ? 10 : this.x >= 400 ? 8 : this.x >= 200 ? 6 : 4
    };
    this.setColorLegendDimensions = function (a) {
        this.legendColorWidth = 0;
        this.legendColorHeight = 0;
        if (this.colorBy || this.outlineBy) {
            var g, f;
            var j = this.getDiameterLegend();
            if (a) {
                g = this.colorBy || this.outlineBy;
                f = a
            } else {
                if (this.data.x && this.data.x.hasOwnProperty(this.colorBy)) {
                    g = this.setMaxSmpStringAnnt(this.colorBy);
                    f = this.legendColorsMax
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.colorBy)) {
                        g = this.setMaxVarStringAnnt(this.colorBy);
                        f = this.setMaxVarStringLabel(this.colorBy)
                    } else {
                        g = 0;
                        f = 0
                    }
                }
            }
            var b = this.measureText(g, this.legendFont);
            var e = this.measureText(f, this.legendFont) + j + this.margin;
            this.legendColorWidth = Math.max(b, e) + (this.margin * 2);
            var i = this.getFontPt(this.legendFont);
            var h = Math.max(j, i);
            this.legendColorHeight = (this.legendColorsN * (h + this.margin)) + i + (this.margin * 3)
        }
    };
    this.drawColorLegend = function (e, f) {
        if ((this.outlineBy && this.isMultidimensionalHeatmap) || (this.colorBy && ((this.data.x && this.data.x.hasOwnProperty(this.colorBy)) || (this.data.z && this.data.z.hasOwnProperty(this.colorBy))))) {
            var i = this.getDiameterLegend();
            var g = this.getFontPt(this.legendFont);
            var j = g / 2;
            var h = f + this.margin + j;
            var a = Math.max(i, g);
            this.disableGradientTransparency();
            if (this.legendBackgroundColor) {
                this.rectangle(e, f, this.legendColorWidth, this.legendColorHeight, this.legendBackgroundColor, this.legendBoxColor)
            } else {
                this.rectangle(e, f, this.legendColorWidth, this.legendColorHeight, false, this.legendBoxColor, "open")
            }
            this.enableGradientTransparency();
            this.drawText(this.colorBy || this.outlineBy, e + (this.legendColorWidth / 2), h, this.legendFont, this.colorLegend, "center", "middle");
            h += j + this.margin;
            this.drawLine("line", e, h, e + this.legendColorWidth, h, this.legendBoxColor);
            h += this.margin + (a / 2);
            for (var b in this.legendColors) {
                if (this.outlineBy) {
                    this.drawShape("circle", e + this.margin + (i / 2), h, i, i, false, this.legendColors[b], "open", false, 2)
                } else {
                    this.drawShape("circle", e + this.margin + (i / 2), h, i, i, this.legendColors[b], this.foreground, "closed")
                }
                this.drawText(b, e + (this.margin * 2) + i, h, this.legendFont, this.colorLegend, "left", "middle");
                h += this.margin + a
            }
            this.addArea(["rect", e, f, e + this.legendColorWidth, f + this.legendColorHeight], [-1], "-legend-color")
        }
    };
    this.setShapeLegendDimensions = function (a) {
        this.legendShapeWidth = 0;
        this.legendShapeHeight = 0;
        if (this.shapeBy) {
            var g, f;
            var j = this.getDiameterLegend();
            if (a) {
                g = this.shapeBy;
                f = a
            } else {
                if (this.data.x && this.data.x.hasOwnProperty(this.shapeBy)) {
                    g = this.setMaxSmpStringAnnt(this.shapeBy);
                    f = this.legendShapesMax
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.shapeBy)) {
                        g = this.setMaxVarStringAnnt(this.shapeBy);
                        f = this.setMaxVarStringLabel(this.shapeBy)
                    } else {
                        g = 0;
                        f = 0
                    }
                }
            }
            var b = this.measureText(g, this.legendFont);
            var e = this.measureText(f, this.legendFont) + j + this.margin;
            this.legendShapeWidth = Math.max(b, e) + (this.margin * 2);
            var i = this.getFontPt(this.legendFont);
            var h = Math.max(j, i);
            this.legendShapeHeight = (this.legendShapesN * (h + this.margin)) + i + (this.margin * 3)
        }
    };
    this.drawShapeLegend = function (b, e) {
        if ((this.shapeBy && this.isMultidimensionalHeatmap) || (this.shapeBy && ((this.data.x && this.data.x.hasOwnProperty(this.shapeBy)) || (this.data.z && this.data.z.hasOwnProperty(this.shapeBy))))) {
            var i = this.getDiameterLegend();
            var f = this.getFontPt(this.legendFont);
            var j = f / 2;
            var h = e + this.margin + j;
            var a = Math.max(i, f);
            this.disableGradientTransparency();
            if (this.legendBackgroundColor) {
                this.rectangle(b, e, this.legendShapeWidth, this.legendShapeHeight, this.legendBackgroundColor, this.legendBoxColor)
            } else {
                this.rectangle(b, e, this.legendShapeWidth, this.legendShapeHeight, false, this.legendBoxColor, "open")
            }
            this.enableGradientTransparency();
            this.drawText(this.shapeBy, b + (this.legendShapeWidth / 2), h, this.legendFont, this.colorLegend, "center", "middle");
            h += j + this.margin;
            this.drawLine("line", b, h, b + this.legendShapeWidth, h, this.legendBoxColor);
            h += this.margin + (a / 2);
            for (var g in this.legendShapes) {
                this.drawShape(this.legendShapes[g], b + this.margin + (i / 2), h, i, i, this.background, this.foreground, "closed");
                this.drawText(g, b + (this.margin * 2) + i, h, this.legendFont, this.colorLegend, "left", "middle");
                h += this.margin + a
            }
            this.addArea(["rect", b, e, b + this.legendShapeWidth, e + this.legendShapeHeight], [-1], "-legend-shape")
        }
    };
    this.setSizeLegendDimensions = function (a) {
        this.legendSizeWidth = 0;
        this.legendSizeHeight = 0;
        if (this.sizeBy) {
            var g, f;
            var j = this.sizes[this.legendSizesN - 1];
            if (a) {
                g = this.sizeBy;
                f = a
            } else {
                if (this.data.x && this.data.x.hasOwnProperty(this.sizeBy)) {
                    g = this.setMaxSmpStringAnnt(this.sizeBy);
                    f = this.legendSizesMax
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.sizeBy)) {
                        g = this.setMaxVarStringAnnt(this.sizeBy);
                        f = this.setMaxVarStringLabel(this.sizeBy)
                    } else {
                        g = 0;
                        f = 0
                    }
                }
            }
            var b = this.measureText(g, this.legendFont);
            var e = this.measureText(f, this.legendFont) + j + this.margin;
            this.legendSizeWidth = Math.max(b, e) + (this.margin * 2);
            var i = this.getFontPt(this.legendFont);
            var h = Math.max(j, i);
            this.legendSizeHeight = (this.legendSizesN * (h + this.margin)) + i + (this.margin * 3)
        }
    };
    this.drawSizeLegend = function (e, f) {
        if ((this.sizeBy && this.isMultidimensionalHeatmap) || (this.sizeBy && ((this.data.x && this.data.x.hasOwnProperty(this.sizeBy)) || (this.data.z && this.data.z.hasOwnProperty(this.sizeBy))))) {
            var i = this.sizes[this.legendSizesN - 1];
            var g = this.getFontPt(this.legendFont);
            var j = g / 2;
            var h = f + this.margin + j;
            var a = Math.max(i, g);
            this.disableGradientTransparency();
            if (this.legendBackgroundColor) {
                this.rectangle(e, f, this.legendSizeWidth, this.legendSizeHeight, this.legendBackgroundColor, this.legendBoxColor)
            } else {
                this.rectangle(e, f, this.legendSizeWidth, this.legendSizeHeight, false, this.legendBoxColor, "open")
            }
            this.enableGradientTransparency();
            this.drawText(this.sizeBy, e + (this.legendSizeWidth / 2), h, this.legendFont, this.colorLegend, "center", "middle");
            h += j + this.margin;
            this.drawLine("line", e, h, e + this.legendSizeWidth, h, this.legendBoxColor);
            h += this.margin + (a / 2);
            for (var b in this.legendSizes) {
                this.drawShape("circle", e + this.margin + (i / 2), h, this.legendSizes[b], this.legendSizes[b], this.background, this.foreground, "closed");
                this.drawText(b, e + (this.margin * 2) + i, h, this.legendFont, this.colorLegend, "left", "middle");
                h += this.margin + a
            }
            this.addArea(["rect", e, f, e + this.legendSizeWidth, f + this.legendSizeHeight], [-1], "-legend-size")
        }
    };
    this.setDataColorShapeSizeDimensions = function () {
        this.setColorLegendDimensions();
        this.setShapeLegendDimensions();
        this.setSizeLegendDimensions()
    };
    this.setDataColor = function (e) {
        this.colorByType = false;
        if (e && this.isMultidimensionalHeatmap) {
            var m = 0;
            var a = {};
            this.dataColors = [];
            this.legendColors = {};
            this.legendColorsN = 0;
            if (this.isNumeric2DArray(e)) {
                var h = this.setRangeDataObject(e);
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var b = e[this.varIndices[g]][this.smpIndices[f]];
                        var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                        this.dataColors.push(d)
                    }
                }
                this.legendColorsN = -1;
                this.legendColorRange = h;
                this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                this.setColorLegendIndicatorDimensions()
            } else {
                var l = 0;
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var d = e[this.varIndices[g]][this.smpIndices[f]];
                        if (!a.hasOwnProperty(d)) {
                            var k = this.measureText(d, this.legendFont);
                            if (k > l) {
                                l = k;
                                this.legendColorsMax = d
                            }
                            a[d] = m % this.colors.length;
                            this.legendColors[d] = this.colors[a[d]];
                            m++
                        }
                        this.dataColors.push(this.colors[a[d]])
                    }
                }
                this.legendColorsN = m;
                this.setColorLegendDimensions(this.legendColorsMax)
            }
        } else {
            if (this.colorBy) {
                var m = 0;
                var a = {};
                this.dataColors = [];
                this.legendColors = {};
                this.legendColorsN = 0;
                if (this.data.x && this.data.x.hasOwnProperty(this.colorBy)) {
                    this.colorByType = "x";
                    var o = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isNumeric(this.data.x[this.colorBy], true)) {
                        var h = this.range(this.data.x[this.colorBy], true);
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData))) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var b = this.data.x[this.colorBy][this.data.w.grps[n][f]];
                                    var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                                    this.dataColors.push(d)
                                }
                            } else {
                                var b = this.isGroupedData ? this.mean(this.getSmpAnnotations(this.colorBy, this.data.w.grps[g], false, true)) : this.data.x[this.colorBy][n];
                                var d = !isNaN(b) ? this.getHeatmapColor(h[0], h[1], b) : this.missingDataColor;
                                this.dataColors.push(d)
                            }
                        }
                        this.legendColorsN = -1;
                        this.legendColorRange = h;
                        this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                        this.setColorLegendIndicatorDimensions()
                    } else {
                        var l = 0;
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData && (this.graphType == "Dotplot" || (this.graphType == "Boxplot" && this.showBoxplotOriginalData))) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var d = this.data.x[this.colorBy][this.data.w.grps[n][f]];
                                    if (!a.hasOwnProperty(d)) {
                                        var k = this.measureText(d, this.legendFont);
                                        if (k > l) {
                                            l = k;
                                            this.legendColorsMax = d
                                        }
                                        a[d] = m % this.colors.length;
                                        this.legendColors[d] = this.colors[a[d]];
                                        m++
                                    }
                                    this.dataColors.push(this.colors[a[d]])
                                }
                            } else {
                                var d = this.isGroupedData ? this.getSmpAnnotations(this.colorBy, this.data.w.grps[g], true) : this.data.x[this.colorBy][n];
                                if (!a.hasOwnProperty(d)) {
                                    var k = this.measureText(d, this.legendFont);
                                    if (k > l) {
                                        l = k;
                                        this.legendColorsMax = d
                                    }
                                    a[d] = m % this.colors.length;
                                    this.legendColors[d] = this.colors[a[d]];
                                    m++
                                }
                                this.dataColors.push(this.colors[a[d]])
                            }
                        }
                        this.legendColorsN = m;
                        this.setColorLegendDimensions()
                    }
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.colorBy)) {
                        this.colorByType = "z";
                        if (this.isNumeric(this.data.z[this.colorBy], false, true)) {
                            var h = this.range(this.data.z[this.colorBy], false, true);
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var b = this.data.z[this.colorBy][n];
                                if (!isNaN(b)) {
                                    this.dataColors.push(this.getHeatmapColor(h[0], h[1], b))
                                } else {
                                    this.dataColors.push(this.missingDataColor)
                                }
                            }
                            this.legendColorRange = h;
                            this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                            this.setColorLegendIndicatorDimensions()
                        } else {
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var d = this.data.z[this.colorBy][n];
                                if (!a.hasOwnProperty(d)) {
                                    a[d] = m % this.colors.length;
                                    this.legendColors[d] = this.colors[a[d]];
                                    m++
                                }
                                this.dataColors.push(this.colors[a[d]])
                            }
                            this.legendColorsN = m;
                            this.setColorLegendDimensions()
                        }
                    } else {
                        if (this.getSampleIndices(this.colorBy) > -1) {
                            m = this.getSampleIndices(this.colorBy);
                            var h = this.getAxisRangeBySample(m);
                            if (!this.scatterType || this.scatterType != "function") {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    var n = this.varIndices[g];
                                    var b = this.getDataAtPos(n, m);
                                    if (!isNaN(b)) {
                                        this.dataColors.push(this.getHeatmapColor(h[0], h[1], b))
                                    } else {
                                        this.dataColors.push(this.missingDataColor)
                                    }
                                }
                            }
                            this.legendColorRange = h;
                            this.legendColorDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], this.heatmapColors.length));
                            this.setColorLegendIndicatorDimensions()
                        } else {
                            if (this.colorBy == "variable") {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    var d = g % this.colors.length;
                                    this.dataColors.push(this.colors[d])
                                }
                                this.setVariableLegendDimension()
                            } else {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    this.dataColors.push(this.colors[0])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setDataShape = function (d) {
        this.shapeByType = false;
        if (d && this.isMultidimensionalHeatmap) {
            var m = 0;
            var a = {};
            var q = "square";
            this.dataShapes = [];
            this.legendShapes = {};
            this.legendShapesN = 0;
            if (this.isNumeric2DArray(d)) {
                var h = this.setRangeDataObject(d);
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var b = d[this.varIndices[g]][this.smpIndices[f]];
                        if (!isNaN(b)) {
                            var e = this.percentile(h[0], h[1], b);
                            var p = parseInt(e / 10);
                            if (p > 0) {
                                p--
                            }
                            this.dataShapes.push("pie" + p)
                        } else {
                            this.dataShapes.push(q)
                        }
                    }
                }
                this.legendShapeRange = h;
                this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                this.setShapeLegendIndicatorDimensions()
            } else {
                var l = 0;
                for (var g = 0; g < this.varIndices.length; g++) {
                    for (var f = 0; f < this.smpIndices.length; f++) {
                        var p = d[this.varIndices[g]][this.smpIndices[f]];
                        if (!a.hasOwnProperty(p)) {
                            var k = this.measureText(p, this.legendFont);
                            if (k > l) {
                                l = k;
                                this.legendShapesMax = p
                            }
                            a[p] = m % this.shapes.length;
                            this.legendShapes[p] = this.shapes[a[p]];
                            m++
                        }
                        this.dataShapes.push(this.shapes[a[p]])
                    }
                }
                this.legendShapesN = m;
                this.setShapeLegendDimensions(this.legendShapesMax)
            }
        } else {
            if (this.shapeBy) {
                var m = 0;
                var a = {};
                var q = "square";
                this.dataShapes = [];
                this.legendShapes = {};
                this.legendShapesN = 0;
                if (this.data.x && this.data.x.hasOwnProperty(this.shapeBy)) {
                    this.shapeByType = "x";
                    var o = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isNumeric(this.data.x[this.shapeBy], true)) {
                        var h = this.range(this.data.x[this.shapeBy], true);
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var b = this.data.x[this.shapeBy][this.data.w.grps[n][f]];
                                    if (!isNaN(b)) {
                                        var e = this.percentile(h[0], h[1], b);
                                        var p = parseInt(e / 10);
                                        if (p > 0) {
                                            p--
                                        }
                                        this.dataShapes.push("pie" + p)
                                    } else {
                                        this.dataShapes.push(q)
                                    }
                                }
                            } else {
                                var b = this.data.x[this.shapeBy][n];
                                if (!isNaN(b)) {
                                    var e = this.percentile(h[0], h[1], b);
                                    var p = parseInt(e / 10);
                                    if (p > 0) {
                                        p--
                                    }
                                    this.dataShapes.push("pie" + p)
                                } else {
                                    this.dataShapes.push(q)
                                }
                            }
                        }
                        this.legendShapeRange = h;
                        this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                        this.setShapeLegendIndicatorDimensions()
                    } else {
                        var l = 0;
                        for (var g = 0; g < o.length; g++) {
                            var n = o[g];
                            if (this.isGroupedData) {
                                for (var f = 0; f < this.data.w.grps[n].length; f++) {
                                    var p = this.data.x[this.shapeBy][this.data.w.grps[n][f]];
                                    if (!a.hasOwnProperty(p)) {
                                        var k = this.measureText(p, this.legendFont);
                                        if (k > l) {
                                            l = k;
                                            this.legendShapesMax = p
                                        }
                                        a[p] = m % this.shapes.length;
                                        this.legendShapes[p] = this.shapes[a[p]];
                                        m++
                                    }
                                    this.dataShapes.push(this.shapes[a[p]])
                                }
                            } else {
                                var p = this.data.x[this.shapeBy][n];
                                if (!a.hasOwnProperty(p)) {
                                    var k = this.measureText(p, this.legendFont);
                                    if (k > l) {
                                        l = k;
                                        this.legendShapesMax = p
                                    }
                                    a[p] = m % this.shapes.length;
                                    this.legendShapes[p] = this.shapes[a[p]];
                                    m++
                                }
                                this.dataShapes.push(this.shapes[a[p]])
                            }
                        }
                        this.legendShapesN = m;
                        this.setShapeLegendDimensions()
                    }
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.shapeBy)) {
                        this.shapeByType = "z";
                        if (this.isNumeric(this.data.z[this.shapeBy], false, true)) {
                            var h = this.range(this.data.z[this.shapeBy], false, true);
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var b = this.data.z[this.shapeBy][n];
                                if (!isNaN(b)) {
                                    var e = this.percentile(h[0], h[1], b);
                                    var p = parseInt(e / 10);
                                    if (p > 0) {
                                        p--
                                    }
                                    this.dataShapes.push("pie" + p)
                                } else {
                                    this.dataShapes.push(q)
                                }
                            }
                            this.legendShapeRange = h;
                            this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                            this.setShapeLegendIndicatorDimensions()
                        } else {
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var p = this.data.z[this.shapeBy][n];
                                if (!a.hasOwnProperty(p)) {
                                    a[p] = m % this.shapes.length;
                                    this.legendShapes[p] = this.shapes[a[p]];
                                    m++
                                }
                                this.dataShapes.push(this.shapes[a[p]])
                            }
                            this.legendShapesN = m;
                            this.setShapeLegendDimensions()
                        }
                    } else {
                        if (this.getSampleIndices(this.shapeBy) > -1) {
                            m = this.getSampleIndices(this.shapeBy);
                            var h = this.getAxisRangeBySample(m);
                            for (var g = 0; g < this.varIndices.length; g++) {
                                var n = this.varIndices[g];
                                var b = this.getDataAtPos(n, m);
                                if (!isNaN(b)) {
                                    var e = this.percentile(h[0], h[1], b);
                                    var p = parseInt(e / 10);
                                    if (p > 0) {
                                        p--
                                    }
                                    this.dataShapes.push("pie" + p)
                                } else {
                                    this.dataShapes.push(q)
                                }
                            }
                            this.legendShapeRange = h;
                            this.legendShapeDecs = this.getAxisDecimals(this.getAxisIncrements(h[0], h[1], 10));
                            this.setShapeLegendIndicatorDimensions()
                        } else {
                            if (this.shapeBy == "variable") {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    var p = g % this.shapes.length;
                                    this.dataShapes.push(this.shapes[p])
                                }
                                this.setVariableLegendDimension()
                            } else {
                                for (var g = 0; g < this.varIndices.length; g++) {
                                    this.dataShapes.push(this.shapes[0])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setDataSize = function (e) {
        this.sizeByType = false;
        if (e && this.isMultidimensionalHeatmap) {
            var n = 0;
            var b = {};
            this.dataSizes = [];
            this.legendSizes = {};
            this.legendSizesN = 0;
            if (this.isNumeric2DArray(e)) {
                var k = this.setRangeDataObject(e);
                for (var h = 0; h < this.varIndices.length; h++) {
                    for (var g = 0; g < this.smpIndices.length; g++) {
                        var d = e[this.varIndices[h]][this.smpIndices[g]];
                        if (!isNaN(d)) {
                            var f = this.percentile(k[0], k[1], d);
                            var a = parseInt(f / 10);
                            if (a > 0) {
                                a--
                            }
                            this.dataSizes.push(this.sizes[a])
                        } else {
                            this.dataSizes.push(0)
                        }
                    }
                }
                this.legendSizeRange = k;
                this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                this.setSizeLegendIndicatorDimensions()
            } else {
                var m = 0;
                for (var h = 0; h < this.varIndices.length; h++) {
                    for (var g = 0; g < this.smpIndices.length; g++) {
                        var a = e[this.varIndices[h]][this.smpIndices[g]];
                        if (!b.hasOwnProperty(a)) {
                            var l = this.measureText(a, this.legendFont);
                            if (l > m) {
                                m = l;
                                this.legendSizesMax = a
                            }
                            b[a] = (n % this.sizes.length) + 3;
                            this.legendSizes[a] = this.sizes[b[a]];
                            n++
                        }
                        this.dataSizes.push(this.sizes[b[a]])
                    }
                }
                this.legendSizesN = n;
                this.setSizeLegendDimensions(this.legendSizesMax)
            }
        } else {
            if (this.sizeBy) {
                var n = 0;
                var b = {};
                this.dataSizes = [];
                this.legendSizes = {};
                this.legendSizesN = 0;
                if (this.data.x && this.data.x.hasOwnProperty(this.sizeBy)) {
                    this.sizeByType = "x";
                    var p = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isNumeric(this.data.x[this.sizeBy], true)) {
                        var k = this.range(this.data.x[this.sizeBy], true);
                        for (var h = 0; h < p.length; h++) {
                            var o = p[h];
                            if (this.isGroupedData) {
                                for (var g = 0; g < this.data.w.grps[o].length; g++) {
                                    var d = this.data.x[this.sizeBy][this.data.w.grps[o][g]];
                                    if (!isNaN(d)) {
                                        var f = this.percentile(k[0], k[1], d);
                                        var a = parseInt(f / 10);
                                        if (a > 0) {
                                            a--
                                        }
                                        this.dataSizes.push(this.sizes[a])
                                    } else {
                                        this.dataSizes.push(0)
                                    }
                                }
                            } else {
                                var d = this.data.x[this.sizeBy][o];
                                if (!isNaN(d)) {
                                    var f = this.percentile(k[0], k[1], d);
                                    var a = parseInt(f / 10);
                                    if (a > 0) {
                                        a--
                                    }
                                    this.dataSizes.push(this.sizes[a])
                                } else {
                                    this.dataSizes.push(0)
                                }
                            }
                        }
                        this.legendSizeRange = k;
                        this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                        this.setSizeLegendIndicatorDimensions()
                    } else {
                        var m = 0;
                        for (var h = 0; h < p.length; h++) {
                            var o = p[h];
                            if (this.isGroupedData) {
                                for (var g = 0; g < this.data.w.grps[o].length; g++) {
                                    var a = this.data.x[this.sizeBy][this.data.w.grps[o][g]];
                                    if (!b.hasOwnProperty(a)) {
                                        var l = this.measureText(a, this.legendFont);
                                        if (l > m) {
                                            m = l;
                                            this.legendSizesMax = a
                                        }
                                        b[a] = (n % this.sizes.length) + 3;
                                        this.legendSizes[a] = this.sizes[b[a]];
                                        n++
                                    }
                                    this.dataSizes.push(this.sizes[b[a]])
                                }
                            } else {
                                var a = this.isGroupedData ? this.getSmpAnnotations(this.sizeBy, this.data.w.grps[h], true) : this.data.x[this.sizeBy][o];
                                if (!b.hasOwnProperty(a)) {
                                    var l = this.measureText(a, this.legendFont);
                                    if (l > m) {
                                        m = l;
                                        this.legendSizesMax = a
                                    }
                                    b[a] = (n % this.sizes.length) + 3;
                                    this.legendSizes[a] = this.sizes[b[a]];
                                    n++
                                }
                                this.dataSizes.push(this.sizes[b[a]])
                            }
                        }
                        this.legendSizesN = n;
                        this.setSizeLegendDimensions()
                    }
                } else {
                    if (this.data.z && this.data.z.hasOwnProperty(this.sizeBy)) {
                        this.sizeByType = "z";
                        if (this.isNumeric(this.data.z[this.sizeBy], false, true)) {
                            var k = this.range(this.data.z[this.sizeBy], false, true);
                            for (var h = 0; h < this.varIndices.length; h++) {
                                var o = this.varIndices[h];
                                var d = this.data.z[this.sizeBy][o];
                                if (!isNaN(d)) {
                                    var f = this.percentile(k[0], k[1], d);
                                    var a = parseInt(f / 10);
                                    if (a > 0) {
                                        a--
                                    }
                                    this.dataSizes.push(this.sizes[a])
                                } else {
                                    this.dataSizes.push(0)
                                }
                            }
                            this.legendSizeRange = k;
                            this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                            this.setSizeLegendIndicatorDimensions()
                        } else {
                            for (var h = 0; h < this.varIndices.length; h++) {
                                var o = this.varIndices[h];
                                var a = this.data.z[this.sizeBy][o];
                                if (!b.hasOwnProperty(a)) {
                                    b[a] = n % this.sizes.length;
                                    this.legendSizes[a] = this.sizes[b[a]];
                                    n++
                                }
                                this.dataSizes.push(this.sizes[b[a]])
                            }
                            this.legendSizesN = n;
                            this.setSizeLegendDimensions()
                        }
                    } else {
                        if (this.getSampleIndices(this.sizeBy) > -1) {
                            n = this.getSampleIndices(this.sizeBy);
                            var k = this.getAxisRangeBySample(n);
                            for (var h = 0; h < this.varIndices.length; h++) {
                                var o = this.varIndices[h];
                                var d = this.getDataAtPos(o, n);
                                if (!isNaN(d)) {
                                    var f = this.percentile(k[0], k[1], d);
                                    var a = parseInt(f / 10);
                                    if (a > 0) {
                                        a--
                                    }
                                    this.dataSizes.push(this.sizes[a])
                                } else {
                                    this.dataSizes.push(0)
                                }
                            }
                            this.legendSizeRange = k;
                            this.legendSizeDecs = this.getAxisDecimals(this.getAxisIncrements(k[0], k[1], 10));
                            this.setSizeLegendIndicatorDimensions()
                        } else {
                            if (this.sizeBy == "variable") {
                                for (var h = 0; h < this.varIndices.length; h++) {
                                    var a = h % this.sizes.length;
                                    this.dataSizes.push(this.sizes[a])
                                }
                                this.setVariableLegendDimension()
                            } else {
                                for (var h = 0; h < this.varIndices.length; h++) {
                                    this.dataSizes.push(this.scatterPointSize)
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setDataColorShapeSize = function () {
        this.resetLegends();
        this.setLegendFont();
        if (this.isMultidimensionalHeatmap) {
            if (this.outlineByData && this.data.y[this.outlineByData]) {
                this.setDataColor(this.data.y[this.outlineByData])
            }
            if (this.shapeByData && this.data.y[this.shapeByData]) {
                this.setDataShape(this.data.y[this.shapeByData])
            }
            if (this.sizeByData && this.data.y[this.sizeByData]) {
                this.setDataSize(this.data.y[this.sizeByData])
            }
        } else {
            this.setDataColor();
            this.setDataShape();
            this.setDataSize()
        }
        if (!this.allVsAll && (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2d")) {
            this.setSampleLegendDimension()
        }
    };
    this.resetLegends = function () {
        var a = ["Color", "Shape", "Size"];
        for (var d = 0; d < a.length; d++) {
            this["legend" + a[d] + "IndicatorWidth"] = 0;
            this["legend" + a[d] + "IndicatorHeight"] = 0;
            this["data" + a[d] + "s"] = [];
            this["legend" + a[d] + "s"] = {};
            this["legend" + a[d] + "s"] = 0
        }
        var b = this.allVsAll ? ["Color", "Shape", "Size", "Variable"] : ["Color", "Shape", "Size", "Variable", "Sample"];
        for (var d = 0; d < b.length; d++) {
            this["legend" + b[d] + "Width"] = 0;
            this["legend" + b[d] + "Height"] = 0
        }
    };
    this.setLegendDimensions = function () {
        this.legendLayout = [];
        var a = this.margin;
        var m = this.margin;
        if (this.showIndicators) {
            var g = ["Color", "Shape", "Size"];
            for (var d = 0; d < g.length; d++) {
                var k = this["legend" + g[d] + "IndicatorWidth"];
                var e = this["legend" + g[d] + "IndicatorHeight"];
                if (k) {
                    if (this.indicatorsPosition == "bottom") {
                        m += this.margin + e
                    } else {
                        a += this.margin + e
                    }
                }
            }
        }
        var b = 0;
        var l = 0;
        var j = 0;
        if (this.showLegend) {
            var f = this.allVsAll ? ["Color", "Shape", "Size", "Variable"] : ["Color", "Shape", "Size", "Variable", "Sample"];
            for (var d = 0; d < f.length; d++) {
                var k = this["legend" + f[d] + "Width"];
                var e = this["legend" + f[d] + "Height"];
                if (k > 0) {
                    if (this.legendPosition == "right") {
                        if (l + this.margin + e > this.height) {
                            a += this.margin + k;
                            b = k;
                            l = e;
                            j++;
                            this.legendLayout[j] = [f[d]]
                        } else {
                            if (k > b) {
                                a += (k - b);
                                b = k
                            }
                            l += e;
                            if (!this.legendLayout[j]) {
                                this.legendLayout[j] = []
                            }
                            this.legendLayout[j].push(f[d])
                        }
                    } else {
                        if (b + this.margin + k > this.width) {
                            m += this.margin + e;
                            b = k;
                            l = e;
                            j++;
                            this.legendLayout[d] = [f[d]]
                        } else {
                            if (e > l) {
                                m += (e - l);
                                l = e
                            }
                            b += k;
                            if (!this.legendLayout[j]) {
                                this.legendLayout[j] = []
                            }
                            this.legendLayout[j].push(f[d])
                        }
                    }
                }
            }
        }
        this.legendWidth = a + this.margin;
        this.legendHeight = m + this.margin
    };
    this.getXYLegendCoords = function (p, a, r) {
        var o, f, n, k;
        var m = 0;
        var d = 0;
        var q = -1;
        var g = -1;
        if (this.legendLayout) {
            for (var e = 0; e < this.legendLayout.length; e++) {
                o = 0;
                f = 0;
                for (var b = 0; b < this.legendLayout[e].length; b++) {
                    if (this.legendLayout[e][b] == p) {
                        g = b
                    }
                    o += this["legend" + this.legendLayout[e][b] + "Width"] + this.margin;
                    f += this["legend" + this.legendLayout[e][b] + "Height"] + this.margin;
                    m = Math.max(m, o);
                    d = Math.max(d, f)
                }
                if (g > -1) {
                    q = e;
                    break
                }
            }
            if (this.legendPosition == "right") {
                r = g == 0 && this.allVsAll ? this.marginTop + this.layoutTop : g == 0 ? this.marginTop + this.offsetY + this.top : r;
                n = a;
                k = g == 0 && this.allVsAll ? (this.height - d) / 2 : g == 0 ? this.marginTop + this.offsetY + this.top + ((this.y - d) / 2) : r;
                a = g == this.legendLayout[q].length - 1 ? a + m : a;
                r = k + this["legend" + this.legendLayout[q][g] + "Height"] + this.margin
            } else {
                a = g == 0 && this.allVsAll ? this.marginLeft + this.layoutLeft : g == 0 ? this.marginLeft + this.offsetX + this.left : a;
                n = g == 0 && this.allVsAll ? (this.width - m) / 2 : g == 0 ? this.marginLeft + this.offsetX + this.left + ((this.x - m) / 2) + this.margin : a + this.margin;
                k = r;
                a = n + this["legend" + this.legendLayout[q][g] + "Width"] + this.margin;
                r = g == this.legendLayout[q].length - 1 ? r + d : r
            }
        }
        return [n, k, a, r]
    };
    this.drawScatterLegend = function (e, s) {
        var d = this.allVsAll ? this.width - (this.marginRight + this.layoutRight) : this.marginLeft + this.offsetX + this.left + this.x;
        var o = this.allVsAll ? this.height - (this.marginBottom + this.layoutBottom) : this.marginTop + this.offsetY + this.top + this.y;
        if (e) {
            d += e
        }
        if (s) {
            o += s
        }
        if (this.showIndicators) {
            var r, k;
            var a, q;
            if (!this.allVsAll && (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D")) {
                d += (this.margin * 2);
                o += this.get2DXAxisHeight() + this.margin;
                if (this.graphType == "ScatterBubble2D" && this.zAxisShow) {
                    d += this.getFontPt(this.axisTitleFont) + (this.margin * 2)
                }
            } else {
                d += (this.margin * 1);
                o += (this.margin * 1)
            }
            var n = ["Color", "Shape", "Size"];
            for (var g = 0; g < n.length; g++) {
                r = this["legend" + n[g] + "IndicatorWidth"];
                k = this["legend" + n[g] + "IndicatorHeight"];
                if (r) {
                    var b = "draw" + n[g] + "Indicator";
                    var j = this["legend" + n[g] + "Range"];
                    var f = this["legend" + n[g] + "Decs"];
                    if (this.indicatorsPosition == "bottom") {
                        a = this.allVsAll ? (this.width - r) / 2 : this.marginLeft + this.offsetX + this.left + ((this.x - r) / 2);
                        q = o;
                        this[b](a, q, j[0], j[1], f);
                        o += k + this.margin
                    } else {
                        a = d;
                        q = this.allVsAll ? (this.height - k) / 2 : this.marginTop + this.offsetY + this.top + (this.y - ((this.y - r) / 2));
                        this[b](a, q, j[0], j[1], f);
                        d += k + this.margin
                    }
                }
            }
        }
        if (this.showLegend) {
            var m = this.allVsAll ? ["Color", "Shape", "Size", "Variable"] : ["Color", "Shape", "Size", "Variable", "Sample"];
            for (var g = 0; g < m.length; g++) {
                r = this["legend" + m[g] + "Width"];
                k = this["legend" + m[g] + "Height"];
                if (r > 0) {
                    var b = "draw" + m[g] + "Legend";
                    var p = this.getXYLegendCoords(m[g], d, o);
                    this[b](p[0], p[1]);
                    if (this.legendPosition == "right") {
                        o = p[3] + this.margin
                    } else {
                        d = p[2] + this.margin
                    }
                }
            }
        }
    }
};
CanvasXpress.prototype.initApi = function () {
    this.getValidGraphTypes = function () {
        return this.validGraphTypes
    };
    this.setHeatmapScheme = function () {
        this.initializeAttributes()
    };
    this.hasIndicator = function () {
        if (this.graphType.match(/Scatter/) || this.graphType == "Bar") {
            return true
        } else {
            return false
        }
    };
    this.hasLegend = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap") {
            return true
        } else {
            return false
        }
    };
    this.hasLegendProperties = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Correlation" && this.graphType != "Heatmap" && this.graphType != "Pie") {
            return true
        } else {
            return false
        }
    };
    this.hasData = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
            return true
        } else {
            return false
        }
    };
    this.hasDataSamples = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
            if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
                return false
            }
            return true
        } else {
            return false
        }
    };
    this.hasDataGroups = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && !this.graphType.match(/Scatter/)) {
            if (this.graphType == "Correlation" && this.correlationAxis != "samples") {
                return false
            }
            if (this.data.x) {
                return true
            } else {
                return false
            }
        } else {
            return false
        }
    };
    this.hasDataVariables = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
            if (this.graphType == "Correlation" && this.correlationAxis != "variables") {
                return false
            }
            return true
        } else {
            return false
        }
    };
    this.hasDataProperties = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Heatmap" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation") {
            return true
        } else {
            return false
        }
    };
    this.hasOrientation = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && this.graphType != "Circular" && !this.graphType.match(/Scatter/)) {
            return true
        } else {
            return false
        }
    };
    this.hasOverlays = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
            return true
        } else {
            return false
        }
    };
    this.hasDendrograms = function () {
        if (this.graphType != "Heatmap" && (this.data.t.smps || this.data.t.vars)) {
            return true
        } else {
            return false
        }
    };
    this.hasDecorations = function () {
        return this.data.d && (this.data.d.nlfit || this.data.d.line || this.data.d.reg || this.data.d.nor || this.data.d.area) ? true : false
    };
    this.isSegregable = function () {
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn" && this.graphType != "Pie" && this.graphType != "Correlation" && !this.graphType.match(/Scatter/)) {
            return true
        } else {
            return false
        }
    };
    this.getLineTypes = function () {
        var f = ["line"];
        var d = ["", "dashed", "dotted", "bezierY", "bezierX", "curved"];
        var a = ["arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"];
        for (var e = 0; e < a.length; e++) {
            f.push(a[e] + "Line")
        }
        for (var e = 1; e < d.length; e++) {
            for (var b = 0; b < a.length; b++) {
                f.push(d[e] + this.capitalize(a[b]) + "Line")
            }
        }
        return f
    };
    this.isValidShape = function (b) {
        for (var a = 0; a < this.shapes.length; a++) {
            if (this.shapes[a] == b) {
                return true
            }
        }
        return false
    };
    this.isCompatibleGraphType = function (b, a) {
        if (b.match(/^Bar$|^Line$|Boxplot|Dotplot/)) {
            return a.match(/^Bar$|^Line$|Boxplot|Dotplot/) ? true : false
        } else {
            return false
        }
    };
    this.modifyHighlights = function (d, b, e) {
        var a = e ? "highlightVar" : "highlightSmp";
        this.modifyObjectArray(d, b, a)
    };
    this.getHighlights = function (b) {
        var a = b ? this.highlightVar : this.highlightSmp;
        return this.getObjectArray(a)
    };
    this.modifySmpOverlays = function (b, a) {
        this.modifyObjectArray(b, a, "smpOverlays")
    };
    this.modifyVarOverlays = function (b, a) {
        this.modifyObjectArray(b, a, "varOverlays")
    };
    this.getSmpOverlays = function () {
        return this.getObjectArray(this.smpOverlays)
    };
    this.getVarOverlays = function () {
        return this.getObjectArray(this.varOverlays)
    };
    this.getXData = function () {
        var b = [];
        if (!this.isGroupedData) {
            if (this.data.x) {
                for (var a in this.data.x) {
                    b.push(a)
                }
            }
        }
        return b
    };
    this.getZData = function () {
        var b = [];
        if (this.data.z) {
            for (var a in this.data.z) {
                b.push(a)
            }
        }
        return b
    };
    this.getXZData = function () {
        return this.graphType.match(/Scatter/) ? this.getZData() : this.getXData()
    };
    this.getSamplesAsArray = function () {
        var e = this.getSamples();
        var b = [];
        for (var d = 0; d < e.length; d++) {
            b.push(e[d].name)
        }
        return b
    };
    this.getVariablesAsArray = function () {
        var e = this.getVariables();
        var b = [];
        for (var d = 0; d < e.length; d++) {
            b.push(e[d].name)
        }
        return b
    };
    this.getNodeData = function (a) {
        return this.getNetworkData("nodes", a)
    };
    this.getEdgeData = function (a) {
        return this.getNetworkData("edges", a)
    };
    this.getSampleData = function (a) {
        if (!this.samplesData) {
            this.samplesData = {
                smps: {
                    o: this.getObjectArray(this.data.y.smps),
                    t: "string"
                }
            };
            if (this.data.x) {
                for (att in this.data.x) {
                    this.samplesData[att] = {
                        o: this.getObjectArray(this.getUniqueKeys(this.data.x[att])),
                        t: this.isNumeric(this.data.x[att]) ? "numeric" : "string"
                    }
                }
            }
        }
        return a ? this.samplesData : this.getKeys(this.samplesData)
    };
    this.getVariableData = function (a) {
        if (!this.variablesData) {
            this.variablesData = {
                vars: {
                    o: this.getObjectArray(this.data.y.vars),
                    t: "string"
                }
            };
            if (this.data.z) {
                for (att in this.data.z) {
                    this.variablesData[att] = {
                        o: this.getObjectArray(this.getUniqueKeys(this.data.z[att])),
                        t: this.isNumeric(this.data.z[att]) ? "numeric" : "string"
                    }
                }
            }
        }
        return a ? this.variablesData : this.getKeys(this.variableData)
    };
    this.getNetworkData = function (e, a) {
        if (!this[e + "Data"]) {
            this[e + "Data"] = {};
            var g = {
                x: true,
                y: true,
                z: true,
                color: true,
                id1: true,
                id2: true,
                eventless: true,
                height: true,
                width: true,
                hideLabel: true,
                imagePath: true,
                shape: true,
                size: true,
                type: true
            };
            for (var d = 0; d < this.data[e].length; d++) {
                var f = this.data[e][d];
                for (var b in f) {
                    if (!g[b]) {
                        if (typeof (f[b]) != "object") {
                            if (this[e + "Data"].hasOwnProperty(b)) {
                                if (this[e + "Data"][b]["o"].hasOwnProperty(f[b])) {
                                    this[e + "Data"][b]["o"][f[b]]++
                                } else {
                                    this[e + "Data"][b]["o"][f[b]] = 1
                                }
                                if (isNaN(f[b])) {
                                    this[e + "Data"][b]["t"] = "string"
                                }
                            } else {
                                this[e + "Data"][b] = {
                                    o: {},
                                    t: "numeric"
                                };
                                this[e + "Data"][b]["o"][f[b]] = 1
                            }
                        }
                    }
                }
            }
        }
        return a ? this[e + "Data"] : this.getKeys(this[e + "Data"])
    };
    this.getFeatureData = function (b) {
        if (!this.featuresData) {
            this.featuresData = {};
            var k = {
                counter: true,
                coordinate: true,
                measureText: true,
                dir: true,
                end: true,
                start: true,
                fill: true,
                hideName: true,
                index: true,
                outline: true,
                offset: true,
                offsetLeft: true,
                sequenceFill: true,
                showDir: true
            };
            for (var g = 0; g < this.data.tracks.length; g++) {
                var a = this.data.tracks[g];
                var h = a.data;
                for (var e = 0; e < h.length; e++) {
                    var f = h[e];
                    for (var d in f) {
                        if (!k[d]) {
                            if (typeof (f[d]) != "object") {
                                if (this.featuresData.hasOwnProperty(d)) {
                                    if (this.featuresData[d]["o"].hasOwnProperty(f[d])) {
                                        this.featuresData[d]["o"][f[d]]++
                                    } else {
                                        this.featuresData[d]["o"][f[d]] = 1
                                    }
                                    if (isNaN(f[d])) {
                                        this.featuresData[d]["t"] = "string"
                                    }
                                } else {
                                    this.featuresData[d] = {
                                        o: {},
                                        t: "numeric"
                                    };
                                    this.featuresData[d]["o"][f[d]] = 1
                                }
                            } else {
                                if (f[d].constructor == (new Date).constructor) {}
                            }
                        }
                    }
                }
            }
        }
        return b ? this.featuresData : this.getKeys(this.featuresData)
    };
    this.getOperators = function () {
        return ["", "like", "not like", ">", ">=", "<", "<=", "==", "null", "not null"]
    };
    this.resetFilters = function (e, d) {
        var a = [];
        if (!e) {
            a = ["filterSmpBy", "filterVarBy", "filterNodeBy", "filterEdgeBy", "filterFeatureBy"]
        } else {
            a = [e]
        }
        for (var b = 0; b < a.length; b++) {
            c = a[b];
            if (c == "filterSmpBy") {
                this.resetSmpFilters(d)
            } else {
                if (c == "filterVarBy") {
                    this.resetVarFilters(d)
                } else {
                    if (c == "filterNodeBy") {
                        this.resetNodeFilters(d)
                    } else {
                        if (c == "filterEdgeBy") {
                            this.resetEdgeFilters(d)
                        } else {
                            if (c == "filterFeatureBy") {
                                this.resetFeatureFilters(d)
                            }
                        }
                    }
                }
            }
        }
    };
    this.zoonIn = function (a) {
        this.handleWheelEvent(a, 1)
    };
    this.zoonOut = function (a) {
        this.handleWheelEvent(a, - 1)
    };
    this.clusterSamples = function () {
        this.clusterAxis = "samples";
        this.showSmpDendrogram = true;
        if (!this.data.t) {
            this.data.t = {}
        }
        this.data.t.smps = this.cluster();
        this.draw()
    };
    this.clusterVariables = function () {
        this.clusterAxis = "variables";
        this.showVarDendrogram = true;
        if (!this.data.t) {
            this.data.t = {}
        }
        this.data.t.vars = this.cluster();
        this.draw()
    };
    this.kmeansSamples = function () {
        this.clusterAxis = "samples";
        this.showOverlays = true;
        if (!this.data.x) {
            this.data.x = {}
        }
        this.data.x["k-Means"] = this.kmeans();
        if (!this.isInArray("k-Means", this.smpOverlays)) {
            this.smpOverlays.push("k-Means")
        }
        this.draw()
    };
    this.kmeansVariables = function () {
        this.clusterAxis = "variables";
        this.showOverlays = true;
        if (!this.data.z) {
            this.data.z = {}
        }
        this.data.z["k-Means"] = this.kmeans();
        if (!this.isInArray("k-Means", this.varOverlays)) {
            this.varOverlays.push("k-Means")
        }
        this.draw()
    };
    this.setFunctions = function () {
        this.functions.push("clusterSamples");
        this.functions.push("clusterVariables");
        this.functions.push("transpose");
        this.functions.push("transform");
        this.functions.push("sortSamplesByCategory");
        this.functions.push("sortSamplesByVariable");
        this.functions.push("sortVariablesByCategory");
        this.functions.push("sortVariablesBySample");
        this.functions.push("hideUnhideSmps");
        this.functions.push("hideUnhideVars");
        this.functions.push("desegregateSamples");
        this.functions.push("segregateSamples");
        this.functions.push("groupSamples");
        this.functions.push("ungroupSamples");
        this.functions.push("desegregateVariables");
        this.functions.push("segregateVariables");
        this.functions.push("kmeansSamples");
        this.functions.push("kmeansVariables");
        this.functions.push("showCodeDiv");
        this.functions.push("hideCodeDiv");
        this.functions.push("showInfoDiv");
        this.functions.push("hideInfoDiv");
        this.functions.push("updateCodeDiv");
        this.functions.push("createHistogram");
        this.functions.push("removeHistogram");
        this.functions.push("addRegressionLine");
        this.functions.push("addNormalDistributionLine");
        this.functions.push("recalculateLayout");
        this.functions.push("setSkin");
        this.functions.push("createRandomData");
        this.functions.push("draw");
        this.functions.push("reset");
        this.functions.push("print");
        this.functions.push("saveRemoteParameters")
    };
    this.initializeApi = function () {
        this.setFunctions()
    };
    this.initializeApi()
};
CanvasXpress.prototype.initUtils = function () {
    this.initDimensions();
    this.initGeneralUtils();
    this.initPlotUtils();
    this.initConfigUtils();
    this.initLegendUtils();
    this.init3dUtils();
    this.initApi()
};
CanvasXpress.prototype.initLayout = function () {
    this.isValidLayout = function () {
        var a = this.layout.split(/X/i);
        if (this.autoAdjust && !this.plotByVariable) {
            if (a.length == 2) {
                this.layoutRows = a[0];
                this.layoutCols = a[1]
            } else {
                this.layoutRows = 1;
                this.layoutCols = 1;
                this.layoutValid = false
            }
            if (!this.graphType.match(/Scatter/) && this.layoutComb && this.data.l && (this.data.l.vars || this.data.l.smps) && this.data.l.weight && this.data.l.type) {
                this.data.l.comp = [];
                if (this.data.l.vars && this.data.l.smps) {
                    var f = 0;
                    for (var d = 0; d < this.data.l.smps.length; d++) {
                        for (var b = 0; b < this.data.l.vars.length; b++) {
                            this.data.l.comp[f] = [this.getVariableIndices(this.data.l.vars[b]), this.getSampleIndices(this.data.l.smps[d])];
                            f++
                        }
                    }
                    this.layoutRows = this.data.l.smps.length;
                    this.layoutCols = this.data.l.vars.length
                } else {
                    if (this.data.l.vars) {
                        for (var d = 0; d < this.data.l.vars.length; d++) {
                            this.data.l.comp[d] = this.getVariableIndices(this.data.l.vars[d])
                        }
                    } else {
                        for (var d = 0; d < this.data.l.smps.length; d++) {
                            this.data.l.comp[d] = this.getSampleIndices(this.data.l.smps[d])
                        }
                    }
                    if (this.graphType != "Pie") {
                        if (this.graphOrientation == "vertical") {
                            this.layoutRows = this.data.l.comp.length
                        } else {
                            this.layoutCols = this.data.l.comp.length
                        }
                    }
                }
                this.layoutValid = true;
                this.layoutAdjust = true
            } else {
                if (this.layoutComb && this.data.l && this.data.l.smps && this.data.l.weight && this.data.l.type) {
                    this.data.l.comp = [];
                    var e = this.getVariableIndices(this.data.y.vars);
                    for (var d = 0; d < this.data.l.type.length; d++) {
                        this.data.l.comp[d] = e
                    }
                    this.layoutValid = true
                } else {
                    if (this.data.l && this.data.l.comp) {
                        if (this.data.l.comp.length <= (this.layoutRows * this.layoutCols)) {
                            this.layoutValid = true
                        } else {
                            this.layoutValid = false
                        }
                    } else {
                        this.layoutValid = false
                    }
                }
            }
        } else {
            this.layoutRows = 1;
            this.layoutCols = 1;
            this.layoutValid = false
        }
    };
    this.setLayout = function (a) {};
    this.addLayoutResizer = function (b) {
        var a = 0;
        if (this.resizerType && this.resizerPosition == b) {
            a += this.resizerWidth + (this.margin * 2);
            if (this.resizerType == "samples") {
                a += 14 + this.margin
            }
        }
        return a
    };
    this.getLayoutResizerDimensions = function () {
        if (this.resizerType) {
            var u, j, e, d;
            var f = this.data.l.comp.length - 1;
            var k = this.resizerWidth;
            var z = this.resizerWidth;
            var B = this.marginTop + this.layoutTop;
            var c = this.marginRight + this.layoutRight;
            var q = this.marginBottom + this.layoutBottom;
            var g = this.marginLeft + this.layoutLeft;
            var A = this.getAxesVals(0);
            var s = 0;
            var m = 0;
            switch (this.resizerPosition) {
                case "right":
                    u = "xAxis";
                    j = "y";
                    e = "v";
                    d = "r";
                    B += this["subGraphTop" + 0];
                    g = this.resizerType == "samples" ? this.width - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
                    k = this.height - (B + q + this["subGraphBottom" + f]);
                    break;
                case "left":
                    u = "xAxis";
                    j = "y";
                    e = "v";
                    d = "l";
                    B += this["subGraphTop" + 0];
                    g = this.resizerType == "samples" && this.graphOrientation == "horizontal" ? (this.margin * 2) : this.margin;
                    k = this.height - (B + q + this["subGraphBottom" + f]);
                    break;
                case "top":
                    u = "xAxis";
                    j = "x";
                    e = "h";
                    d = "t";
                    B = this.resizerType == "samples" ? (this.margin * 2) + 14 : this.margin;
                    g += this["subGraphLeft" + 0];
                    z = this.width - (g + c + this["subGraphRight" + f]);
                    m += this.resizerWidth;
                    break;
                case "bottom":
                    u = "xAxis";
                    j = "x";
                    e = "h";
                    d = "b";
                    B = this.resizerType == "samples" && this.graphOrientation == "vertical" ? this.height - ((this.margin * 2) + this.resizerWidth + 14) : this.width - (this.margin + this.resizerWidth);
                    g += this["subGraphLeft" + 0];
                    z = this.width - (g + c + this["subGraphRight" + f]);
                    m += this.resizerWidth;
                    break
            }
            if (e == "v") {
                return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g + 14, B, z, k])
            } else {
                return ([u, g + s, g + s + z, B + m, B + m + k, j, e, d, A, g, B, z, k])
            }
        }
    };
    this.drawLayoutResizer = function () {
        if (this.resizerType) {
            var a = this.getLayoutResizerDimensions();
            this.showAxesResizer(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], "", 0, 0, 0);
            this.drawAxesResizerBackgroundData(a[9], a[10], a[11], a[12]);
            this.drawAxesResizerMasks()
        }
    };
    this.getLayoutMaxLegend = function () {
        if (this.data.l.vars) {
            var a = 0;
            if (this.data.l.comp) {
                for (var b = 0; b < this.data.l.comp.length; b++) {
                    a = Math.max(a, this.data.l.comp[b].length)
                }
            }
            return a
        } else {
            return this.varIndices.length
        }
    };
    
    this.drawLayoutSampleOverlays = function (b) {
        var a = this.smpIndices;
        this.smpIndices = b;
        this.set1DVarSmpLabelFont();
        this.smpIndices = a;
        this.showSampleNames = true;
        this.showOverlays = true;
        this.draw1DYLayout()
    };
    this.drawLayoutVariableLegend = function () {
        this.showLegend = true;
        if (this.graphType == "Pie") {
            this.drawPieLegend()
        } else {
            this.draw1DLegend()
        }
        this.showLegend = false
    };
    this.setLayoutDimensions = function () {
        this.offsetX = 0;
        this.offsetY = 0;
        this.layoutLeft = this.setLayoutLeft();
        this.layoutRight = this.setLayoutRight();
        this.layoutTop = this.setLayoutTop();
        this.layoutBottom = this.setLayoutBottom()
    };
    this.drawLabelsLayout = function () {
        var q = 0;
        var p = 0;
        var o = 0;
        var f = 0;
        var k = this.width - (this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight);
        var d = this.height - (this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom);
        if (this.resizerType) {
            if (this.resizerPosition == "top") {
                p = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
                f = p
            } else {
                if (this.resizerPosition == "left") {
                    q = this.resizerType == "samples" ? (this.margin * 2) + this.resizerWidth + 14 : this.margin + this.resizerWidth;
                    o = q
                }
            }
        }
        if (this.segregateSamplesBy && this.segregateVariablesBy) {
            p += this.fontSize + (this.margin * 4);
            q = this.marginLeft + this.layoutLeft;
            for (var s = 0; s < this.data.l.vars.length; s++) {
                var l = s * this.data.l.smps.length;
                var r = k * this["subGraphWeight" + l][0];
                q += (r / 2);
                this.drawText(this.data.l.name[l][0], q, p, this.font, this.foreground, "center", "middle");
                q += (r / 2)
            }
            q = o + this.fontSize + (this.margin * 4);
            p = this.marginTop + this.layoutTop;
            for (var l = 0; l < this.data.l.smps.length; l++) {
                var m = d * this["subGraphWeight" + l][1];
                p += (m / 2);
                this.drawText(this.data.l.name[l][1], q, p, this.font, this.foreground, "center", "middle", - Math.PI / 2);
                p += (m / 2)
            }
        } else {
            if ((this.segregateSamplesBy || this.segregateVariablesBy) && this.graphOrientation == "vertical" && this.data.l.name) {
                q += this.fontSize + (this.margin * 4);
                p += this.marginTop + this.layoutTop;
                for (var l = 0; l < this.data.l.name.length; l++) {
                    var m = d * this["subGraphWeight" + l];
                    p += (m / 2);
                    this.drawText(this.data.l.name[l], q, p, this.font, this.foreground, "center", "middle", - Math.PI / 2);
                    p += (m / 2)
                }
            } else {
                if ((this.segregateSamplesBy || this.segregateVariablesBy) && this.graphOrientation == "horizontal" && this.data.l.name) {
                    p += this.fontSize + (this.margin * 4);
                    q += this.marginLeft + this.layoutLeft;
                    for (var l = 0; l < this.data.l.name.length; l++) {
                        var r = k * this["subGraphWeight" + l];
                        q += (r / 2);
                        this.drawText(this.data.l.name[l], q, p, this.font, this.foreground, "center", "middle");
                        q += (r / 2)
                    }
                } else {
                    if (this.graphType == "Pie" && (this.showPieGrid || this.showPieSampleLabel)) {
                        var m, r;
                        var n = 0;
                        var t = this.getFontPt(this.font);
                        var b = this.marginTop + this.layoutTop;
                        var e = this.marginLeft + this.layoutLeft;
                        var a = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
                        for (var l = 0; l < this.layoutRows; l++) {
                            m = d * this["subGraphWeight" + n][1];
                            q = (this.marginLeft + this.layoutLeft) - this.margin;
                            b += m;
                            if (this.showPieGrid) {
                                this.drawText(a[l], q, (b + (t / 2)) - (m / 2), this.font, this.foreground, "right", "middle")
                            }
                            for (var g = 0; g < this.layoutCols; g++) {
                                if (this.xAxis.length <= n) {
                                    break
                                }
                                r = k * this["subGraphWeight" + n][0];
                                e += r;
                                p = (this.marginTop + this.layoutTop) - this.margin;
                                if (l == 0) {
                                    if (this.showPieGrid) {
                                        this.drawText(g + 1, (e + (t / 2)) - (r / 2), p, this.font, this.foreground, "center", "bottom")
                                    }
                                }
                                if (this.showPieSampleLabel) {
                                    this.drawText(this.xAxis[n], e - (r / 1.1), b - (m / 5), this.legendFont, this.foreground, "center", "middle")
                                }
                                n++
                            }
                            e = this.marginLeft + this.layoutLeft
                        }
                    }
                }
            }
        }
    };
    this.setLayoutGraphAttributes = function () {
        var g = 0;
        for (var d = 0; d < this.layoutRows; d++) {
            for (var b = 0; b < this.layoutCols; b++) {
                var e = "subGraphType" + g;
                if (!this[e]) {
                    if (this.data.l.type && this.data.l.type[g]) {
                        this[e] = this.data.l.type[g]
                    } else {
                        this[e] = this.graphType
                    }
                }
                var f = "subSummaryType" + g;
                if (this[e] == "Boxplot" || this.summaryType == "iqr") {
                    this[f] = "iqr"
                } else {
                    if (this.summaryType == "median") {
                        this[f] = "median"
                    } else {
                        if (this.summaryType == "sum") {
                            this[f] = "sum"
                        } else {
                            if (this[e] == "Correlation") {
                                this[f] = "cor"
                            } else {
                                if (this[e] == "Candlestick") {
                                    if ((this.graphOrientation == "vertical" && d > 0) || (this.graphOrientation == "horizontal" && b == 0)) {
                                        this[f] = "volume"
                                    } else {
                                        this[f] = "candle"
                                    }
                                } else {
                                    this[f] = "mean"
                                }
                            }
                        }
                    }
                }
                var a = "subTransformType" + g;
                if (!this[a]) {
                    if (this.data.l.transform && this.data.l.transform[g]) {
                        this[a] = this.data.l.transform[g]
                    } else {
                        this[a] = this.subTransformType
                    }
                }
                g++
            }
        }
    };
    this.setLayoutWeights = function () {
        if (this.data.l.weight) {
            var d = 0;
            var e = 0;
            var a;
            var b;
            if (this.allVsAll) {
                for (var c = 0; c < this.layoutRows; c++) {
                    a = "subGraphWeight" + c;
                    b = this[a] ? this[a] : this.data.l.weight[c];
                    d += b
                }
                for (var c = 0; c < this.data.l.weight.length; c++) {
                    a = "subGraphWeight" + c;
                    b = this[a] ? this[a] : this.data.l.weight[c];
                    this.data.l.weight[c] = b / d;
                    this[a] = this.data.l.weight[c]
                }
            } else {
                if (this.data.l.vars && this.data.l.smps) {
                    for (var c = 0; c < this.data.l.weight.length; c++) {
                        a = "subGraphWeight" + c;
                        b = this[a] ? this[a] : this.data.l.weight[c];
                        d += b[0];
                        e += b[1]
                    }
                    for (var c = 0; c < this.data.l.weight.length; c++) {
                        a = "subGraphWeight" + c;
                        b = this[a] ? this[a] : this.data.l.weight[c];
                        this.data.l.weight[c][0] = b[0] / d * this.data.l.smps.length;
                        this.data.l.weight[c][1] = b[1] / e * this.data.l.vars.length;
                        this[a] = this.data.l.weight[c]
                    }
                } else {
                    if (this.graphType == "Pie") {
                        for (var c = 0; c < this.data.l.comp.length; c++) {
                            a = "subGraphWeight" + c;
                            this[a] = this.data.l.weight[c]
                        }
                    } else {
                        for (var c = 0; c < this.data.l.weight.length; c++) {
                            a = "subGraphWeight" + c;
                            b = this[a] ? this[a] : this.data.l.weight[c];
                            d += b
                        }
                        for (var c = 0; c < this.data.l.weight.length; c++) {
                            a = "subGraphWeight" + c;
                            b = this[a] ? this[a] : this.data.l.weight[c];
                            this.data.l.weight[c] = b / d;
                            this[a] = this.data.l.weight[c]
                        }
                    }
                }
            }
        } else {
            if (this.data.l.comp) {
                this.data.l.weight = [];
                for (var c = 0; c < this.data.l.comp.length; c++) {
                    a = "subGraphWeight" + c;
                    this.data.l.weight[c] = this.data.l.comp.length;
                    this[a] = this.data.l.weight[c]
                }
            } else {
                alert("Wuz going on dude? This aint't gonna work!")
            }
        }
    };
    this.setMinimumLayoutAxisFonts = function () {
        var h = 0;
        var e = Number.MAX_VALUE;
        for (var d = 0; d < this.layoutRows; d++) {
            for (var b = 0; b < this.layoutCols; b++) {
                var g, f, a;
                if (this.data.l.desc && this.data.l.desc[h]) {
                    g = this.data.l.desc[h]
                } else {
                    g = "NA"
                }
                a = this.graphOrientation == "vertical" ? this.height * this["subGraphWeight" + h] : this.width * this["subGraphWeight" + h];
                this.setAxisFont(g, a);
                f = this.getFontPt(this.axisTitleFont);
                if (f < e) {
                    e = f;
                    this.minLayoutAxis = e;
                    this.minLayoutAxisTitle = g
                }
                h++
            }
        }
    };
    this.getLayoutSummaryTypes = function () {
        var g = 0;
        var a = {};
        var e = [];
        for (var d = 0; d < this.layoutRows; d++) {
            for (var b = 0; b < this.layoutCols; b++) {
                var f = "subSummaryType" + g;
                if (!a.hasOwnProperty(this[f])) {
                    e.push(this[f]);
                    a[this[f]] = true
                }
                g++
            }
        }
        return e
    };
    this.validateLayoutSummaryGrouping = function () {
        if (this.isGroupedData) {
            var b = this.getLayoutSummaryTypes();
            for (var a = 0; a < b.length; a++) {
                if (!this.isValidPlotData(b[a])) {
                    this.groupSamples(this.groupingFactors, b);
                    break
                }
            }
        }
    };
    this.resetLayout = function () {
        delete(this.data.l);
        delete(this.layoutParams);
        this.offsetX = 0;
        this.offsetY = 0;
        this.layoutValidN = false;
        this.layoutValidR = false;
        this.layoutValidC = false;
        this.layoutComb = false;
        this.layout = "1X1"
    };
    this.drawLayoutCompartments = function (g) {
        var a = [];
        var z = 0;
        var s = 0;
        var x = this.varIndices;
        var u = this.smpIndices;
        var r = this.showSampleNames;
        var o = this.showOverlays;
        var h = this.showLegend;
        var w = this.showIndicators;
        var d = this.getObjectArray(x);
        var f = this.getObjectArray(u);
        var C = false;
        var B = ["left", "right", "top", "bottom", "x", "y", "width", "height", "weight", "offsetX", "offsetY", "varIndices", "smpIndices", "grpIndices", "graphType", "summaryType", "transformType", "varIndicesStart", "smpIndicesStart", "minData", "maxData", "xAxisMin", "xAxisMax", "xAxis2Min", "xAxis2Max", "yAxisMin", "yAxisMax", "zAxisMin", "zAxisMax", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ"];
        var n = ["graphType", "transformType", "varIndicesStart", "smpIndicesStart", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ"];
        var q;
        if (this.layoutComb) {
            if (!this.graphType.match(/Scatter/)) {
                this.layoutMaxVarLegend = this.getLayoutMaxLegend()
            }
            if (this.graphType.match(/Scatter/)) {
                this.xAxis = this.data.y.smps;
                this.yAxis = this.data.y.smps;
                this.initAxes(true)
            } else {
                this.initAxes(false, true)
            }
            //this.setLayoutDimensions();
            var D = this.marginLeft + this.layoutLeft + this.layoutRight + this.marginRight;
            var e = this.marginTop + this.layoutTop + this.layoutBottom + this.marginBottom;
            if (this.graphType.match(/Scatter/)) {
                this.draw2DLegend()
            }
            if (this.layoutParams && this.layoutValidN > -1) {
                q = this.layoutParams;
                if (q[this.layoutValidN]) {
                    for (var y = 0; y < B.length; y++) {
                        q[this.layoutValidN][B[y]] = this[B[y]]
                    }
                }
            }
            this.offsetX = this.layoutLeft;
            this.offsetY = this.layoutTop;
            this.layoutMaxVarLegendLabel = this.data.l.vars ? this.maxVarNameStr : this.maxSmpNameStr;
            this.layoutParams = [];
            if (!this.graphType.match(/Scatter/)) {
                if (this.data.l.vars && this.data.l.smps) {
                    this.layoutRows = this.data.l.smps.length;
                    this.layoutCols = this.data.l.vars.length;
                    this.layoutMaxSamples = this.smpIndices.length * this.layoutCols / this.layoutRows;
                    this.legendPosition = "bottom"
                } else {
                    z = Math.max(this.layoutRows, this.layoutCols);
                    if (this.graphType != "Pie") {
                        if (this.graphOrientation == "vertical") {
                            this.layoutRows = z;
                            this.layoutCols = 1;
                            this.legendPosition = "right"
                        } else {
                            this.layoutRows = 1;
                            this.layoutCols = z;
                            this.legendPosition = "bottom"
                        }
                    }
                }
            }
            this.setLayoutWeights();
            this.setMinimumLayoutAxisFonts();
            this.setLayoutGraphAttributes();
            this.validateLayoutSummaryGrouping();
            var A = 0;
            for (var y = 0; y < this.layoutRows; y++) {
                for (var v = 0; v < this.layoutCols; v++) {
                    this.layoutCurrent = A;
                    if (this.graphType == "Pie") {
                        if (this.data.l.smps.length <= A) {
                            break
                        }
                    }
                    if (q) {
                        for (var t = 0; t < n.length; t++) {
                            this[n[t]] = q[A][n[t]]
                        }
                    }
                    this.weight = this["subGraphWeight" + A];
                    this.graphType = this["subGraphType" + A];
                    this.summaryType = this["subSummaryType" + A];
                    this.transformType = this["subTransformType" + A];
                    if (this["subTransformType" + A]) {
                        this.isTransformedData = true
                    }
                    if (this.data.l.log && this.data.l.log[A]) {
                        this.isLogData = this.data.l.log[A]
                    }
                    if (this.graphType.match(/Scatter/)) {
                        if (this.data.l.smps[A].xAxis && this.data.l.smps[A].yAxis) {
                            this.xAxis = this.data.l.smps[A].xAxis;
                            this.yAxis = this.data.l.smps[A].yAxis;
                            this.xAxisIndices = this.getSampleIndices(this.xAxis);
                            this.yAxisIndices = this.getSampleIndices(this.yAxis)
                        } else {
                            this.xAxis = false;
                            this.yAxis = false;
                            this.xAxisIndices = false;
                            this.yAxisIndices = false
                        }
                        this.layoutWidth = (this.width - D) * this["subGraphWeight" + A];
                        this.layoutHeight = (this.height - e) * this["subGraphWeight" + A];
                        this.varIndices = this.data.l.comp[A];
                        if (this.graphType.match(/Scatter/) && this.layoutAdjust && this.xAxis && this.yAxis) {
                            this.initAxes(true);
                            this.layoutAxis = 3
                        } else {
                            if (this.graphType.match(/Scatter/)) {
                                this.layoutAxis = v == 0 ? 2 : 0;
                                this.layoutAxis = y == this.layoutRows && this.layoutAxis ? 3 : y == this.layoutRows ? 1 : 0
                            }
                        }
                        this.showLegend = false;
                        this.showIndicators = false
                    } else {
                        if (this.data.l.vars && this.data.l.smps) {
                            C = this.graphOrientation == "vertical" ? true : false;
                            this.showLegend = false
                        } else {
                            if (this.graphType == "Pie") {
                                C = false;
                                this.showLegend = false
                            } else {
                                C = this.data.l.smps ? true : false
                            }
                        }
                        this.showSampleNames = C;
                        this.showOverlays = C;
                        this.xAxisTitle = this.data.l.desc && this.data.l.desc[A] ? this.data.l.desc[A] : false;
                        if (this.data.l.vars && this.data.l.smps) {
                            this.layoutHeight = (this.height - e) * this["subGraphWeight" + A][1];
                            this.layoutWidth = (this.width - D) * this["subGraphWeight" + A][0];
                            a = [];
                            for (var t = 0; t < this.data.l.comp[A][0].length; t++) {
                                if (d.hasOwnProperty(this.data.l.comp[A][0][t])) {
                                    a.push(this.data.l.comp[A][0][t])
                                }
                            }
                            this.varIndices = a;
                            a = [];
                            for (var t = 0; t < this.data.l.comp[A][1].length; t++) {
                                if (f.hasOwnProperty(this.data.l.comp[A][1][t])) {
                                    a.push(this.data.l.comp[A][1][t])
                                }
                            }
                            this.smpIndices = a
                        } else {
                            if (this.graphType == "Pie") {
                                this.layoutWidth = (this.width - D) * this["subGraphWeight" + A][0];
                                this.layoutHeight = (this.height - e) * this["subGraphWeight" + A][1]
                            } else {
                                if (this.graphOrientation == "vertical") {
                                    this.layoutHeight = (this.height - e) * this["subGraphWeight" + A];
                                    this.layoutWidth = this.width - D
                                } else {
                                    this.layoutWidth = (this.width - D) * this["subGraphWeight" + A];
                                    this.layoutHeight = this.height - e
                                }
                            }
                            a = [];
                            if (this.data.l.vars) {
                                for (var t = 0; t < this.data.l.comp[A].length; t++) {
                                    if (d.hasOwnProperty(this.data.l.comp[A][t])) {
                                        a.push(this.data.l.comp[A][t])
                                    }
                                }
                                this.varIndices = a
                            } else {
                                for (var t = 0; t < this.data.l.comp[A].length; t++) {
                                    if (f.hasOwnProperty(this.data.l.comp[A][t])) {
                                        a.push(this.data.l.comp[A][t])
                                    }
                                }
                                this.smpIndices = a
                            }
                        }
                        if (this.layoutAdjust) {
                            this.layoutAxis = 3;
                            this.initAxes(true)
                        }
                    }
                    g.call(this);
                    this["subGraphTop" + A] = this.top;
                    this["subGraphBottom" + A] = this.bottom;
                    this["subGraphRight" + A] = this.right;
                    this["subGraphLeft" + A] = this.left;
                    this["subGraphX" + A] = this.x;
                    this["subGraphY" + A] = this.y;
                    var l = ["rect", this.marginLeft + this.offsetX + this.left, this.marginTop + this.offsetY + this.top, this.marginLeft + this.offsetX + this.left + this.x, this.marginTop + this.offsetY + this.top + this.y];
                    if (this.graphType.match(/Scatter/)) {
                        if (y == v) {
                            var p = this.scaleTextToFont(this.maxSmpNameStr, this.maxTextSize, (this.width - D) * 0.8 / this.layoutCols);
                            this.drawText(this.data.y.smps[y], this.marginLeft + this.offsetX + this.left + (this.x / 2), this.marginTop + this.offsetY + this.top + (this.y / 2), p, this.foreground, "center", "middle")
                        }
                    } else {
                        if (!C) {
                            if (this.data.l.vars && this.data.l.smps) {
                                if (this.graphOrientation != "vertical" && A % this.data.l.vars.length == 0) {
                                    this.drawLayoutSampleOverlays(u)
                                }
                                if (A >= this.data.l.vars.length * (this.data.l.smps.length - 1)) {
                                    this.drawLayoutVariableLegend()
                                }
                            } else {
                                if (this.graphType != "Pie") {
                                    if ((this.graphOrientation == "vertical" && (A + 1) == z) || (this.graphOrientation != "vertical" && A == 0)) {
                                        this.drawLayoutSampleOverlays(u)
                                    }
                                } else {
                                    if (this.graphType == "Pie" && A == 0) {
                                        if (h) {
                                            this.drawLayoutVariableLegend()
                                        }
                                    }
                                }
                            }
                        } else {
                            if (this.data.l.vars && this.data.l.smps) {
                                if (A >= this.data.l.vars.length * (this.data.l.smps.length - 1)) {
                                    this.drawLayoutVariableLegend()
                                }
                            }
                        }
                    }
                    var b = {};
                    for (var t = 0; t < B.length; t++) {
                        b[B[t]] = this[B[t]]
                    }
                    b.width = this.layoutWidth;
                    b.height = this.layoutHeight;
                    b.subGraphType = this.graphType;
                    b.subSummaryType = this.SummaryType;
                    b.subTransformType = this.transformType;
                    this.layoutParams.push(b);
                    if (this.graphType.match(/Scatter/) || (this.data.l.vars && this.data.l.smps)) {
                        this.offsetX += this.layoutWidth
                    } else {
                        if (this.graphOrientation == "vertical") {
                            this.offsetY += this.layoutHeight
                        } else {
                            this.offsetX += this.layoutWidth
                        }
                    }
                    A++
                }
                if (this.graphType.match(/Scatter|Pie/) || (this.data.l.vars && this.data.l.smps)) {
                    this.offsetX = this.layoutLeft;
                    this.offsetY += this.layoutHeight
                }
            }
            this.drawLabelsLayout();
            this.drawLayoutResizer();
            this.varIndices = x;
            this.smpIndices = u;
            this.showSampleNames = r;
            this.showOverlays = o;
            this.showLegend = h;
            this.showIndicators = w
        }
    };
    this.initializeLayout = function () {
        this.isValidLayout()
    };
    this.initializeLayout()
};
CanvasXpress.prototype.initViewport = function (a) {
    this.setViewport = function () {
        var s = this.$("container-" + this.target);
        var p = this.toolbarPermanent && this.canvas.height > 400 ? 20 : this.toolbarPermanent && this.canvas.height <= 400 ? 13 : 0;
        if (!s) {
            var o = this.$(this.target);
            o.className = "CanvasXpress";
            var s = this.$cX("div", {
                id: "container-" + this.target,
                className: "CanvasXpressContainer"
            });
            if (a) {
                s.style.display = "none"
            }
            var i = this.$cX("div", {
                id: "north-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: (o.width + 14) + "px",
                height: (p + 7) + "px",
                clear: "left"
            });
            var d = this.$cX("div", {
                id: "north-handler-" + this.target,
                className: "CanvasXpressHandler",
                state: "open",
                open: "url('" + this.imageDir + "tbottom.png')",
                close: "url('" + this.imageDir + "ttop.png')",
                skipWidth: true
            }, {
                width: (o.width + 14) + "px",
                height: "7px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "ttop.png')"
            });
            var l = this.$cX("div", {
                id: "north-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            }, {
                width: (o.width + 14) + "px",
                height: p + "px"
            });
            var q = this.$cX("div", {
                id: "middle-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: (o.width + 14) + "px",
                height: o.height + "px",
                clear: "left"
            });
            var e = this.$cX("div", {
                id: "west-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: "7px",
                height: o.height + "px"
            });
            var b = this.$cX("div", {
                id: "west-handler-" + this.target,
                className: "CanvasXpressHandler",
                state: "open",
                open: "url('" + this.imageDir + "tright.png')",
                close: "url('" + this.imageDir + "tleft.png')",
                skipHeight: true
            }, {
                width: "7px",
                height: o.height + "px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "tleft.png')"
            });
            var h = this.$cX("div", {
                id: "west-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            }, {
                width: "0px",
                height: o.height + "px"
            });
            var g = this.$cX("div", {
                id: "center-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            });
            var k = this.$cX("div", {
                id: "east-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: "7px",
                height: o.height + "px"
            });
            var f = this.$cX("div", {
                id: "east-handler-" + this.target,
                className: "CanvasXpressHandler",
                state: "open",
                open: "url('" + this.imageDir + "tright.png')",
                close: "url('" + this.imageDir + "tleft.png')",
                skipHeight: true
            }, {
                width: "7px",
                height: o.height + "px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "tleft.png')"
            });
            var n = this.$cX("div", {
                id: "east-wrapper-" + this.target,
                className: "CanvasXpressWrapper"
            }, {
                width: "0px",
                height: o.height + "px"
            });
            var m = this.$cX("div", {
                id: "south-container-" + this.target,
                className: "CanvasXpressContainer"
            }, {
                width: (o.width + 14) + "px",
                height: "7px",
                clear: "left"
            });
            var j = this.$cX("div", {
                id: "south-handler-" + this.target,
                className: "CanvasXpressHandler",
                open: "url('" + this.imageDir + "tbottom.png')",
                close: "url('" + this.imageDir + "ttop.png')",
                skipWidth: true
            }, {
                width: (o.width + 14) + "px",
                height: "7px",
                display: "none",
                backgroundImage: "url('" + this.imageDir + "ttop.png')"
            });
            var r = this.$cX("div", {
                id: "south-wrapper-" + this.target,
                className: "CanvasXpressWrapper",
                state: "open"
            }, {
                width: (o.width + 14) + "px",
                height: "0px"
            });
            i.appendChild(d);
            i.appendChild(l);
            e.appendChild(h);
            e.appendChild(b);
            k.appendChild(f);
            k.appendChild(n);
            m.appendChild(j);
            m.appendChild(r);
            q.appendChild(e);
            q.appendChild(g);
            q.appendChild(k);
            s.appendChild(i);
            s.appendChild(q);
            s.appendChild(m);
            o.parentNode.insertBefore(s, o);
            g.appendChild(o.parentNode.appendChild(o));
            this.addRemoveViewportListeners("addEvtListener")
        }
    };
    this.addRemoveViewportListeners = function (d) {
        var e = this.$("north-handler-" + this.target);
        var b = this.$("west-handler-" + this.target);
        var f = this.$("east-handler-" + this.target);
        var c = this.$("south-handler-" + this.target);
        if (e && b && f && c) {
            this[d](e, "click", this.clickViewport, false);
            this[d](b, "click", this.clickViewport, false);
            this[d](f, "click", this.clickViewport, false);
            this[d](c, "click", this.clickViewport, false)
        }
    };
    this.resizeViewportNorth = function () {
        var e = this.$("west-container-" + this.target);
        var c = this.$("east-container-" + this.target);
        var g = this.$("north-container-" + this.target);
        var d = this.$("north-handler-" + this.target);
        var b = this.$("north-wrapper-" + this.target);
        var f = this.toolbarPermanent && this.canvas.height > 400 ? "20px" : this.toolbarPermanent && this.canvas.height <= 400 ? "13px" : 0;
        if (e && c && g && d && b) {
            if (d.style.display == "block" && d.state == "open") {
                g.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px";
                b.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px"
            } else {
                g.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px";
                b.style.width = (parseInt(e.style.width) + this.canvas.width + parseInt(c.style.width)) + "px";
                g.style.height = (f + 7) + "px";
                b.style.height = f + "px"
            }
            d.style.left = parseInt(e.style.width) + "px";
            d.style.width = this.canvas.width + "px"
        }
    };
    this.resizeViewportWest = function () {
        var f = this.$(this.target + "canvasXpressConfigurator");
        var d = this.$("west-container-" + this.target);
        var b = this.$("west-handler-" + this.target);
        var e = this.$("west-wrapper-" + this.target);
        if (d && b && e) {
            if (b.style.display == "block" && b.state == "open") {
                d.style.width = (this.configuratorWidth + 7) + "px";
                e.style.width = this.configuratorWidth + "px";
                d.style.height = this.canvas.height + "px";
                e.style.height = this.canvas.height + "px"
            } else {
                d.style.width = "7px";
                e.style.width = "0px"
            }
            b.style.height = this.canvas.height + "px"
        }
    };
    this.resizeViewportEast = function () {
        var d = this.$(this.target + "canvasXpressDataFilter");
        var b = this.$("east-container-" + this.target);
        var e = this.$("east-handler-" + this.target);
        var c = this.$("east-wrapper-" + this.target);
        if (b && e && c) {
            if (e.style.display == "block" && e.state == "open") {
                b.style.width = (this.dataFilterWidth + 7) + "px";
                c.style.width = this.dataFilterWidth + "px";
                b.style.height = this.canvas.height + "px";
                c.style.height = this.canvas.height + "px"
            } else {
                b.style.width = "7px";
                c.style.width = "0px"
            }
            e.style.height = this.canvas.height + "px"
        }
    };
    this.resizeViewportSouth = function () {
        var j = this.$(this.target + "canvasXpressDataTable");
        var c = this.$("west-handler-" + this.target);
        var g = this.$("west-container-" + this.target);
        var e = this.$("east-container-" + this.target);
        var i = this.$("south-container-" + this.target);
        var f = this.$("south-handler-" + this.target);
        var b = this.$("south-wrapper-" + this.target);
        if (j && c && g && e && i && f && b) {
            var h = c && c.style.display == "none" ? 7 : 0;
            if (f.style.display == "block" && f.state == "open") {
                i.style.height = (parseInt(j.style.height) + 7 + 2) + "px";
                b.style.height = (parseInt(j.style.height) + 2) + "px";
                i.style.width = (parseInt(j.style.width) + 2 + h) + "px";
                b.style.width = i.style.width
            } else {
                i.style.width = (parseInt(g.style.width) + this.canvas.width + parseInt(e.style.width)) + "px";
                b.style.width = (parseInt(g.style.width) + this.canvas.width + parseInt(e.style.width)) + "px";
                i.style.height = "7px";
                b.style.height = "0px"
            }
            f.style.left = parseInt(g.style.width) + "px";
            f.style.width = this.canvas.width + "px"
        }
    };
    this.resizeViewport = function (j) {
        if (j) {
            var b = j.target || j.srcElement;
            if (b.className == "CanvasXpressHandler") {
                return
            }
            if (this.Ext) {
                for (var d = 0; d < CanvasXpress.references.length; d++) {
                    CanvasXpress.references[d].resizeViewport()
                }
            }
            if (b.className && b.className.match(/x-tab-strip-text/)) {
                return
            }
        }
        var h = this.$("middle-container-" + this.target);
        var c = this.$("east-container-" + this.target);
        var g = this.$("west-container-" + this.target);
        if (h && c && g) {
            this.resizeViewportWest();
            this.resizeViewportEast();
            this.resizeViewportNorth();
            this.resizeViewportSouth();
            var f = (parseInt(g.style.width) + this.canvas.width + parseInt(c.style.width) + 1);
            h.style.width = f + "px";
            h.style.height = this.canvas.height + "px"
        }
    };
    this.hideViewport = function () {
        if (this.configuratorLastState && this.configuratorLastState == "docked") {
            var b = this.$("west-handler-" + this.target);
            if (b && b.state == "open") {
                this.clickViewport(false, b)
            }
        }
        if (this.dataFilterLastState && this.dataFilterLastState == "docked") {
            var d = this.$("east-handler-" + this.target);
            if (d && d.state == "open") {
                this.clickViewport(false, d)
            }
        }
        if (this.dataTableLastState && this.dataTableLastState == "docked") {
            var c = this.$("south-handler-" + this.target);
            if (c && c.state == "open") {
                this.clickViewport(false, c)
            }
        }
    };
    this.resetViewportOverflow = function (c) {
        if (c) {
            var b = this.$(c + "-wrapper-" + this.target);
            if (b) {
                b.style.overflow = "visible"
            }
        }
    };
    this.clickViewport = function (b) {
        return function (n, d) {
            if (!n) {
                n = window.event
            }
            if (!d) {
                d = n.target || n.srcElement
            }
            var q, l;
            var g = d.parentNode;
            var j = d.nextSibling || d.previousSibling;
            var f = b.$(this.remoteParentId + "-canvasXpressRemoteWindow");
            var c = b.$("west-handler-" + b.target);
            var k = b.$("north-container-" + b.target);
            var o = b.$("south-container-" + b.target);
            var p = b.$("middle-container-" + b.target);
            var m = b.$("east-container-" + b.target);
            var i = b.$("west-container-" + b.target);
            if (g && j && c && k && o && p && m && i) {
                if (d.state == "closed") {
                    d.state = "open";
                    d.style.backgroundImage = d.close;
                    if (f) {
                        q = d.lastRemoteWidth;
                        l = d.lastRemoteHeight + 7;
                        b.resizeMove(f, 0, 0, d.lastRemoteWidth, d.lastRemoteHeight)
                    }
                    if (d.id.match(/north|south/)) {
                        b.resizeMove(g, 0, 0, d.lastWidth, d.lastHeight + 7);
                        b.resizeMove(j, 0, 0, d.lastWidth, d.lastHeight)
                    } else {
                        b.resizeMove(p, 0, 0, d.lastMiddleWidth, b.canvas.height);
                        b.resizeMove(g, 0, 0, d.lastWidth + 7, b.canvas.height);
                        b.resizeMove(j, 0, 0, d.lastWidth, b.canvas.height)
                    }
                    setTimeout(function () {
                        j.style.overflow = "visible"
                    }, 1000)
                } else {
                    j.style.overflow = "hidden";
                    d.state = "closed";
                    d.lastLeft = parseInt(j.style.left);
                    d.lastTop = parseInt(j.style.top);
                    d.lastWidth = parseInt(j.style.width);
                    d.lastHeight = parseInt(j.style.height);
                    d.lastMiddleWidth = parseInt(p.style.width);
                    d.lastRemoteWidth = f ? parseInt(f.clientWidth) : 0;
                    d.lastRemoteHeight = f ? parseInt(f.clientHeight) : 0;
                    d.style.backgroundImage = d.open;
                    if (d.id.match(/north|south/)) {
                        q = parseInt(i.clientWidth) + b.canvas.width + parseInt(m.clientWidth);
                        l = b.canvas.height + 14;
                        if (f) {
                            b.resizeMove(f, 0, 0, q, l)
                        }
                        b.resizeMove(j, 0, 0, q, 0);
                        b.resizeMove(g, 0, 0, q, 7)
                    } else {
                        l = parseInt(k.clientHeight) + b.canvas.height + parseInt(o.clientHeight);
                        if (d.id.match(/west/)) {
                            q = Math.max(parseInt(o.clientHeight), parseInt(m.clientWidth) + b.canvas.width + 7);
                            if (f) {
                                b.resizeMove(f, 0, 0, q + 48, l + 54)
                            }
                            b.resizeMove(j, 0, 0, 0, b.canvas.height);
                            b.resizeMove(g, 0, 0, 7, b.canvas.height);
                            b.resizeMove(p, 0, 0, parseInt(m.clientWidth) + b.canvas.width + 7, b.canvas.height)
                        } else {
                            q = Math.max(parseInt(o.clientHeight), parseInt(i.clientWidth) + b.canvas.width + 7);
                            if (f) {
                                b.resizeMove(f, 0, 0, q + 48, l + 54)
                            }
                            b.resizeMove(j, 0, 0, 0, b.canvas.height);
                            b.resizeMove(g, 0, 0, 7, b.canvas.height);
                            b.resizeMove(p, 0, 0, parseInt(i.clientWidth) + b.canvas.width + 7, b.canvas.height)
                        }
                    }
                }
                if (f) {
                    setTimeout(function () {
                        b.resizeExtContainer(q + 48, l + 54)
                    }, 500)
                }
            }
            return false
        }
    }(this);
    this.initializeViewport = function () {
        this.setViewport()
    };
    this.initializeViewport()
};
CanvasXpress.prototype.initMenu = function () {
    /*
	this.addMenu = function (h, j) {
        
    };
    this.addMenuItem = function (h, e) {
        
    };
	
    this.addRemoveItemListeners = function (b, a) {
        
    };
    this.clickMenuItem = function (a) {
        
    }(this);
    this.getMenuItemComp = function (d) {
        
    };
    this.mouseoverMenuItem = function (a) {
        
    }(this);
    this.mouseoutMenuItem = function (a) {
        
    }(this); */
    this.hideMenu = function (d) {
        
    };
	/*
    this.setMenu = function () {
        this.menu = {};
        var a = ["Bar", "Line", "Area", "AreaLine", "BarLine", "Boxplot", "Dotplot", "Heatmap", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Candlestick", "Pie", "Correlation", "Circular", "Scatter2D", "ScatterBubble2D", "Scatter3D", "Scatter2D", "Venn", "Network", "Genome"];
        for (var b = 0; b < a.length; b++) {
            this.menu[this.validGraphTypes[b]] = []
        }
        if (this.graphType == "Network") {
            if (this.isSelectNodes) {
                var c = [];
                c.push(["Align nodes top", false, "alignDistributeSelectedNodes", [false, 84]]);
                this.menu.Network.push(["Align", false, false, false, c]);
                c.push(["Align nodes right", false, "alignDistributeSelectedNodes", [false, 82]]);
                c.push(["Align nodes bottom", false, "alignDistributeSelectedNodes", [false, 66]]);
                c.push(["Align nodes left", false, "alignDistributeSelectedNodes", [false, 76]]);
                this.menu.Network.push(["Distribute nodes vertically", false, "alignDistributeSelectedNodes", [false, 86]]);
                this.menu.Network.push(["Distribute nodes horozontally", false, "alignDistributeSelectedNodes", [false, 72]]);
                this.menu.Network.push(["Align", false, false, false, c]);
                this.menu.Network.push(["Show conections for nodes", false, "showHideSelectedDataPoint", [false, 36]]);
                this.menu.Network.push(["Show hidden nodes", false, "showHideSelectedDataPoint", [false, 45]]);
                this.menu.Network.push(["Hide nodes", false, "showHideSelectedDataPoint", [false, 46]]);
                this.menu.Network.push(["Undo", false, "alignDistributeSelectedNodes", [false, 90]]);
                this.menu.Network.push(["Align", false, false, false, c]);
                this.menu.Network.push(["Redo", false, "alignDistributeSelectedNodes", [false, 90, true]])
            }
        }
        for (var b = 0; b < a.length; b++) {
            this.menu[this.validGraphTypes[b]].push(["Print", "disk.png", "print", []])
        }
        return this.menu[this.graphType]
    }*/
};
CanvasXpress.prototype.initToolbar = function () {
    this.addToolbarDiv = function () {
        
    };
    this.addRemoveToolbarListeners = function (c) {
        
    };
    this.showToolbar = function (c) {
        
    };
    this.hideToolbar = function () {
        
    };
    this.isToolbar = function (c) {
        
    };
    this.initializeToolbarEvents = function () {
        
    };
    this.initializeToolbarEvents()
};
CanvasXpress.prototype.initConfigurator = function () {
    this.addConfigurator = function (a) {
        return function (al, F, S, R) {
            if (!al) {
                al = window.event
            }
            var an = a.$(a.target + "canvasXpressConfigurator");
            if (an) {
                if (a.activeTarget) {
                    a.activeTarget.style.zIndex = 10000
                }
                a.activeTarget = an;
                a.activeTarget.style.zIndex = 10001;
                if (a.configuratorLastState && a.configuratorLastState == "docked") {
                    var J = a.$(a.target + "canvasXpressConfiguratorKeyDock");
                    if (J) {
                        J.state = "free"
                    }
                    return a.clickDockUndockConfigurator()
                }
                var D = S != null && R != null ? {
                    x: S,
                    y: R
                } : a.adjustedCoordinates(al);
                if (D) {
                    S = D.x;
                    R = D.y
                }
                an.style.left = S + "px";
                an.style.top = R + "px";
                return
            }
            var I = "Search property or function";
            if (a.isVML || a.disableConfigurator) {
                return
            }
            a.configuringOn = true;
            if (F) {
                if (a.isArray(F)) {
                    F = F[0]
                }
                if (a.graphType == "Network") {
                    a.configuringNetwork = F;
                    if (a.data.nodes.length > F) {
                        I = "Configure " + (a.data.nodes[F].label || a.data.nodes[F].name || a.data.nodes[F].id)
                    } else {
                        var A = a.data.edges[F - a.data.nodes.length];
                        var M = a.data.nodes[a.data.nodeIndices[A.id1]];
                        var L = a.data.nodes[a.data.nodeIndices[A.id2]];
                        I = "Configure " + (M.label || M.name || M.id) + " - " + (L.label || M.name || L.id)
                    }
                } else {
                    if (a.graphType == "Genome") {
                        a.configuringGenome = F;
                        I = "Configure track " + F
                    }
                }
            }
            var D = S != null && R != null ? {
                x: S,
                y: R
            } : a.adjustedCoordinates(al);
            if (D) {
                S = a.applicationLook || a.configuratorLastState == "docked" ? 0 : D.x;
                R = a.applicationLook || a.configuratorLastState == "docked" ? 0 : D.y;
                var an = document.createElement("div");
                an.id = a.target + "canvasXpressConfigurator";
                an.className = a.applicationLook ? "fixed" : "draggable";
                an.style.fontFamily = "arial,tahoma,sans-serif";
                an.style.fontSize = "small";
                an.style.cursor = "move";
                an.style.left = S + "px";
                an.style.top = R + "px";
                an.style.padding = "10px";
                an.style.color = a.skinColor;
                an.style.border = "1px solid " + a.skinBorderColor;
                an.style.backgroundColor = a.skinBackgroundColor;
                an.style.boxShadow = "2px 2px 2px " + a.skinShadowColor;
                an.style.MozBoxShadow = "2px 2px 2px " + a.skinShadowColor;
                an.style.borderRadius = "8px";
                an.style.position = "absolute";
                an.style.zIndex = 10001;
                var ag = document.createElement("div");
                ag.id = a.target + "canvasXpressConfiguratorKeyText";
                ag.style.cursor = "default";
                ag.style.display = "block";
                ag.style.marginBottom = "5px";
                ag.style.width = a.configuratorWidth + "px";
                ag.style.fontWeight = "bold";
                var aj = document.createElement("span");
                aj.id = a.target + "canvasXpressConfiguratorKeyTextSpan";
                aj.innerHTML = I;
                var ai = document.createElement("img");
                ai.id = a.target + "canvasXpressConfiguratorKeyHelp";
                ai.src = a.imageDir + "help1.png";
                ai.alt = "Help";
                ai.title = "Help";
                ai.style.width = "13px";
                ai.style.height = "13px";
                ai.style.marginLeft = "2px";
                ai.style.cssFloat = "right";
                var B = document.createElement("img");
                B.id = a.target + "canvasXpressConfiguratorKeySave";
                B.src = a.imageDir + "disk.png";
                B.alt = "Save as png";
                B.title = "Save as png";
                B.style.width = "13px";
                B.style.height = "13px";
                B.style.marginLeft = "2px";
                B.style.cssFloat = "right";
                var Q = document.createElement("img");
                Q.id = a.target + "canvasXpressConfiguratorKeyFilter";
                Q.src = a.imageDir + "funnel.png";
                Q.alt = "Filter data";
                Q.title = "Filter data";
                Q.style.width = "13px";
                Q.style.height = "13px";
                Q.style.marginLeft = "2px";
                Q.style.cssFloat = "right";
                var t = document.createElement("img");
                t.id = a.target + "canvasXpressConfiguratorKeyData";
                t.src = a.imageDir + "table.png";
                t.alt = "Show data";
                t.title = "Show data";
                t.style.width = "13px";
                t.style.height = "13px";
                t.style.marginLeft = "2px";
                t.style.cssFloat = "right";
                var C = document.createElement("img");
                C.id = a.target + "canvasXpressConfiguratorKeyAdvanced";
                C.src = a.showAdvancedConfiguration ? a.imageDir + "lightbulb.png" : a.imageDir + "lightbulb_off.png";
                C.alt = a.showAdvancedConfiguration ? "Show basic configuaration properties" : "Show advanced configuaration properties";
                C.title = a.showAdvancedConfiguration ? "Show basic configuaration properties" : "Show advanced configuaration properties";
                C.style.width = "13px";
                C.style.height = "13px";
                C.style.marginLeft = "2px";
                C.style.cssFloat = "right";
                var ak = document.createElement("img");
                ak.id = a.target + "canvasXpressConfiguratorKeySearch";
                ak.src = a.imageDir + "find.png";
                ak.style.marginLeft = "2px";
                ak.alt = "Browse properties by category";
                ak.title = "Browse properties by category";
                ak.style.width = "13px";
                ak.style.height = "13px";
                ak.style.marginLeft = "2px";
                ak.style.cssFloat = "right";
                var E = document.createElement("img");
                E.id = a.target + "canvasXpressConfiguratorKeyDock";
                E.src = a.applicationLook ? a.imageDir + "unpin.png" : a.imageDir + "pin.png";
                E.alt = a.applicationLook ? "Undock" : "Dock";
                E.title = a.applicationLook ? "Undock" : "Dock";
                E.state = a.applicationLook ? "docked" : "free";
                E.style.display = "none";
                E.style.width = "13px";
                E.style.height = "13px";
                E.style.marginLeft = "2px";
                E.style.cssFloat = "right";
                var ae = document.createElement("img");
                ae.id = a.target + "canvasXpressConfiguratorKeyClose";
                ae.src = a.imageDir + "cancel1.png";
                ae.alt = "Close";
                ae.title = "Close";
                ae.style.width = "13px";
                ae.style.height = "13px";
                ae.style.marginLeft = "2px";
                ae.style.cssFloat = "right";
                var af = document.createElement("input");
                af.id = a.target + "canvasXpressConfiguratorKey";
                af.type = "text";
                af.style.cursor = "default";
                af.style.display = "block";
                af.style.width = a.configuratorWidth + "px";
                af.style.borderRadius = "4px";
                af.style.MozBorderRadius = "4px";
                var ad = document.createElement("select");
                ad.id = a.target + "canvasXpressConfiguratorCategories";
                ad.style.cursor = "default";
                ad.style.display = "none";
                ad.style.width = a.configuratorWidth + "px";
                ad.style.borderRadius = "4px";
                ad.style.MozBorderRadius = "4px";
                ad.size = 5;
                var X = document.createElement("div");
                X.id = a.target + "canvasXpressConfiguratorSugestionsText";
                X.style.cursor = "default";
                X.style.display = "none";
                X.style.margin = "5px 0px 5px 0px";
                X.style.width = a.configuratorWidth + "px";
                X.innerHTML = "Select property";
                X.style.fontWeight = "bold";
                var G = document.createElement("div");
                G.id = a.target + "canvasXpressConfiguratorSugestionsDiv";
                G.style.cursor = "s-resize";
                G.style.display = "none";
                G.style.overflow = "auto";
                G.style.height = "100px";
                var W = document.createElement("select");
                W.id = a.target + "canvasXpressConfiguratorSugestions";
                W.style.cursor = "default";
                W.style.display = "none";
                W.style.width = a.configuratorWidth + "px";
                W.style.borderRadius = "4px";
                W.style.MozBorderRadius = "4px";
                W.style.overflow = "auto";
                W.size = a.mobileApp ? 5 : 10;
                var am = document.createElement("div");
                am.id = a.target + "canvasXpressConfiguratorSugestionsDescription";
                am.style.cursor = "default";
                am.style.display = "none";
                am.style.backgroundColor = a.skinBackgroundColor;
                am.style.margin = "5px 0px 5px 0px";
                am.style.width = a.configuratorWidth + "px";
                am.style.minHeight = "56px";
                am.style.overflow = "auto";
                var V = document.createElement("div");
                V.id = a.target + "canvasXpressConfiguratorValueText";
                V.style.cursor = "default";
                V.style.display = "none";
                V.style.margin = "5px 0px 5px 0px";
                V.style.width = a.configuratorWidth + "px";
                V.innerHTML = "Current value";
                V.style.fontWeight = "bold";
                var ap = document.createElement("div");
                ap.id = a.target + "canvasXpressConfiguratorSeeAlso";
                ap.style.cursor = "default";
                ap.style.display = "none";
                ap.style.backgroundColor = a.skinBackgroundColor;
                ap.style.width = a.configuratorWidth + "px";
                ap.style.minHeight = "20px";
                ap.style.overflow = "auto";
                var U = document.createElement("input");
                U.id = a.target + "canvasXpressConfiguratorValue";
                U.type = "text";
                U.style.cursor = "default";
                U.style.display = "none";
                U.style.width = a.configuratorWidth + "px";
                U.style.borderRadius = "4px";
                U.style.MozBorderRadius = "4px";
                var H = document.createElement("input");
                H.id = a.target + "canvasXpressConfiguratorApply";
                H.value = "Apply";
                H.type = "button";
                H.style.cursor = "default";
                H.style.display = "none";
                H.style.cssFloat = "left";
                H.style.width = (a.configuratorWidth / 2) + "px";
                H.style.borderRadius = "4px";
                H.style.MozBorderRadius = "4px";
                var ao = document.createElement("input");
                ao.id = a.target + "canvasXpressConfiguratorButton";
                ao.value = "Draw";
                ao.type = "button";
                ao.style.cursor = "default";
                ao.style.display = "none";
                ao.style.cssFloat = "left";
                ao.style.width = (a.configuratorWidth / 2) + "px";
                ao.style.borderRadius = "4px";
                ao.style.MozBorderRadius = "4px";
                var Y = document.createElement("img");
                Y.id = a.target + "canvasXpressConfiguratorOptionsClose";
                Y.src = a.imageDir + "cancel1.png";
                Y.style.width = "13px";
                Y.style.height = "13px";
                Y.style.cssFloat = "right";
                Y.style.cursor = "default";
                var P = document.createElement("div");
                P.id = a.target + "canvasXpressConfiguratorOptions";
                P.className = "draggable";
                P.style.cursor = "move";
                P.style.resize = "both";
                P.style.display = "none";
                P.style.padding = "10px";
                P.style.border = "1px solid " + a.skinBorderColor;
                P.style.backgroundColor = a.skinBackgroundColor;
                P.style.boxShadow = "2px 2px 2px " + a.skinShadowColor;
                P.style.MozBoxShadow = "2px 2px 2px " + a.skinShadowColor;
                P.style.borderRadius = "8px";
                P.style.position = "absolute";
                P.style.fontWeight = "bold";
                var ah = document.createElement("img");
                ah.id = a.target + "canvasXpressConfiguratorHelpClose";
                ah.src = a.imageDir + "cancel1.png";
                ah.style.width = "13px";
                ah.style.height = "13px";
                ah.style.cssFloat = "right";
                ah.style.cursor = "default";
                var T = document.createElement("div");
                T.id = a.target + "canvasXpressConfiguratorHelp";
                T.className = "draggable";
                T.style.cursor = "move";
                T.style.display = "none";
                T.style.padding = "10px";
                T.style.border = "1px solid " + a.skinBorderColor;
                T.style.backgroundColor = a.skinBackgroundColor;
                T.style.boxShadow = "2px 2px 2px " + a.skinShadowColor;
                T.style.MozBoxShadow = "2px 2px 2px " + a.skinShadowColor;
                T.style.borderRadius = "8px";
                T.style.fontWeight = "bold";
                T.style.position = "absolute";
                var aa = document.createElement("div");
                aa.id = a.target + "canvasXpressConfiguratorColorCurrent";
                aa.style.width = "181px";
                aa.style.height = "16px";
                aa.style.cssFloat = "left";
                aa.style.fontSize = "x-small";
                aa.style.border = "1px solid " + a.configuratorBorderColor;
                aa.style.cursor = "default";
                var Z = document.createElement("img");
                Z.id = a.target + "canvasXpressConfiguratorColorClose";
                Z.src = a.imageDir + "cancel1.png";
                Z.style.clear = "none";
                Z.style.width = "13px";
                Z.style.height = "13px";
                Z.style.cssFloat = "right";
                Z.style.cursor = "default";
                var ac = document.createElement("div");
                ac.id = a.target + "canvasXpressConfiguratorColor";
                ac.className = "draggable";
                ac.style.cursor = "move";
                ac.style.display = "none";
                ac.style.padding = "10px";
                ac.style.border = "1px solid " + a.skinBorderColor;
                ac.style.backgroundColor = a.skinBackgroundColor;
                ac.style.boxShadow = "2px 2px 2px " + a.skinShadowColor;
                ac.style.MozBoxShadow = "2px 2px 2px " + a.skinShadowColor;
                ac.style.borderRadius = "8px";
                ac.style.width = "204px";
                ac.style.position = "absolute";
                var K = document.createElement("div");
                K.id = a.target + "canvasXpressConfiguratorFilter";
                K.className = "draggable";
                K.style.cursor = "move";
                K.style.display = "none";
                K.style.padding = "10px";
                K.style.border = "1px solid " + a.skinBorderColor;
                K.style.backgroundColor = a.skinBackgroundColor;
                K.style.boxShadow = "2px 2px 2px " + a.skinShadowColor;
                K.style.MozBoxShadow = "2px 2px 2px " + a.skinShadowColor;
                K.style.borderRadius = "8px";
                K.style.position = "absolute";
                var O = document.createElement("b");
                var N = document.createElement("img");
                N.id = a.target + "canvasXpressConfiguratorFilterClose";
                N.src = a.imageDir + "cancel1.png";
                N.style.clear = "none";
                N.style.width = "13px";
                N.style.height = "13px";
                N.style.cssFloat = "right";
                N.style.cursor = "default";
                ag.appendChild(aj);
                ag.appendChild(ae);
                ag.appendChild(E);
                ag.appendChild(C);
                ag.appendChild(ak);
                ag.appendChild(B);
                ag.appendChild(Q);
                ag.appendChild(t);
                ag.appendChild(ai);
                P.appendChild(document.createTextNode("Select option ..."));
                P.appendChild(Y);
                P.appendChild(document.createElement("br"));
                T.appendChild(document.createTextNode("Help"));
                T.appendChild(ah);
                T.appendChild(document.createElement("br"));
                ac.appendChild(aa);
                ac.appendChild(Z);
                ac.appendChild(document.createElement("br"));
                O.appendChild(document.createTextNode("Build filter '+' to set '-' to remove"));
                K.appendChild(O);
                K.appendChild(N);
                K.appendChild(document.createElement("br"));
                an.appendChild(ag);
                an.appendChild(af);
                an.appendChild(ad);
                an.appendChild(X);
                G.appendChild(W);
                an.appendChild(G);
                an.appendChild(am);
                an.appendChild(ap);
                an.appendChild(V);
                an.appendChild(U);
                an.appendChild(H);
                an.appendChild(ao);
                an.appendChild(P);
                an.appendChild(T);
                an.appendChild(ac);
                an.appendChild(K);
                var ab = a.$("west-wrapper-" + a.target);
                if (ab) {
                    ab.appendChild(an);
                    if (a.activeTarget) {
                        a.activeTarget.style.zIndex = 10000
                    }
                    a.activeTarget = an;
                    a.addRemoveConfiguratorListeners("addEvtListener");
                    if (a.configuringNetwork || a.configuringGenome) {
                        a.selectConfig(false, true)
                    }
                    setTimeout(function () {
                        af.focus()
                    }, 300)
                }
            }
        }
    }(this);
    this.addRemoveConfiguratorListeners = function (k) {
        var I = this.$(this.target + "canvasXpressConfigurator");
        var A = this.$(this.target + "canvasXpressConfiguratorCategories");
        var a = this.$(this.target + "canvasXpressConfiguratorSugestionsDiv");
        var o = this.$(this.target + "canvasXpressConfiguratorSugestions");
        var d = this.$(this.target + "canvasXpressConfiguratorApply");
        var J = this.$(this.target + "canvasXpressConfiguratorButton");
        var B = this.$(this.target + "canvasXpressConfiguratorKeyClose");
        var K = this.$(this.target + "canvasXpressConfiguratorKeyDock");
        var H = this.$(this.target + "canvasXpressConfiguratorKeyAdvanced");
        var F = this.$(this.target + "canvasXpressConfiguratorKeyHelp");
        var G = this.$(this.target + "canvasXpressConfiguratorKeySearch");
        var C = this.$(this.target + "canvasXpressConfiguratorKeySave");
        var D = this.$(this.target + "canvasXpressConfiguratorKeyFilter");
        var r = this.$(this.target + "canvasXpressConfiguratorKeyData");
        var e = this.$(this.target + "canvasXpressConfiguratorOptions");
        var u = this.$(this.target + "canvasXpressConfiguratorOptionsClose");
        var j = this.$(this.target + "canvasXpressConfiguratorHelp");
        var E = this.$(this.target + "canvasXpressConfiguratorHelpClose");
        var y = this.$(this.target + "canvasXpressConfiguratorColor");
        var x = this.$(this.target + "canvasXpressConfiguratorColorClose");
        var g = this.$(this.target + "canvasXpressConfiguratorFilter");
        var v = this.$(this.target + "canvasXpressConfiguratorFilterClose");
        if (I && A && a && o && J && d && B && K && H && F && G && C && D && r && e && u && j && E && y && x && g && v) {
            this[k](I, "mousedown", this.registerMousemove, false);
            this[k](A, "change", this.changeCategory, false);
            this[k](A, "click", this.changeCategory, false);
            this[k](a, "mousedown", this.mousedownSuggestionsDiv, false);
            this[k](o, "change", this.clickSuggestions, false);
            this[k](o, "click", this.clickSuggestions, false);
            this[k](d, "click", this.clickApplyConfigurator, false);
            this[k](J, "click", this.clickConfigurator, false);
            this[k](F, "click", this.clickHelp, false);
            this[k](r, "click", this.clickDataTable, false);
            this[k](D, "click", this.clickDataFilter, false);
            this[k](C, "click", this.print, false);
            this[k](G, "click", this.clickSearch, false);
            this[k](H, "click", this.clickAdvanced, false);
            this[k](K, "click", this.clickDockUndockConfigurator, false);
            this[k](B, "click", this.closeConfigurator, false);
            this[k](e, "mousedown", this.registerMousemove, false);
            this[k](u, "click", this.closePropertyOptions, false);
            this[k](j, "mousedown", this.registerMousemove, false);
            this[k](E, "click", this.closeHelp, false);
            this[k](y, "mousedown", this.registerMousemove, false);
            this[k](x, "click", this.closePropertyColor, false);
            this[k](g, "mousedown", this.registerMousemove, false);
            this[k](v, "click", this.closePropertyFilter, false)
        }
    };
    this.getConfigurableProperties = function () {
        if (this.configuringNetwork) {
            if (this.data.nodes.length > this.configuringNetwork) {
                return this.getNodeConfigurableProperties(this.configuringNetwork)
            } else {
                return this.getEdgeConfigurableProperties(this.configuringNetwork - this.data.nodes.length)
            }
        } else {
            if (this.configuringGenome) {
                if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
                    return this.featureConfigurableProperties
                } else {
                    if (this.configuringGenome.match(/track/)) {
                        return this.trackConfigurableProperties
                    } else {
                        this.configuringGenome = false
                    }
                }
            }
        }
        var d = [];
        for (var c in CanvasXpress.doc.P) {
            var a = CanvasXpress.doc.P[c].M;
            var b = CanvasXpress.doc.P[c].U;
            if (CanvasXpress.doc.M[a].U) {
                if (CanvasXpress.doc.M[a].U.hasOwnProperty(this.graphType)) {
                    if (this.showAdvancedConfiguration) {
                        d.push(c)
                    } else {
                        if (!CanvasXpress.doc.P[c].A) {
                            d.push(c)
                        }
                    }
                }
            } else {
                if (this.showAdvancedConfiguration) {
                    if (b) {
                        if (b.hasOwnProperty(this.graphType)) {
                            d.push(c)
                        }
                    } else {
                        d.push(c)
                    }
                } else {
                    if (!CanvasXpress.doc.P[c].A) {
                        if (b) {
                            if (b.hasOwnProperty(this.graphType)) {
                                d.push(c)
                            } else {
                                d.push(c)
                            }
                        }
                    }
                }
            }
        }
        return d
    };
    this.getConfigurableObjectDoc = function (a) {
        if (this.configuringNetwork) {
            if (this.data.nodes.length > this.configuringNetwork) {
                return CanvasXpress.doc.N[a] ? CanvasXpress.doc.N[a] : false
            } else {
                return CanvasXpress.doc.E[a] ? CanvasXpress.doc.E[a] : false
            }
        } else {
            if (this.configuringGenome) {
                if (!isNaN(this.configuringGenome) || this.configuringGenome.match(/:/)) {
                    return CanvasXpress.doc.F[a] ? CanvasXpress.doc.F[a] : false
                } else {
                    if (this.configuringGenome.match(/track/)) {
                        return CanvasXpress.doc.G[a] ? CanvasXpress.doc.G[a] : false
                    } else {
                        this.configuringGenome = false;
                        return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
                    }
                }
            } else {
                return CanvasXpress.doc.P[a] ? CanvasXpress.doc.P[a] : false
            }
        }
    };
    this.selectConfig = function (E, G) {
        var A = this.$(this.target + "canvasXpressConfiguratorKey");
        var w = this.$(this.target + "canvasXpressConfiguratorSugestionsText");
        var f = this.$(this.target + "canvasXpressConfiguratorSugestionsDiv");
        var q = this.$(this.target + "canvasXpressConfiguratorSugestions");
        var F = this.$(this.target + "canvasXpressConfiguratorSugestionsDescription");
        var m = this.$(this.target + "canvasXpressConfiguratorValueText");
        var I = this.$(this.target + "canvasXpressConfiguratorSeeAlso");
        var l = this.$(this.target + "canvasXpressConfiguratorValue");
        var g = this.$(this.target + "canvasXpressConfiguratorApply");
        var H = this.$(this.target + "canvasXpressConfiguratorButton");
        var C = this.$(this.target + "canvasXpressConfiguratorValueHREF");
        var n = document.activeElement;
        var z = this.getConfigurableProperties();
        var y = [];
        if (this.getKeyCode(E) == 13) {
            this.resetHelpOptionColorFilters();
            if (this.editingDescriptionOn) {
                this.submitEditPropertyDescription()
            } else {
                if (q && l && l.value) {
                    var j = false;
                    for (var B = 0; B < z.length; B++) {
                        if (q.value == z[B]) {
                            j = true;
                            break
                        }
                    }
                    if (j) {
                        this.clickConfigurator(E, q, l)
                    } else {
                        this.resetConfigurator()
                    }
                }
            }
        } else {
            if (n.id.match(/canvasXpressConfiguratorFilterValue/)) {
                return
            } else {
                if (A && n.id == A.id || G) {
                    this.resetHelpOptionColorFilters();
                    this.resetEditPropertyDescription();
                    for (var B = 0; B < z.length; B++) {
                        if (z[B].toLowerCase().indexOf(A.value.toLowerCase()) >= 0) {
                            y.push(z[B])
                        }
                    }
                    if (y.length > 0 && w && f && q && F && m && I && l && H && g) {
                        this.resetSugestions();
                        if (!this.configuringNetwork && !this.configuringGenome) {
                            y.sort(function (d, c) {
                                return CanvasXpress.doc.P[d].M > CanvasXpress.doc.P[c].M ? 1 : CanvasXpress.doc.P[c].M > CanvasXpress.doc.P[d].M ? -1 : d > c ? 1 : c > d ? -1 : 0
                            });
                            for (var B = 0; B < y.length; B++) {
                                var z = document.createElement("option");
                                z.text = CanvasXpress.doc.P[y[B]].M ? CanvasXpress.doc.P[y[B]].M + " : " + y[B] : "NA : " + y[B];
                                z.value = y[B];
                                try {
                                    q.add(z, null)
                                } catch (D) {
                                    q.add(z)
                                }
                            }
                        } else {
                            y.sort();
                            for (var B = 0; B < y.length; B++) {
                                var z = document.createElement("option");
                                z.text = y[B];
                                z.value = y[B];
                                try {
                                    q.add(z, null)
                                } catch (D) {
                                    q.add(z)
                                }
                            }
                        }
                        q.options[0].selected = true;
                        this.setConfiguratorPropertyValue(q, F, m, I, l);
                        w.innerHTML = "Select property (" + y.length + ")";
                        w.style.display = "block";
                        f.style.display = "block";
                        q.style.display = "block";
                        F.style.display = "block";
                        m.style.display = "block";
                        I.style.display = "block";
                        l.style.display = "block";
                        H.style.display = "block";
                        g.style.display = "block"
                    } else {
                        A.value = A.value.slice(0, A.value.length - 1)
                    }
                } else {
                    if (l && n.id == l.id) {
                        this.resetHelpOptionColorFilters();
                        this.resetEditPropertyDescription();
                        if (C && C.innerHTML == "color") {
                            C.style.color = l.value ? this.rgbToHex(this.validateColor(l.value.replace(/[\'\"]/g, ""))) : this.foreground
                        }
                    } else {
                        if (this.remoteService) {
                            this.resetHelpOptionColorFilters();
                            this.selectDataSet(E)
                        }
                    }
                }
            }
        }
        return false
    };
    this.clickHelp = function (a) {
        return function (c) {
            if (!c) {
                c = window.event
            }
            var b = a.$(a.target + "canvasXpressConfiguratorHelp");
            a.resetHelpEditOptionColorFilters();
            if (b) {
                a.addHelp(b);
                b.style.display = "block";
                b.style.left = c.layerX + "px";
                b.style.top = c.layerY + "px"
            }
            return false
        }
    }(this);
    this.addHelp = function (q) {
        if (!this.helpOn) {
            var l = document.createElement("div");
            l.style.width = this.configuratorWidth + "px";
            l.style.fontWeight = "normal";
            l.appendChild(document.createElement("br"));
            var v = document.createElement("p");
            v.innerHTML = "This widget allows you to customize this graph. You may enter the name of the property you wish to customize in the text box (which filters as you type) or browse through a number of categories.";
            l.appendChild(v);
            var r = document.createElement("p");
            r.innerHTML = "You will find a short description for the property you select along with its category and links to other relevant properties.";
            l.appendChild(r);
            var o = document.createElement("p");
            o.innerHTML = "You will also see the current value for the seleced property along with a link to an additional widget to help you specifying the new value.";
            l.appendChild(o);
            var f = document.createElement("img");
            f.src = this.imageDir + "help1.png";
            l.appendChild(f);
            l.appendChild(document.createTextNode(" Show help on this configurator"));
            l.appendChild(document.createElement("br"));
            var b = document.createElement("img");
            b.src = this.imageDir + "disk.png";
            l.appendChild(b);
            l.appendChild(document.createTextNode(" Save the image as a 'png' file"));
            l.appendChild(document.createElement("br"));
            var g = document.createElement("img");
            g.src = this.imageDir + "table.png";
            l.appendChild(g);
            l.appendChild(document.createTextNode(" Show the data used for this visualization"));
            l.appendChild(document.createElement("br"));
            var n = document.createElement("img");
            n.src = this.imageDir + "lightbulb.png";
            l.appendChild(n);
            l.appendChild(document.createTextNode(" Show or hide advanced customizations"));
            l.appendChild(document.createElement("br"));
            var y = document.createElement("img");
            y.src = this.imageDir + "find.png";
            l.appendChild(y);
            l.appendChild(document.createTextNode(" Search by categories of the customization"));
            l.appendChild(document.createElement("br"));
            var e = document.createElement("img");
            e.src = this.imageDir + "pin.png";
            l.appendChild(e);
            l.appendChild(document.createTextNode(" Dock the configurator to the left side"));
            l.appendChild(document.createElement("br"));
            var t = document.createElement("img");
            t.src = this.imageDir + "unpin.png";
            l.appendChild(t);
            l.appendChild(document.createTextNode(" Undock the configurator from the left side"));
            l.appendChild(document.createElement("br"));
            var j = document.createElement("img");
            j.src = this.imageDir + "cancel1.png";
            l.appendChild(j);
            l.appendChild(document.createTextNode(" Hide the help on this configurator"));
            l.appendChild(document.createElement("br"));
            l.appendChild(document.createElement("br"));
            var m = document.createElement("a");
            m.href = "http://canvasxpress.org";
            m.target = "_blank";
            m.innerHTML = "canvasXpress";
            l.appendChild(document.createTextNode("Additional documentation at "));
            l.appendChild(m);
            l.appendChild(document.createElement("br"));
            q.appendChild(l);
            this.helpOn = true
        }
    };
    this.closeHelp = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "canvasXpressConfiguratorHelp")
        }
    }(this);
    this.clickDataTable = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            if (a.configuratorLastState && a.configuratorLastState == "docked") {
                a.clickDockUndockConfigurator()
            }
            a.resetConfigurator();
            a.updateDataTable();
            return false
        }
    }(this);
    this.clickDataFilter = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            if (a.filterLastState && a.filterLastState == "docked") {
                a.clickDockUndockFilter()
            }
            a.resetConfigurator();
            a.showDataFilter();
            return false
        }
    }(this);
    this.clickSearch = function (a) {
        return function (J) {
            if (!J) {
                J = window.event
            }
            a.configuringNetwork = false;
            a.configuringGenome = false;
            a.resetHelpEditOptionColorFilters();
            var H = a.$(a.target + "canvasXpressConfiguratorKeyTextSpan");
            var F = a.$(a.target + "canvasXpressConfiguratorKey");
            var D = a.$(a.target + "canvasXpressConfiguratorCategories");
            var A = a.$(a.target + "canvasXpressConfiguratorSugestionsText");
            var c = a.$(a.target + "canvasXpressConfiguratorSugestionsDiv");
            var y = a.$(a.target + "canvasXpressConfiguratorSugestions");
            var K = a.$(a.target + "canvasXpressConfiguratorSugestionsDescription");
            var x = a.$(a.target + "canvasXpressConfiguratorValueText");
            var M = a.$(a.target + "canvasXpressConfiguratorSeeAlso");
            var t = a.$(a.target + "canvasXpressConfiguratorValue");
            var L = a.$(a.target + "canvasXpressConfiguratorButton");
            var f = a.$(a.target + "canvasXpressConfiguratorApply");
            var h = a.$(a.target + "canvasXpressConfiguratorOptions");
            var q = a.$(a.target + "canvasXpressConfiguratorHelp");
            var C = a.$(a.target + "canvasXpressConfiguratorColor");
            var j = a.$(a.target + "canvasXpressConfiguratorFilter");
            var E = a.getKeys(CanvasXpress.doc.M).sort();
            var p = [];
            if (F && F.style.display == "none") {
                if (H) {
                    H.innerText = "Search property or function"
                }
                if (D) {
                    D.style.display = "none"
                }
                F.value = "";
                F.style.display = "block"
            } else {
                if (H) {
                    for (var G = 0; G < E.length; G++) {
                        if (CanvasXpress.doc.M[E[G]].U) {
                            if (CanvasXpress.doc.M[E[G]].U.hasOwnProperty(a.graphType)) {
                                if (a.showAdvancedConfiguration) {
                                    p.push(E[G])
                                } else {
                                    if (CanvasXpress.doc.M[E[G]].B) {
                                        p.push(E[G])
                                    }
                                }
                            }
                        } else {
                            if (a.showAdvancedConfiguration) {
                                p.push(E[G])
                            } else {
                                if (CanvasXpress.doc.M[E[G]].B) {
                                    p.push(E[G])
                                }
                            }
                        }
                        H.innerText = "Select category (" + p.length + ")"
                    }
                }
                if (F) {
                    F.style.display = "none"
                }
                if (D) {
                    a.resetCategories();
                    for (var G = 0; G < p.length; G++) {
                        var B = document.createElement("option");
                        B.text = p[G];
                        B.value = p[G];
                        try {
                            D.add(B, null)
                        } catch (I) {
                            D.add(B)
                        }
                    }
                    D.style.display = "block"
                }
            }
            if (A && c && y && K && x && M && t && L && f && h && q && C && j) {
                A.style.display = "none";
                c.style.display = "none";
                y.style.display = "none";
                K.style.display = "none";
                x.style.display = "none";
                M.style.display = "none";
                t.style.display = "none";
                L.style.display = "none";
                f.style.display = "none";
                h.style.display = "none";
                q.style.display = "none";
                C.style.dysplay = "none";
                j.style.dysplay = "none"
            }
            return false
        }
    }(this);
    this.clickDockUndockConfigurator = function (a) {
        return function (j, b) {
            if (!j) {
                j = window.event
            }
            var m = a.$(a.target + "canvasXpressConfigurator");
            var k = a.$(a.target + "canvasXpressConfiguratorKeyDock");
            var n = a.$("middle-container-" + a.target);
            var g = a.$("west-container-" + a.target);
            var f = a.$("west-handler-" + a.target);
            var h = a.$("east-container-" + a.target);
            if (m && k && n && g && f && h) {
                var l = parseInt(m.style.padding);
                if (k.state == "free" && !b) {
                    a.resizeViewportWest();
                    m.className = "fixed";
                    m.style.cursor = "default";
                    m.style.borderRadius = "0px";
                    m.style.border = "";
                    k.src = a.imageDir + "unpin.png";
                    k.alt = "Undock";
                    k.title = "Undock";
                    k.state = "docked";
                    a.configuratorLastState = "docked";
                    n.style.width = parseInt(m.clientWidth) + 7 + a.canvas.width + parseInt(h.clientWidth);
                    a.resizeMove(g, 0, 0, parseInt(m.clientWidth) + 7, Math.max(a.canvas.height, parseInt(m.clientHeight)), 500, null);
                    a.resizeMove(m, 0, 0, a.configuratorWidth, parseInt(m.clientHeight) - (l * 2), 500, null);
                    f.style.display = "block"
                } else {
                    m.className = "draggable";
                    m.style.cursor = "move";
                    m.style.borderRadius = "8px";
                    m.style.border = "1px solid " + a.skinBorderColor;
                    k.src = a.imageDir + "pin.png";
                    k.alt = "Dock";
                    k.title = "Dock";
                    k.state = "free";
                    a.configuratorLastState = "free";
                    a.resizeMove(g, 0, 0, 0, 0, 500);
                    a.resizeViewport();
                    f.style.display = "none"
                }
                setTimeout(function () {
                    a.resizeViewportWest();
                    m.style.height = ""
                }, 500)
            }
            return false
        }
    }(this);
    this.clickAdvanced = function (a) {
        return function (d) {
            if (!d) {
                d = window.event
            }
            var b = a.$(a.target + "canvasXpressConfiguratorKey");
            var c = a.$(a.target + "canvasXpressConfiguratorKeyAdvanced");
            if (c) {
                if (a.showAdvancedConfiguration) {
                    a.showAdvancedConfiguration = false;
                    c.src = a.imageDir + "lightbulb_off.png";
                    c.alt = "Show advanced configuaration properties";
                    c.title = "Show advanced configuaration properties"
                } else {
                    a.showAdvancedConfiguration = true;
                    c.src = a.imageDir + "lightbulb.png";
                    c.alt = "Show basic configuaration properties";
                    c.title = "Show basic configuaration properties"
                }
                if (b && b.style.display == "none") {
                    b.value = "";
                    b.style.display = "block";
                    a.clickSearch()
                } else {
                    a.resetHelpEditOptionColorFilters();
                    a.resetEditPropertyDescription();
                    a.resetPropertySeeAlsoLinks();
                    a.selectConfig(false, true)
                }
            }
            return false
        }
    }(this);
    this.closeConfigurator = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.resetViewportOverflow("west");
            a.resetConfigurator();
            return false
        }
    }(this);
    this.changeCategory = function (a) {
        return function (I, F) {
            if (!I) {
                I = window.event
            }
            a.resetHelpEditOptionColorFilters();
            var E = a.$(a.target + "canvasXpressConfiguratorCategories");
            var A = a.$(a.target + "canvasXpressConfiguratorSugestionsText");
            var c = a.$(a.target + "canvasXpressConfiguratorSugestionsDiv");
            var y = a.$(a.target + "canvasXpressConfiguratorSugestions");
            var J = a.$(a.target + "canvasXpressConfiguratorSugestionsDescription");
            var t = a.$(a.target + "canvasXpressConfiguratorValueText");
            var L = a.$(a.target + "canvasXpressConfiguratorSeeAlso");
            var q = a.$(a.target + "canvasXpressConfiguratorValue");
            var f = a.$(a.target + "canvasXpressConfiguratorApply");
            var K = a.$(a.target + "canvasXpressConfiguratorButton");
            var g = a.$(a.target + "canvasXpressConfiguratorOptions");
            var l = a.$(a.target + "canvasXpressConfiguratorHelp");
            var D = a.$(a.target + "canvasXpressConfiguratorColor");
            var h = a.$(a.target + "canvasXpressConfiguratorFilter");
            var k = CanvasXpress.doc.M;
            if (E && E.value && A && c && y && J && t && L && q && K && g && l && D && h) {
                var B = a.showAdvancedConfiguration ? k[E.value].P.sort() : k[E.value].B.sort();
                a.resetSugestions();
                for (var G = 0; G < B.length; G++) {
                    var C = document.createElement("option");
                    C.text = B[G];
                    C.value = B[G];
                    try {
                        y.add(C, null)
                    } catch (H) {
                        y.add(C)
                    }
                }
                y.options[F || 0].selected = true;
                A.innerHTML = "Select property (" + B.length + ")";
                a.setConfiguratorPropertyValue(y, J, t, L, q);
                A.style.display = "block";
                c.style.display = "block";
                y.style.display = "block";
                J.style.display = "block";
                t.style.display = "block";
                L.style.display = "block";
                q.style.display = "block";
                f.style.display = "block";
                K.style.display = "block";
                g.style.display = "none";
                l.style.display = "none";
                D.style.display = "none";
                h.style.display = "none"
            }
            return false
        }
    }(this);
    this.resetCategories = function () {
        var a = this.$(this.target + "canvasXpressConfiguratorCategories");
        if (a) {
            if (a.hasChildNodes()) {
                while (a.childNodes.length >= 1) {
                    a.removeChild(a.firstChild)
                }
            }
            a.style.display = "none"
        }
    };
    this.mousedownSuggestionsDiv = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.registerSuggestionsDivResizer(b);
            return false
        }
    }(this);
    this.registerSuggestionsDivResizer = function (c) {
        if (!c) {
            c = window.event
        }
        var a = c.target || c.srcElement;
        if (a.id == this.target + "canvasXpressConfiguratorSugestionsDiv") {
            var b = this.$(this.target + "canvasXpressConfiguratorSugestions");
            if (a && b) {
                this.yMouseDown = c.clientY;
                this.resizingSuggestionsDivOn = a.clientHeight / b.size
            }
        }
    };
    this.updateSuggestionsDivResizer = function (d) {
        if (!d) {
            d = window.event
        }
        if (this.resizingSuggestionsDivOn) {
            var c = this.$(this.target + "canvasXpressConfiguratorSugestionsDiv");
            var a = this.$(this.target + "canvasXpressConfiguratorSugestions");
            if (a) {
                var b = parseInt((d.clientY - this.yMouseDown) / this.resizingSuggestionsDivOn);
                if (b != 0) {
                    a.size += b;
                    this.yMouseDown = d.clientY;
                    this.resizingSuggestionsDivOn = c.clientHeight / a.size
                }
            }
        }
    };
    this.endSuggestionsDivResizer = function (a) {
        if (this.resizingSuggestionsDivOn) {
            this.yMouseDown = null;
            this.resizingSuggestionsDivOn = false
        }
    };
    this.clickSuggestions = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.resetHelpEditOptionColorFilters();
            a.setConfiguratorPropertyValue();
            return false
        }
    }(this);
    this.setConfiguratorPropertyValue = function (l, e, j, g, h) {
        if (!l) {
            l = this.$(this.target + "canvasXpressConfiguratorSugestions")
        }
        if (!e) {
            e = this.$(this.target + "canvasXpressConfiguratorSugestionsDescription")
        }
        if (!j) {
            j = this.$(this.target + "canvasXpressConfiguratorValueText")
        }
        if (!g) {
            g = this.$(this.target + "canvasXpressConfiguratorSeeAlso")
        }
        if (!h) {
            h = this.$(this.target + "canvasXpressConfiguratorValue")
        }
        var k;
        var f = this.$(this.target + "canvasXpressConfiguratorOptions");
        var c = this.getConfigurableObjectDoc(l.value);
        h.value = "";
        h.style.readonly = false;
        if (this.configuringNetwork) {
            if (typeof (this[l.value]) == "function") {
                h.style.disabled = "disabled";
                h.style.readonly = false
            } else {
                if (this.configuringNetwork < this.data.nodes.length) {
                    k = this.data.nodes[this.configuringNetwork][l.value]
                } else {
                    k = this.data.edges[this.configuringNetwork - this.data.nodes.length][l.value]
                }
            }
        } else {
            if (this.configuringGenome) {
                var b = this.subtracksInfo;
                if (!isNaN(this.configuringGenome)) {
                    k = this.data.tracks[b[this.configuringGenome].track].data[b[this.configuringGenome].index][l.value]
                } else {
                    if (this.configuringGenome.match(/:/)) {
                        k = parseInt(this.configuringGenome.split(":")[1]);
                        k = this.data.tracks[b[k].track].data[b[k].index][l.value]
                    } else {
                        k = parseInt(this.configuringGenome.replace("track-", ""));
                        k = this.data.tracks[b[k].track][l.value]
                    }
                }
            } else {
                if (typeof (this[l.value]) == "function") {
                    j.innerHTML = "Current&nbsp;value&nbsp;[&nbsp;<i>function</i>&nbsp;]&nbsp;" + this[l.value].length + "&nbsp;parameter(s)";
                    if (this[l.value].length == 0) {
                        h.style.disabled = "disabled";
                        h.style.readonly = false
                    }
                } else {
                    k = this[l.value]
                }
            }
        }
        h.value = k ? JSON.stringify(k) : "";
        this.addPropertyDescription(e, c, l.value);
        this.addPropertySeeAlsoLinks(g, c);
        this.addPropertyOptions(j, f, c, l.value, k)
    };
    this.resetSugestions = function () {
        var b = this.$(this.target + "canvasXpressConfiguratorSugestionsDiv");
        var a = this.$(this.target + "canvasXpressConfiguratorSugestions");
        if (b && a) {
            if (a.hasChildNodes()) {
                while (a.childNodes.length >= 1) {
                    a.removeChild(a.firstChild)
                }
            }
            b.style.display = "none";
            a.style.display = "none"
        }
    };
    this.addPropertyDescription = function (l, g, f) {
        var n = g && g.C ? g.C : "";
        var h = g && g.M ? g.M : "";
        this.resetPropertyDescription(l);
        var k = document.createElement("img");
        k.id = this.target + "canvasXpressConfiguratorSugestionsDescriptionEdit";
        k.src = this.imageDir + "pencil.png";
        k.style.margin = "2px";
        k.style.width = "10px";
        k.style.height = "10px";
        k.alt = "Edit description";
        k.title = "Edit description";
        var a = document.createElement("i");
        a.innerHTML = f;
        var t = document.createElement("span");
        t.id = this.target + "canvasXpressConfiguratorSugestionsDescriptionEditSpan";
        t.innerHTML = " : " + n;
        var j = document.createElement("i");
        j.innerHTML = h;
        var r = document.createElement("b");
        r.appendChild(document.createTextNode("Description [ "));
        r.appendChild(j);
        r.appendChild(document.createTextNode(" ]"));
        l.appendChild(r);
        l.appendChild(document.createElement("br"));
        l.appendChild(a);
        l.appendChild(t);
        l.appendChild(k);
        this.addEvtListener(k, "click", this.clickEditPropertyDescription, false)
    };
    this.resetPropertyDescription = function (b, a) {
        if (!b) {
            b = this.$(this.target + "canvasXpressConfiguratorSugestionsDescription")
        }
        if (!a) {
            a = this.$(this.target + "canvasXpressConfiguratorSugestionsDescriptionEdit")
        }
        if (b && a) {
            this.removeEvtListener(a, "click", this.clickEditPropertyDescription, false);
            while (b.childNodes.length > 0) {
                var f = b.childNodes[0];
                b.removeChild(f)
            }
        }
    };
    this.clickEditPropertyDescription = function (a) {
        return function (h) {
            if (!h) {
                h = window.event
            }
            a.resetPropertyColor();
            a.resetPropertyFilter();
            var f = a.$(a.target + "canvasXpressConfigurator");
            var g = a.$(a.target + "canvasXpressConfiguratorSugestions");
            var u = a.$(a.target + "canvasXpressConfiguratorSugestionsDescriptionEditSpan");
            var m = a.$(a.target + "canvasXpressConfiguratorOptions");
            if (f && g && u && m) {
                m.style.display = "none";
                var t = a.adjustedCoordinates(h, g);
                if (t) {
                    a.editingDescriptionOn = true;
                    var r = t.x;
                    var o = t.y;
                    var j = document.createElement("div");
                    j.id = a.target + "canvasXpressConfiguratorEditForm";
                    j.className = "draggable";
                    j.style.cursor = "move";
                    j.style.left = r + "px";
                    j.style.top = o + "px";
                    j.style.padding = "10px";
                    j.style.color = a.skinColor;
                    j.style.border = "1px solid " + a.skinBorderColor;
                    j.style.backgroundColor = a.skinBackgroundColor;
                    j.style.boxShadow = "2px 2px 2px " + a.skinShadowColor;
                    j.style.MozBoxShadow = "2px 2px 2px " + a.skinShadowColor;
                    j.style.borderRadius = "8px";
                    j.style.position = "absolute";
                    j.style.fontWeight = "bold";
                    var l = document.createElement("img");
                    l.id = a.target + "canvasXpressConfiguratorEditFormClose";
                    l.style.cursor = "default";
                    l.src = a.imageDir + "cancel1.png";
                    l.alt = "Close";
                    l.title = "Close";
                    l.style.width = "13px";
                    l.style.height = "13px";
                    l.style.margin = "2px";
                    l.style.cssFloat = "right";
                    var q = document.createElement("textarea");
                    q.id = a.target + "canvasXpressConfiguratorEditFormValue";
                    q.style.cursor = "default";
                    q.style.margin = "5px";
                    q.cols = 30;
                    q.rows = 10;
                    q.value = u.innerHTML;
                    var n = document.createElement("input");
                    n.id = a.target + "canvasXpressConfiguratorEditFormButton";
                    n.value = "Submit";
                    n.type = "button";
                    n.style.cursor = "default";
                    n.style.margin = "5px";
                    n.style.width = "100%";
                    n.style.borderRadius = "4px";
                    n.style.MozBorderRadius = "4px";
                    j.appendChild(document.createTextNode("Editing " + g.value));
                    j.appendChild(l);
                    j.appendChild(document.createElement("br"));
                    j.appendChild(q);
                    j.appendChild(n);
                    a.addEvtListener(l, "click", a.closeEditPropertyDescription, false);
                    a.addEvtListener(n, "click", a.submitEditPropertyDescription, false);
                    f.appendChild(j)
                }
            }
        }
    }(this);
    this.submitEditPropertyDescription = function (a) {
        return function (f) {
            if (!f) {
                f = window.event
            }
            var c = a.$(a.target + "canvasXpressConfiguratorSugestions");
            var b = a.$(a.target + "canvasXpressConfiguratorEditFormValue");
            var d = a.$(a.target + "canvasXpressConfiguratorSugestionsDescriptionEditSpan");
            if (c && b && d) {
                b.value = b.value.replace(/\n/g, "");
                CanvasXpress.doc.P[c.value].C = b.value;
                d.innerHTML = b.value;
                alert("New description for:\n - " + c.value + " -\nwas submitted and may apppear\nin new versions of CanvasXpress\nThank you for your contribution")
            }
            a.resetEditPropertyDescription()
        }
    }(this);
    this.closeEditPropertyDescription = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.resetEditPropertyDescription()
        }
    }(this);
    this.resetEditPropertyDescription = function () {
        var e = this.$(this.target + "canvasXpressConfiguratorEditForm");
        var f = this.$(this.target + "canvasXpressConfiguratorEditFormClose");
        var a = this.$(this.target + "canvasXpressConfiguratorEditFormButton");
        if (e && f && a) {
            this.addEvtListener(f, "click", this.closeEditPropertyDescription, false);
            this.addEvtListener(a, "click", this.submitEditPropertyDescription, false);
            e.parentNode.removeChild(e)
        }
        this.editingDescriptionOn = false
    };
    this.addPropertySeeAlsoLinks = function (e, g) {
        this.resetPropertySeeAlsoLinks(e);
        var d = document.createElement("b");
        d.appendChild(document.createTextNode("See Also: "));
        e.appendChild(d);
        if (g && g.S) {
            for (var f = 0; f < g.S.length; f++) {
                var h = document.createElement("a");
                h.href = "javascript:void(0)";
                h.innerHTML = g.S[f];
                this.addEvtListener(h, "click", this.clickPropertySeeAlsoLinks, false);
                e.appendChild(h);
                if (f < g.S.length - 1) {
                    e.appendChild(document.createTextNode(", "))
                }
            }
        }
    };
    this.clickPropertySeeAlsoLinks = function (a) {
        return function (h) {
            if (!h) {
                h = window.event
            }
            var f = a.$(a.target + "canvasXpressConfiguratorKey");
            var b = a.$(a.target + "canvasXpressConfiguratorCategories");
            var g = a.$(a.target + "canvasXpressConfiguratorSugestions");
            var c = h.target || h.srcElement;
            if (b && b.style.display == "block") {
                var l = CanvasXpress.doc.P[c.innerHTML];
                var j = CanvasXpress.doc.M[l.M].P.sort();
                b.value = l.M;
                for (i = 0; i < j.length; i++) {
                    if (j[i] == c.innerHTML) {
                        a.changeCategory(h, i);
                        return false
                    }
                }
                a.changeCategory(h)
            } else {
                if (f) {
                    f.value = c.innerHTML;
                    a.selectConfig(h, true)
                }
            }
            return false
        }
    }(this);
    this.resetPropertySeeAlsoLinks = function (b) {
        if (!b) {
            b = this.$(this.target + "canvasXpressConfiguratorSeeAlso")
        }
        if (b && b.childNodes) {
            while (b.childNodes.length > 0) {
                var d = b.childNodes[0];
                if (d.nodeName.toLowerCase() == "a") {
                    this.removeEvtListener(d, "click", this.clickPropertySeeAlsoLinks, false)
                }
                b.removeChild(d)
            }
        }
    };
    this.addPropertyOptions = function (w, p, f, g, s) {
        this.resetPropertyOptions(w, p);
        var q = document.createElement("b");
        var l = document.createElement("i");
        q.appendChild(document.createTextNode("Current value"));
        if (f && f.T && (f.T == "option" || f.T == "array" || f.T == "boolean")) {
            var x = document.createElement("div");
            x.id = this.target + "canvasXpressConfiguratorOptionsContainer";
            x.style.height = "50px";
            x.style.overflow = "auto";
            x.style.cursor = "default";
            x.style.width = "180px";
            x.style.marginTop = "8px";
            x.style.fontWeight = "normal";
            var r = document.createElement("a");
            r.href = "javascript:void(0)";
            r.innerHTML = f.T;
            this.addEvtListener(r, "click", this.clickPropertyOptions, false);
            q.appendChild(document.createTextNode(" ["));
            l.appendChild(r);
            q.appendChild(document.createTextNode(" "));
            q.appendChild(l);
            q.appendChild(document.createTextNode(" ]"));
            if (f.T == "array") {
                var n = f.X ? this[f.X]() : f.O ? f.O : [];
                var m = this.getObjectArray(s);
                if (n.length > 0) {
                    for (var h = 0; h < n.length; h++) {
                        var g = document.createElement("input");
                        g.type = "checkbox";
                        g.value = n[h];
                        g.checked = m.hasOwnProperty(n[h]) ? true : false;
                        g.style.marginLeft = "0px";
                        this.addEvtListener(g, "change", this.updatePropertyValue, false);
                        x.appendChild(document.createTextNode((h + 1) + ". "));
                        x.appendChild(g);
                        x.appendChild(document.createTextNode(n[h]));
                        x.appendChild(document.createElement("br"))
                    }
                } else {
                    x.appendChild(document.createElement("br"));
                    x.appendChild(document.createTextNode("This array is user defined"));
                    x.appendChild(document.createElement("br"))
                }
            } else {
                var n = f.T == "boolean" ? ["true", "false"] : f.X ? this[f.X]() : f.O ? f.O : [];
                if (f.X && f.O) {
                    n = n.concat(f.O)
                }
                for (var h = 0; h < n.length; h++) {
                    var g = document.createElement("a");
                    g.href = "javascript:void(0)";
                    g.innerHTML = n[h];
                    g.style.padding = "2px";
                    this.addEvtListener(g, "click", this.updatePropertyValue, false);
                    x.appendChild(document.createTextNode((h + 1) + ". "));
                    x.appendChild(g);
                    x.appendChild(document.createElement("br"))
                }
            }
            p.appendChild(x)
        } else {
            if (f && f.T) {
                q.appendChild(document.createTextNode(" ["));
                if (f.T == "color") {
                    var n;
                    if (this.configuringNetwork) {
                        if (this.configuringNetwork < this.data.nodes.length) {
                            n = this.data.nodes[this.configuringNetwork][g]
                        } else {
                            n = this.data.edges[this.configuringNetwork - this.data.nodes.length][g]
                        }
                    } else {
                        if (this.configuringGenome) {
                            var e = this.subtracksInfo;
                            if (!isNaN(this.configuringGenome)) {
                                n = this.data.tracks[e[this.configuringGenome].track].data[e[this.configuringGenome].index]
                            } else {
                                if (this.configuringGenome.match(/:/)) {
                                    n = parseInt(this.configuringGenome.split(":")[1]);
                                    n = this.data.tracks[e[n].track].data[e[n].index]
                                } else {
                                    n = parseInt(this.configuringGenome.replace("track-", ""));
                                    n = this.data.tracks[e[n].track]
                                }
                            }
                        } else {
                            n = this[g]
                        }
                    }
                    var r = document.createElement("a");
                    r.id = this.target + "canvasXpressConfiguratorValueHREF";
                    r.href = "javascript:void(0)";
                    r.innerHTML = f.T;
                    r.style.color = n ? this.rgbToHex(this.validateColor(n)) : this.foreground;
                    this.addEvtListener(r, "click", this.addPropertyColor, false);
                    l.appendChild(r)
                } else {
                    if (f && f.T == "filter") {
                        var r = document.createElement("a");
                        r.id = this.target + "canvasXpressConfiguratorValueFilter";
                        r.href = "javascript:void(0)";
                        r.innerHTML = f.T;
                        r.name = g;
                        r.opts = f.X ? this[f.X]() : f.O ? f.O : [];
                        r.opts.unshift("");
                        this.addEvtListener(r, "click", this.addPropertyFilter, false);
                        l.appendChild(r)
                    } else {
                        l.appendChild(document.createTextNode(f.T))
                    }
                }
                q.appendChild(document.createTextNode(" "));
                q.appendChild(l);
                q.appendChild(document.createTextNode(" ]"))
            }
        }
        w.appendChild(q)
    };
    this.clickPropertyOptions = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.resetEditPropertyDescription();
            var c = a.$(a.target + "canvasXpressConfiguratorOptions");
            if (c) {
                c.style.display = "block";
                c.style.left = b.layerX + "px";
                c.style.top = b.layerY + "px"
            }
            return false
        }
    }(this);
    this.closePropertyOptions = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "canvasXpressConfiguratorOptions")
        }
    }(this);
    this.resetPropertyOptions = function (a, e, b) {
        if (!a) {
            a = this.$(this.target + "canvasXpressConfiguratorValueText")
        }
        if (!e) {
            e = this.$(this.target + "canvasXpressConfiguratorOptions")
        }
        if (a && a.childNodes && !b) {
            while (a.childNodes.length > 0) {
                var f = a.childNodes[0];
                if (f.nodeName.toLowerCase() == "a") {
                    this.removeEvtListener(f, "click", this.clickPropertyOptions, false)
                }
                a.removeChild(f)
            }
        }
        if (e) {
            var d = this.$(this.target + "canvasXpressConfiguratorOptionsContainer");
            if (d) {
                while (d.childNodes.length > 0) {
                    var f = d.childNodes[0];
                    if (f.nodeName.toLowerCase() == "a") {
                        this.removeEvtListener(f, "click", this.updatePropertyValue, false)
                    } else {
                        if (f.nodeName.toLowerCase() == "input" && f.type == "checkbox") {
                            this.removeEvtListener(f, "change", this.updatePropertyValue, false)
                        }
                    }
                    d.removeChild(f)
                }
                e.removeChild(d)
            }
            e.style.display = "none"
        }
    };
    this.addPropertyFilter = function (a) {
        return function (d) {
            if (!d) {
                d = window.event
            }
            a.resetEditPropertyDescription();
            var b = d.target || d.srcElement;
            var c = a.$(a.target + "canvasXpressConfiguratorFilter");
            a.addAllPropertyFilters(b.name, b.opts);
            c.style.display = "block";
            c.opts = b.opts;
            c.style.left = d.layerX + "px";
            c.style.top = d.layerY + "px"
        }
    }(this);
    this.addAllPropertyFilters = function (c, d) {
        var b = this.$(this.target + "canvasXpressConfiguratorFilter");
        for (var a = 0; a < this[c].length; a++) {
            this.insertPropertyFilterRow(b, a, c, d)
        }
        this.insertPropertyFilterRow(b, this[c].length, c, d)
    };
    this.insertPropertyFilterRow = function (F, B, r, y) {
        if (!F) {
            F = this.$(this.target + "canvasXpressConfiguratorFilter")
        }
        if (F) {
            var e = (this.configuratorWidth - 65) / 3;
            var G = document.createElement("div");
            G.id = this.target + "canvasXpressConfiguratorFilterContainer" + B;
            G.style.width = (this.configuratorWidth + 25) + "px";
            var q = document.createElement("select");
            q.id = this.target + "canvasXpressConfiguratorFilterSelect" + B;
            q.param = r;
            q.idx = B;
            q.style.marginRight = "2px";
            q.style.marginLeft = "1px";
            q.style.width = (e + 10) + "px";
            if (!y) {
                y = F.opts
            }
            y.sort();
            for (var A = 0; A < y.length; A++) {
                var d = document.createElement("option");
                d.text = y[A];
                d.value = y[A];
                try {
                    q.add(d, null)
                } catch (E) {
                    q.add(d)
                }
                if (this[r][B] && y[A] == this[r][B]) {
                    d.selected = true
                }
            }
            this.addEvtListener(q, "change", this.unsetPropertyFilterRow, false);
            var t = document.createElement("select");
            t.id = this.target + "canvasXpressConfiguratorFilterOp" + B;
            t.param = r;
            t.idx = B;
            t.style.marginRight = "2px";
            t.style.width = (e - 20) + "px";
            var x = this.getOperators();
            for (var A = 0; A < x.length; A++) {
                var d = document.createElement("option");
                d.text = x[A];
                d.value = x[A];
                try {
                    t.add(d, null)
                } catch (E) {
                    t.add(d)
                }
                if (this[r + "Op"][B] && x[A] == this[r + "Op"][B]) {
                    d.selected = true
                }
            }
            this.addEvtListener(t, "change", this.unsetPropertyFilterRow, false);
            var I = document.createElement("img");
            I.src = this.imageDir + "case_sensitive.png";
            I.style.width = "10px";
            var H = document.createElement("input");
            H.id = this.target + "canvasXpressConfiguratorFilterCase" + B;
            H.type = "checkbox";
            H.param = r;
            H.idx = B;
            H.style.width = "10px";
            H.alt = "Check for case sensitive";
            H.title = "Check for case sensitive";
            if (this[r + "Case"][B]) {
                H.checked = true
            }
            this.addEvtListener(H, "change", this.unsetPropertyFilterRow, false);
            var n = document.createElement("input");
            n.id = this.target + "canvasXpressConfiguratorFilterValue" + B;
            n.param = r;
            n.idx = B;
            n.type = "text";
            n.style.width = (e + 10) + "px";
            if (this[r + "Value"][B]) {
                n.value = this[r + "Value"][B]
            }
            this.addEvtListener(n, "change", this.unsetPropertyFilterRow, false);
            var u = document.createElement("img");
            u.id = this.target + "canvasXpressConfiguratorFilterMinus" + B;
            u.src = this.imageDir + "minus.png";
            u.alt = "Remove Filter";
            u.title = "Remove Filter";
            u.param = r;
            u.idx = B;
            u.style.marginRight = "2px";
            u.style.margin = "2px";
            u.style.marginTop = "5px";
            u.style.cssFloat = "left";
            u.style.cursor = "default";
            u.style.width = "10px";
            this.addEvtListener(u, "click", this.removePropertyFilterRow, false);
            var e = document.createElement("img");
            e.id = this.target + "canvasXpressConfiguratorFilterPlus" + B;
            e.src = this.imageDir + "add1.png";
            e.alt = "Set Filter";
            e.title = "Set Filter";
            e.param = r;
            e.idx = B;
            e.style.margin = "2px";
            e.style.marginTop = "3px";
            e.style.cssFloat = "right";
            e.style.cursor = "default";
            e.style.width = "10px";
            this.addEvtListener(e, "click", this.addPropertyFilterRow, false);
            var D = document.createElement("img");
            D.id = this.target + "canvasXpressConfiguratorFilterCheck" + B;
            D.src = this.imageDir + "accept.png";
            D.alt = "Filter added";
            D.title = "Filter added";
            D.style.margin = "2px";
            D.style.marginTop = "3px";
            D.style.cssFloat = "right";
            D.style.cursor = "default";
            D.style.width = "10px";
            D.style.display = this[r][B] ? "block" : "none";
            var C = document.createElement("div");
            C.id = this.target + "canvasXpressConfiguratorFilterCheckEmpty" + B;
            C.style.margin = "2px";
            C.style.marginTop = "3px";
            C.style.cssFloat = "right";
            C.style.cursor = "default";
            C.style.width = "10px";
            C.style.display = this[r][B] ? "none" : "block";
            G.appendChild(u);
            G.appendChild(q);
            G.appendChild(t);
            G.appendChild(I);
            G.appendChild(H);
            G.appendChild(n);
            G.appendChild(C);
            G.appendChild(D);
            G.appendChild(e);
            F.appendChild(G)
        }
    };
    this.addPropertyFilterRow = function (a) {
        return function (q) {
            if (!q) {
                q = window.event
            }
            var b = q.target || q.srcElement;
            var d = b.parentNode;
            var r = b.param;
            var l = b.idx;
            var t = a.$(a.target + "canvasXpressConfiguratorValue");
            var n = a.$(a.target + "canvasXpressConfiguratorFilterCheck" + l);
            var m = a.$(a.target + "canvasXpressConfiguratorFilterCheckEmpty" + l);
            if (d && r && l != null && t && n && m) {
                var j = d.childNodes[1].value;
                var f = d.childNodes[2].value;
                var s = d.childNodes[4].checked;
                var u = d.childNodes[5].value;
                if (j != "" && ((f != "" && u != "") || f.match("null"))) {
                    if (a[r].length > 0 && a[r][l] != null) {
                        a[r][l] = j;
                        a[r + "Op"][l] = f;
                        a[r + "Value"][l] = u;
                        a[r + "Case"][l] = s
                    } else {
                        a[r].push(j);
                        a[r + "Op"].push(f);
                        a[r + "Value"].push(u);
                        a[r + "Case"].push(s);
                        a.insertPropertyFilterRow(false, l + 1, r)
                    }
                    t.value = '["' + a[r].join('", "') + '"]';
                    n.style.display = "block";
                    m.style.display = "none"
                }
            }
        }
    }(this);
    this.removePropertyFilterRow = function (a) {
        return function (k) {
            if (!k) {
                k = window.event
            }
            var d = k.target || k.srcElement;
            var j = d.parentNode;
            var h = j.parentNode;
            var l = d.param;
            var f = d.idx;
            var b = a.$(a.target + "canvasXpressConfiguratorValue");
            if (j && l && f != null && b) {
                a.resetFilters(l, f);
                a.resetPropertyFilter(true);
                a.addAllPropertyFilters(l, h.opts);
                b.value = a[l].length > 0 ? '["' + a[l].join('", "') + '"]' : "[]"
            }
        }
    }(this);
    this.unsetPropertyFilterRow = function (a) {
        return function (m) {
            if (!m) {
                m = window.event
            }
            var p = [];
            var b = m.target || m.srcElement;
            var n = b.param;
            var f = b.idx;
            if (n && f != null) {
                if (a[n].length > 0 && a[n][f]) {
                    a[n][f] = false;
                    a[n + "Op"][f] = false;
                    a[n + "Value"][f] = false;
                    a[n + "Case"][f] = false;
                    for (var d = 0; d < a[n].length; d++) {
                        if (d != f) {
                            p.push(a[n][d])
                        }
                    }
                    var l = a.$(a.target + "canvasXpressConfiguratorFilterCheck" + f);
                    var k = a.$(a.target + "canvasXpressConfiguratorFilterCheckEmpty" + f);
                    var o = a.$(a.target + "canvasXpressConfiguratorValue");
                    if (l && k && o) {
                        l.style.display = "none";
                        k.style.display = "block";
                        o.value = p.length > 0 ? '["' + p.join('", "') + '"]' : "[]"
                    }
                }
            }
        }
    }(this);
    this.closePropertyFilter = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "canvasXpressConfiguratorFilter");
            a.resetPropertyFilter()
        }
    }(this);
    this.resetPropertyFilter = function (a) {
        var b = this.$(this.target + "canvasXpressConfiguratorFilter");
        if (b) {
            if (b && b.childNodes) {
                while (b.childNodes.length > 3) {
                    var c = b.childNodes[3];
                    this.removeEvtListener(c.childNodes[0], "click", this.removePropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[1], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[2], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[4], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[5], "change", this.unsetPropertyFilterRow, false);
                    this.removeEvtListener(c.childNodes[8], "click", this.addPropertyFilterRow, false);
                    b.removeChild(b.childNodes[3])
                }
            }
            if (!a) {
                b.style.display = "none"
            }
        }
    };
    this.addPropertyColor = function (a) {
        return function (j) {
            if (!j) {
                j = window.event
            }
            a.resetEditPropertyDescription();
            var d = a.$(a.target + "canvasXpressConfiguratorColor");
            var t = a.$(a.target + "canvasXpressConfiguratorValue");
            if (d && t) {
                var g = t.value ? a.rgbToHex(a.validateColor(t.value.replace(/[\'\"]/g, ""))) : a.foreground;
                a.colorRGBfromString(g);
                var r = Math.round(a.colorHSV[0] / 6 * 180);
                var q = Math.round((1 - a.colorHSV[1]) * 100);
                var m = Math.round((1 - a.colorHSV[2]) * 100);
                var l = document.createElement("div");
                l.id = a.target + "canvasXpressConfiguratorColorContainer";
                l.style.width = "210px";
                l.style.height = "101px";
                l.style.marginTop = "7px";
                var b = document.createElement("div");
                b.id = a.target + "canvasXpressConfiguratorColorPalette";
                b.style.position = "relative";
                b.style.left = "0px";
                b.style.top = "0px";
                b.style.width = "181px";
                b.style.height = "101px";
                b.style.backgroundImage = "url('" + a.imageDir + "color.png')";
                b.style.backgroundRepeat = "no-repeat";
                b.style.border = "1px solid " + a.skinBorderColor;
                b.style.cursor = "crosshair";
                var o = document.createElement("div");
                o.id = a.target + "canvasXpressConfiguratorColorPaletteCurrent";
                o.style.position = "relative";
                o.style.left = (r - 7) + "px";
                o.style.top = (q - 7) + "px";
                o.style.width = "195px";
                o.style.height = "115px";
                o.style.cursor = "crosshair";
                o.style.backgroundImage = "url('" + a.imageDir + "cross.gif')";
                o.style.backgroundRepeat = "no-repeat";
                b.appendChild(o);
                var w = document.createElement("div");
                w.id = a.target + "canvasXpressConfiguratorColorSaturation";
                w.style.position = "relative";
                w.style.left = "188px";
                w.style.top = "-102px";
                w.style.width = "15px";
                w.style.height = "100px";
                w.style.border = "1px solid " + a.skinBorderColor;
                w.style.cursor = "crosshair";
                for (var f = 0; f < 100; f += 4) {
                    var u = document.createElement("div");
                    u.style.height = "4px";
                    u.style.position = "relative";
                    u.style.left = "0px";
                    u.style.cursor = "crosshair";
                    w.appendChild(u)
                }
                var k = document.createElement("div");
                k.id = a.target + "canvasXpressConfiguratorColorSaturationCurrent";
                k.style.position = "relative";
                k.style.left = "0px";
                k.style.top = (m - 108) + "px";
                k.style.width = "29px";
                k.style.height = "115px";
                k.style.cursor = "crosshair";
                k.style.backgroundImage = "url('" + a.imageDir + "cross.gif')";
                k.style.backgroundRepeat = "no-repeat";
                k.style.overflow = "hidden";
                w.appendChild(k);
                l.appendChild(b);
                l.appendChild(w);
                d.appendChild(l);
                a.colorizeSaturationColorDiv();
                a.addEvtListener(b, "mousedown", a.registerPalette, false);
                a.addEvtListener(w, "mousedown", a.registerSaturation, false);
                d.style.display = "block";
                d.style.left = j.layerX + "px";
                d.style.top = j.layerY + "px"
            }
            return false
        }
    }(this);
    this.registerPalette = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.changingColorOn = "palette";
            if (a.colorHSV[2] == 0) {
                a.colorFromHsv(null, null, 1);
                var c = a.$(a.target + "canvasXpressConfiguratorColorSaturationCurrent");
                if (c) {
                    c.style.top = "-108px"
                }
            }
            a.updateColorValue(b);
            a.colorizeSaturationColorDiv();
            return false
        }
    }(this);
    this.registerSaturation = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.changingColorOn = "saturation";
            a.updateColorValue(b);
            return false
        }
    }(this);
    this.updateColorValue = function (g) {
        if (this.changingColorOn) {
            if (this.changingColorOn == "palette") {
                var f = this.$(this.target + "canvasXpressConfiguratorColorPalette");
                var b = this.$(this.target + "canvasXpressConfiguratorColorPaletteCurrent");
                if (f && b) {
                    var d = this.adjustedCoordinates(g, f);
                    if (d) {
                        var a = Math.min(Math.max(0, d.x), 181);
                        var j = Math.min(Math.max(0, d.y), 101);
                        b.style.left = (a - 7) + "px";
                        b.style.top = (j - 7) + "px";
                        this.colorFromHsv(a * 6 / 180, 1 - j / 100, null);
                        this.colorizeSaturationColorDiv()
                    }
                }
            } else {
                var c = this.$(this.target + "canvasXpressConfiguratorColorSaturation");
                var h = this.$(this.target + "canvasXpressConfiguratorColorSaturationCurrent");
                if (c && h) {
                    var d = this.adjustedCoordinates(g, c);
                    if (d) {
                        var j = Math.min(Math.max(0, d.y), 101);
                        h.style.top = (j - 108) + "px";
                        this.colorFromHsv(null, null, 1 - j / 100)
                    }
                }
            }
        }
    };
    this.colorFromHsv = function (c, b, a) {
        if (c != null) {
            this.colorHSV[0] = Math.min(Math.max(0, c), 6)
        }
        if (b != null) {
            this.colorHSV[1] = Math.min(Math.max(0, b), 1)
        }
        if (a != null) {
            this.colorHSV[2] = Math.min(Math.max(0, a), 1)
        }
        this.colorRGB = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], this.colorHSV[2]);
        this.colorizeCurrentColorDiv()
    };
    this.hsvFromRgb = function (e, d, b) {
        if (e == null) {
            return [b, b, b]
        }
        var c = Math.floor(e);
        var g = c % 2 ? e - c : 1 - (e - c);
        var a = b * (1 - d);
        var j = b * (1 - d * g);
        switch (c) {
            case 0:
                return [b, j, a];
            case 1:
                return [j, b, a];
            case 2:
                return [a, b, j];
            case 3:
                return [a, j, b];
            case 4:
                return [j, a, b];
            case 5:
                return [b, a, j];
            case 6:
        }
    };
    this.colorFromRgb = function (e, d, a) {
        if (e != null) {
            this.colorRGB[0] = Math.min(Math.max(0, e), 1)
        }
        if (d != null) {
            this.colorRGB[1] = Math.min(Math.max(0, d), 1)
        }
        if (a != null) {
            this.colorRGB[2] = Math.min(Math.max(0, a), 1)
        }
        var c = this.rgbFromHsv(this.colorRGB[0], this.colorRGB[1], this.colorRGB[2]);
        if (c[0] != null) {
            this.colorHSV[0] = c[0]
        }
        if (c[2] != 0) {
            this.colorHSV[1] = c[1]
        }
        this.colorHSV[2] = c[2];
        this.colorizeCurrentColorDiv()
    };
    this.rgbFromHsv = function (j, f, c) {
        var k = Math.min(Math.min(j, f), c);
        var d = Math.max(Math.max(j, f), c);
        var a = d - k;
        if (a == 0) {
            return [null, 0, d]
        } else {
            var e = j == k ? 3 + (c - f) / a : (f == k ? 5 + (j - c) / a : 1 + (f - j) / a);
            return [e == 6 ? 0 : e, a / d, d]
        }
    };
    this.colorRGBToString = function () {
        return (256 | Math.round(255 * this.colorRGB[0])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[1])).toString(16).substr(1) + (256 | Math.round(255 * this.colorRGB[2])).toString(16).substr(1)
    };
    this.colorRGBfromString = function (b) {
        var a = b.match(/^\W*([0-9A-F]{3}([0-9A-F]{3})?)\W*$/i);
        if (!a) {
            return false
        } else {
            if (a[1].length === 6) {
                this.colorFromRgb(parseInt(a[1].substr(0, 2), 16) / 255, parseInt(a[1].substr(2, 2), 16) / 255, parseInt(a[1].substr(4, 2), 16) / 255)
            } else {
                this.colorFromRgb(parseInt(a[1].charAt(0) + a[1].charAt(0), 16) / 255, parseInt(a[1].charAt(1) + a[1].charAt(1), 16) / 255, parseInt(a[1].charAt(2) + a[1].charAt(2), 16) / 255)
            }
            return true
        }
    };
    this.colorizeCurrentColorDiv = function () {
        var f = this.$(this.target + "canvasXpressConfiguratorColorCurrent");
        var a = this.$(this.target + "canvasXpressConfiguratorValue");
        var d = this.$(this.target + "canvasXpressConfiguratorValueHREF");
        if (f && a && d) {
            var e = this.colorRGBToString();
            var b = this.hexToRgb("#" + e);
            f.style.backgroundColor = "#" + e;
            f.innerHTML = "&nbsp;&nbsp;" + b;
            a.value = '"' + b + '"';
            d.style.color = "#" + e
        }
    };
    this.colorizeSaturationColorDiv = function () {
        var b = function (m, k, c, j, h) {
            return "rgb(" + (m * (1 - j / h) * 100) + "%," + (k * (1 - j / h) * 100) + "%," + (c * (1 - j / h) * 100) + "%)"
        };
        var e = this.$(this.target + "canvasXpressConfiguratorColorSaturation");
        if (e) {
            var f = e.childNodes;
            var a = this.hsvFromRgb(this.colorHSV[0], this.colorHSV[1], 1);
            for (var d = 0; d < f.length - 1; d++) {
                f[d].style.backgroundColor = b(a[0], a[1], a[2], d, f.length - 1)
            }
        }
    };
    this.endColorChange = function (a) {
        this.changingColorOn = false
    };
    this.closePropertyColor = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.handleHideDiv(a.target + "canvasXpressConfiguratorColor");
            a.resetPropertyColor()
        }
    }(this);
    this.resetPropertyColor = function () {
        var c = this.$(this.target + "canvasXpressConfiguratorColor");
        var b = this.$(this.target + "canvasXpressConfiguratorColorPalette");
        var a = this.$(this.target + "canvasXpressConfiguratorColorSaturation");
        if (c && b && a) {
            if (c && c.childNodes) {
                while (c.childNodes.length > 3) {
                    c.removeChild(c.childNodes[3])
                }
                this.removeEvtListener(b, "mousedown", this.registerPalette, false);
                this.removeEvtListener(a, "mousedown", this.registerSaturation, false)
            }
            c.style.display = "none"
        }
    };
    this.updatePropertyValue = function (a) {
        return function (h) {
            if (!h) {
                h = window.event
            }
            a.resetEditPropertyDescription();
            var f = a.$(a.target + "canvasXpressConfiguratorValue");
            var j = a.$(a.target + "canvasXpressConfiguratorOptions");
            var d = h.target || h.srcElement;
            if (d.nodeName.toLowerCase() == "input") {
                var b = [];
                for (var g = 0; g < d.parentNode.childNodes.length; g++) {
                    var k = d.parentNode.childNodes[g];
                    if (k.checked) {
                        b.push(k.value)
                    }
                }
                f.value = b.length > 0 ? '["' + b.join('", "') + '"]' : "[]"
            } else {
                if (f && j) {
                    if (d.innerHTML == "true") {
                        f.value = d.innerHTML
                    } else {
                        if (d.innerHTML == "false") {
                            f.value = d.innerHTML
                        } else {
                            if (d.innerHTML == "null") {
                                f.value = d.innerHTML
                            } else {
                                f.value = '"' + d.innerHTML + '"'
                            }
                        }
                    }
                    j.style.display = "none"
                }
            }
            return false
        }
    }(this);
    this.clickApplyConfigurator = function (a) {
        return function (b) {
            return a.clickConfigurator(b, false, false, true)
        }
    }(this);
    this.clickConfigurator = function (a) {
        return function (j, g, c, b) {
            if (!j) {
                j = window.event
            }
            if (!g) {
                g = a.$(a.target + "canvasXpressConfiguratorSugestions")
            }
            if (!c) {
                c = a.$(a.target + "canvasXpressConfiguratorValue")
            }
            if (g && c) {
                if (a.configuringNetwork) {
                    if (a.configuringNetwork < a.data.nodes.length) {
                        if (typeof (a[g.value]) == "function") {
                            a[g.value](a.data.nodes[a.configuringNetwork])
                        } else {
                            a.data.nodes[a.configuringNetwork][g.value] = JSON.parse(c.value)
                        }
                    } else {
                        if (typeof (a[g.value]) == "function") {
                            a[g.value](a.data.edges[a.configuringNetwork - a.data.nodes.length])
                        } else {
                            a.data.edges[a.configuringNetwork - a.data.nodes.length][g.value] = JSON.parse(c.value)
                        }
                    }
                } else {
                    if (a.configuringGenome) {
                        var d = a.subtracksInfo;
                        if (!isNaN(a.configuringGenome)) {
                            a.data.tracks[d[a.configuringGenome].track].data[d[a.configuringGenome].index][g.value] = JSON.parse(c.value)
                        } else {
                            if (a.configuringGenome.match(/:/)) {
                                var k = parseInt(a.configuringGenome.split(":")[1]);
                                a.data.tracks[d[k].track].data[d[k].index][g.value] = JSON.parse(c.value)
                            } else {
                                var k = parseInt(a.configuringGenome.replace("track-", ""));
                                a.data.tracks[k][g.value] = JSON.parse(c.value)
                            }
                        }
                    } else {
                        if (typeof (a[g.value]) == "function") {
                            if (a[g.value].length > 0 && c && c.value) {
                                var b = JSON.parse(c.value);
                                a[g.value](b)
                            } else {
                                a[g.value]()
                            }
                            a.resetConfigurator();
                            return false
                        } else {
                            a[g.value] = JSON.parse(c.value);
                            a.userConfig[g.value] = a[g.value]
                        }
                    }
                }
                if (!b) {
                    a.resetConfigurator()
                }
                var h = g.value.match(/filter(.+)By/);
                if (h) {
                    a.reset();
                    a.filterData()
                }
                a.draw()
            }
            return false
        }
    }(this);
    this.handleHideDiv = function (a) {
        var b = this.$(a);
        if (b) {
            b.style.display = "none"
        }
        return false
    };
    this.resetHelpOptionColorFilters = function () {
        this.closeHelp();
        this.resetPropertyOptions(false, false, true);
        this.resetPropertyColor();
        this.resetPropertyFilter()
    };
    this.resetHelpEditOptionColorFilters = function () {
        this.closeHelp();
        this.resetEditPropertyDescription();
        this.resetPropertyOptions(false, false, true);
        this.resetPropertyFilter()
    };
    this.resetConfigurator = function () {
        this.resetHelpEditOptionColorFilters();
        this.resetPropertyDescription();
        this.resetPropertySeeAlsoLinks();
        this.helpOn = false;
        this.editingDescriptionOn = false;
        this.configuratorLastState = false;
        this.configuringOn = false;
        this.configuringNetwork = false;
        this.configuringGenome = false;
        this.addRemoveConfiguratorListeners("removeEvtListener");
        this.removeTarget(this.target + "canvasXpressConfigurator")
    }
};
CanvasXpress.prototype.initAcknowlegments = function () {
    this.addAcknowledgementDiv = function () {
        if (this.$(this.target + "canvasXpressAcknowledgementDiv")) {
            this.setAcknowledgementVisibility();
            return
        }
        var f = document.createElement("div");
        f.id = this.target + "canvasXpressAcknowledgementDiv";
        f.style.display = this.acknowledgment ? "block" : "none";
        f.style.width = this.width + "px";
        f.style.cssFloat = "left";
        f.style.position = "relative";
        f.style.zIndex = 9999;
        this.setAcknowledgementPosition(f);
        var c = document.createElement("img");
        c.src = this.imageDir + this.acknowledgementIcon;
        c.style.margin = "2px";
        c.alt = "Graphs powered by canvasXpress";
        c.title = "Graphs powered by canvasXpress";
        c.style.cssFloat = "right";
        var b = document.createElement("a");
        b.href = "http://canvasxpress.org";
        b.target = "_blank";
        b.style.cssFloat = "right";
        b.appendChild(c);
        f.appendChild(b);
        var e = this.$("south-wrapper-" + this.target);
        if (e) {
            e.appendChild(f)
        }
    };
    this.resizeAcknowledgementDiv = function () {
        var b = this.$(this.target + "canvasXpressAcknowledgementDiv");
        if (b) {
            b.style.width = this.width + "px"
        }
    };
    this.setAcknowledgementVisibility = function () {
        var b = this.$(this.target + "canvasXpressAcknowledgementDiv");
        if (b) {
            b.style.display = this.acknowledgment ? "block" : "none";
            this.setAcknowledgementPosition(b)
        }
    };
    this.setAcknowledgementPosition = function (b) {
        if (b) {
            if (this.acknowledgementIconPosition == "inside") {
                b.style.top = this.citation ? (((this.citationFontSize * this.citationScaleFontFactor) + 36) * -1) + "px" : "-31px";
                b.style.right = "3px"
            } else {
                b.style.top = "0px";
                b.style.right = "0px"
            }
        }
    };
    this.addAcknowledgementDiv()
};
CanvasXpress.prototype.initCodeInfo = function () {
    this.addInfoCodeDiv = function () {
        if (this.$(this.target + "canvasXpressCode")) {
            return
        }
        var a = document.createElement("div");
        a.id = this.target + "canvasXpressInfoDiv";
        a.style.display = "none";
        a.style.fontFamily = "arial,tahoma,sans-serif";
        a.style.fontSize = "small";
        var e = document.createElement("div");
        e.id = this.target + "canvasXpressCode";
        e.style.display = "none";
        e.style.fontFamily = "arial,tahoma,sans-serif";
        e.style.fontSize = "small";
        var d = this.$("north-wrapper-" + this.target);
        var b = this.$("south-wrapper-" + this.target);
        if (d) {
            d.appendChild(a)
        }
        if (b) {
            b.appendChild(e)
        }
    };
    this.clearCodeDiv = function () {
        var d = this.$(this.target + "canvasXpressCode");
        if (d) {
            var b = d.childNodes;
            if (b) {
                for (var a = 0; a < b.length; a++) {
                    d.removeChild(b[a])
                }
            }
        }
        d.style.display = "none"
    };
    this.updateCodeDiv = function () {
        var f = this.$(this.target + "canvasXpressCode");
        var e = this.cloneObject(this.data);
        var b = this.codeType == "pretty" ? this.prettyJSON(e) : JSON.stringify(e);
        var d = this.codeType == "pretty" ? this.prettyJSON(this.userConfig) : JSON.stringify(this.userConfig);
        if (f) {
            this.clearCodeDiv();
            var e;
            var a = "";
            if (this.codeType == "tab") {
                e = document.createElement("span");
                a = this.target + "\t" + b + "\t" + d + "\n"
            } else {
                if (this.codeType == "compact") {
                    e = document.createElement("span");
                    a = 'new CanvasXpress("' + this.target + '", ' + b + ", " + d + ")\n"
                } else {
                    e = document.createElement("pre");
                    a = 'new CanvasXpress("' + this.target + '", ' + b + ", " + d + ")\n"
                }
            }
            e.style.clear = "both";
            e.innerHTML = a;
            f.appendChild(e);
            f.style.display = "block"
        }
    };
    this.updateInfoDiv = function (a) {
        var b = this.$(this.target + "canvasXpressInfoDiv");
        if (b && a) {
            b.innerHTML = a
        }
    };
    this.showDiv = function (a) {
        var b = this.$(this.target + "canvasXpress" + a);
        if (b) {
            b.style.display = "block"
        }
    };
    this.hideDiv = function (a) {
        var b = this.$(this.target + "canvasXpress" + a);
        if (b) {
            b.style.display = "none"
        }
    };
    this.showCodeDiv = function () {
        this.showDiv("Code")
    };
    this.hideCodeDiv = function () {
        this.hideDiv("Code")
    };
    this.showInfoDiv = function () {
        this.showDiv("InfoDiv")
    };
    this.hideInfoDiv = function () {
        this.hideDiv("InfoDiv")
    };
    this.initializeCodeInfo = function () {
        this.addInfoCodeDiv()
    };
    this.initializeCodeInfo()
};
CanvasXpress.prototype.initDataFilter = function () {
    this.addDataFilterDiv = function () {
        if (this.$(this.target + "canvasXpressDataFilter")) {
            return
        }
        var e = this.dataFilterLastX != null ? parseInt(this.dataFilterLastX) : -this.canvas.width * 0.5;
        var c = this.dataFilterLastY != null ? parseInt(this.dataFilterLastY) : this.canvas.height * 0.5;
        var n = this.graphType == "Genome" ? 40 : 61;
        this.dataFilterHeight = this.canvas.height - n;
        this.activeAccordion = null;
        var u = document.createElement("div");
        u.id = this.target + "canvasXpressDataFilter";
        u.className = this.applicationLook ? "fixed" : "draggable-container";
        u.style.fontFamily = "arial,tahoma,sans-serif";
        u.style.fontSize = "small";
        u.style.top = c + "px";
        u.style.left = e + "px";
        u.style.borderRadius = "8px 8px 0px 0px";
        u.style.position = "absolute";
        u.style.display = "none";
        u.style.zIndex = 10000;
        var i = document.createElement("div");
        i.id = this.target + "canvasXpressDataFilterToolbar";
        i.style.left = "0px";
        i.style.top = "0px";
        i.style.width = this.dataFilterWidth + "px";
        i.style.height = 19 + "px";
        i.style.position = "absolute";
        i.style.cursor = "move";
        i.style.background = this.skinBackgroundColor;
        i.style.borderRadius = "8px 8px 0px 0px";
        i.className = this.applicationLook ? "fixed" : "draggable";
        var j = document.createElement("b");
        j.style.cursor = "default";
        j.innerHTML = "Filters";
        j.style.top = "5px";
        j.style.left = "5px";
        j.style.position = "absolute";
        var b = document.createElement("img");
        b.id = this.target + "canvasXpressDataFilterKeyReset";
        b.src = this.imageDir + "funnel_cross.png";
        b.alt = "Reset filters";
        b.title = "Reset filters";
        b.style.cursor = "default";
        b.style.width = "13px";
        b.style.height = "13px";
        b.style.marginTop = "4px";
        b.style.marginRight = "4px";
        b.style.cssFloat = "right";
        var p = document.createElement("img");
        p.id = this.target + "canvasXpressDataFilterKeyDock";
        p.src = this.applicationLook ? this.imageDir + "unpin.png" : this.imageDir + "pin.png";
        p.alt = this.applicationLook ? "Undock" : "Dock";
        p.title = this.applicationLook ? "Undock" : "Dock";
        p.state = this.applicationLook ? "docked" : "free";
        p.style.display = this.dockable ? "block" : "none";
        p.style.cursor = "default";
        p.style.width = "13px";
        p.style.height = "13px";
        p.style.marginTop = "4px";
        p.style.marginRight = "4px";
        p.style.cssFloat = "right";
        var q = document.createElement("img");
        q.id = this.target + "canvasXpressDataFilterKeyClose";
        q.src = this.imageDir + "cancel1.png";
        q.alt = "Close";
        q.title = "Close";
        q.style.cursor = "default";
        q.style.width = "13px";
        q.style.height = "13px";
        q.style.marginTop = "4px";
        q.style.marginRight = "7px";
        q.style.cssFloat = "right";
        var v = document.createElement("div");
        v.id = this.target + "canvasXpressDataFilterContainer";
        v.style.left = "0px";
        v.style.top = "19px";
        v.style.width = this.dataFilterWidth + "px";
        v.style.background = this.background;
        v.style.position = "absolute";
        var h = document.createElement("div");
        h.id = this.target + "canvasXpressDataFilterVariableHeader";
        h.innerHTML = "&nbsp;Variables";
        h.className = "accordionHead";
        h.style.backgroundColor = this.skinBackgroundColor;
        h.style.backgroundImage = "url('" + this.imageDir + "tbottom.png')";
        h.style.backgroundRepeat = "no-repeat";
        h.style.backgroundPosition = this.dataFilterWidth - 20 + "px";
        h.style.border = "1px solid " + this.skinBorderColor;
        h.style.width = (this.dataFilterWidth - 2) + "px";
        h.style.display = this.graphType.match(/Genome|Network/) ? "none" : "block";
        var m = document.createElement("div");
        m.id = this.target + "canvasXpressDataFilterVariableContent";
        m.className = "accordionContent";
        m.style.border = "1px solid " + this.skinBorderColor;
        m.style.height = "0px";
        m.style.display = "none";
        var f = document.createElement("div");
        f.id = this.target + "canvasXpressDataFilterSampleHeader";
        f.innerHTML = "&nbsp;Samples";
        f.className = "accordionHead";
        f.style.backgroundColor = this.skinBackgroundColor;
        f.style.backgroundImage = "url('" + this.imageDir + "tbottom.png')";
        f.style.backgroundRepeat = "no-repeat";
        f.style.backgroundPosition = this.dataFilterWidth - 20 + "px";
        f.style.border = "1px solid " + this.skinBorderColor;
        f.style.width = (this.dataFilterWidth - 2) + "px";
        f.style.display = this.graphType.match(/Genome|Network/) ? "none" : "block";
        var l = document.createElement("div");
        l.id = this.target + "canvasXpressDataFilterSampleContent";
        l.className = "accordionContent";
        l.style.border = "1px solid " + this.skinBorderColor;
        l.style.height = "0px";
        l.style.display = "none";
        var r = document.createElement("div");
        r.id = this.target + "canvasXpressDataFilterNodeHeader";
        r.innerHTML = "&nbsp;Nodes";
        r.className = "accordionHead";
        r.style.backgroundColor = this.skinBackgroundColor;
        r.style.backgroundImage = "url('" + this.imageDir + "tbottom.png')";
        r.style.backgroundRepeat = "no-repeat";
        r.style.backgroundPosition = this.dataFilterWidth - 20 + "px";
        r.style.border = "1px solid " + this.skinBorderColor;
        r.style.width = (this.dataFilterWidth - 2) + "px";
        r.style.display = this.graphType == "Network" ? "block" : "none";
        var t = document.createElement("div");
        t.id = this.target + "canvasXpressDataFilterNodeContent";
        t.className = "accordionContent";
        t.style.border = "1px solid " + this.skinBorderColor;
        t.style.height = "0px";
        t.style.display = "none";
        var o = document.createElement("div");
        o.id = this.target + "canvasXpressDataFilterEdgeHeader";
        o.innerHTML = "&nbsp;Edges";
        o.className = "accordionHead";
        o.style.backgroundColor = this.skinBackgroundColor;
        o.style.backgroundImage = "url('" + this.imageDir + "tbottom.png')";
        o.style.backgroundRepeat = "no-repeat";
        o.style.backgroundPosition = this.dataFilterWidth - 20 + "px";
        o.style.border = "1px solid " + this.skinBorderColor;
        o.style.width = (this.dataFilterWidth - 2) + "px";
        o.style.display = this.graphType == "Network" ? "block" : "none";
        var s = document.createElement("div");
        s.id = this.target + "canvasXpressDataFilterEdgeContent";
        s.className = "accordionContent";
        s.style.border = "1px solid " + this.skinBorderColor;
        s.style.height = "0px";
        s.style.display = "none";
        var a = document.createElement("div");
        a.id = this.target + "canvasXpressDataFilterGenomeHeader";
        a.innerHTML = "&nbsp;Features";
        a.className = "accordionHead";
        a.style.backgroundColor = this.skinBackgroundColor;
        a.style.backgroundImage = "url('" + this.imageDir + "tbottom.png')";
        a.style.backgroundRepeat = "no-repeat";
        a.style.backgroundPosition = this.dataFilterWidth - 20 + "px";
        a.style.border = "1px solid " + this.skinBorderColor;
        a.style.width = (this.dataFilterWidth - 2) + "px";
        a.style.display = this.graphType == "Genome" ? "block" : "none";
        var g = document.createElement("div");
        g.id = this.target + "canvasXpressDataFilterGenomeContent";
        g.className = "accordionContent";
        g.style.border = "1px solid " + this.skinBorderColor;
        g.style.height = "0px";
        g.style.display = "none";
        i.appendChild(j);
        i.appendChild(q);
        i.appendChild(p);
        i.appendChild(b);
        v.appendChild(h);
        v.appendChild(m);
        v.appendChild(f);
        v.appendChild(l);
        v.appendChild(r);
        v.appendChild(t);
        v.appendChild(o);
        v.appendChild(s);
        v.appendChild(a);
        v.appendChild(g);
        u.appendChild(i);
        u.appendChild(v);
        var k = this.$("east-wrapper-" + this.target);
        if (k) {
            k.appendChild(u);
            this.addRemoveDataFilterListeners("addEvtListener")
        }
    };
    this.addRemoveDataFilterListeners = function (j) {
        var d = this.$(this.target + "canvasXpressDataFilterToolbar");
        var f = this.$(this.target + "canvasXpressDataFilterKeyReset");
        var a = this.$(this.target + "canvasXpressDataFilterKeyDock");
        var b = this.$(this.target + "canvasXpressDataFilterKeyClose");
        var g = this.$(this.target + "canvasXpressDataFilterVariableHeader");
        var h = this.$(this.target + "canvasXpressDataFilterSampleHeader");
        var c = this.$(this.target + "canvasXpressDataFilterNodeHeader");
        var e = this.$(this.target + "canvasXpressDataFilterEdgeHeader");
        var i = this.$(this.target + "canvasXpressDataFilterGenomeHeader");
        if (d && a && b && g && h && c && e && i) {
            this[j](d, "mousedown", this.registerMousemove, false);
            this[j](f, "click", this.resetDataFilter, false);
            this[j](a, "click", this.dockUndockDataFilter, false);
            this[j](b, "click", this.hideDataFilter, false);
            this[j](g, "click", this.activateAccordion, false);
            this[j](h, "click", this.activateAccordion, false);
            this[j](c, "click", this.activateAccordion, false);
            this[j](e, "click", this.activateAccordion, false);
            this[j](i, "click", this.activateAccordion, false)
        }
    };
    this.activateAccordion = function (a) {
        return function (f, b) {
            if (!f) {
                f = window.event
            }
            var d = a;
            if (!b) {
                b = f.target || f.srcElement
            }
            if (b) {
                b.style.backgroundImage = "url('" + a.imageDir + "ttop.png')";
                b.style.backgroundColor = "rgb(210,210,210)";
                var c = b.nextSibling;
                if (c) {
                    setTimeout(function () {
                        if (d.activeAccordion && c.id == d.activeAccordion.id) {
                            c = false
                        }
                        d.transitionAccordion(new Date().getTime(), 250, c, d.activeAccordion);
                        if (d.activeAccordion) {
                            var e = d.activeAccordion.previousSibling;
                            e.style.backgroundImage = "url('" + a.imageDir + "tbottom.png')";
                            e.style.backgroundColor = a.skinBackgroundColor
                        }
                        d.activeAccordion = c
                    }, 33)
                }
            }
            return false
        }
    }(this);
    this.resizeDataFilterForScroller = function (k) {
        var h = this.$(this.target + "canvasXpressDataFilter");
        var b = this.$(this.target + "canvasXpressDataFilterToolbar");
        var l = this.$(this.target + "canvasXpressDataFilterContainer");
        var f = this.$(this.target + "canvasXpressDataFilterVariableHeader");
        var g = this.$(this.target + "canvasXpressDataFilterSampleHeader");
        var a = this.$(this.target + "canvasXpressDataFilterNodeHeader");
        var e = this.$(this.target + "canvasXpressDataFilterEdgeHeader");
        var j = this.$(this.target + "canvasXpressDataFilterGenomeHeader");
        if (h && b && l && f && g && a && e && j) {
            this.dataFilterScroller = k ? true : false;
            var d = [h, b, l, f, g, a, e, j];
            for (var c = 0; c < d.length; c++) {
                if (k) {
                    d[c].style.width = (parseInt(d[c].style.width) + 18) + "px"
                } else {
                    d[c].style.width = (parseInt(d[c].style.width) - 18) + "px"
                }
            }
            for (var c = 3; c < d.length; c++) {
                if (k) {
                    d[c].style.backgroundPosition = (parseInt(d[c].style.backgroundPosition) + 18) + "px"
                } else {
                    d[c].style.backgroundPosition = (parseInt(d[c].style.backgroundPosition) - 18) + "px"
                }
            }
        }
    };
    this.moveDataFilter = function (i) {
        var p, g;
        var o = this.$(this.target + "canvasXpressDataFilter");
        var d = this.$(this.target + "canvasXpressDataFilterToolbar");
        var f = this.$(this.target + "canvasXpressDataFilterKeyDock");
        var a = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
        var e = this.$("north-container-" + this.target);
        var m = this.$("south-container-" + this.target);
        var b = this.$("west-container-" + this.target);
        var n = this.$("middle-container-" + this.target);
        var k = this.$("east-container-" + this.target);
        var c = this.$("east-handler-" + this.target);
        var l = this.$("east-wrapper-" + this.target);
        var j = this;
        if (o && d && f && e && m && b && n && k && c && l) {
            g = parseInt(e.clientHeight) + this.canvas.height + parseInt(m.clientHeight);
            if (f.state == "free" && !i) {
                o.style.borderRadius = "0px";
                d.style.borderRadius = "0px";
                d.className = "fixed";
                f.src = this.imageDir + "unpin.png";
                f.alt = "Undock";
                f.title = "Undock";
                f.state = "docked";
                this.dataFilterLastState = "docked";
                this.dataFilterLastX = o.style.left;
                this.dataFilterLastY = o.style.top;
                c.style.display = "block";
                var p = parseInt(b.style.width) + this.canvas.width + this.dataFilterWidth;
                if (a) {
                    this.resizeMove(a, 0, 0, Math.max(p + 7, parseInt(m.clientWidth)) + 48, g + 54)
                }
                this.resizeMove(n, 0, 0, p + 7, this.canvas.height);
                this.resizeMove(k, 0, 0, this.dataFilterWidth + 7, this.canvas.height);
                this.resizeMove(l, 0, 0, this.dataFilterWidth, this.canvas.height);
                this.resizeMove(o, 0, 0, this.dataFilterWidth, this.canvas.height)
            } else {
                o.style.borderRadius = "8px 8px 0px 0px";
                d.style.borderRadius = "8px 8px 0px 0px";
                d.className = "draggable";
                f.src = this.imageDir + "pin.png";
                f.alt = "Dock";
                f.title = "Dock";
                f.state = "free";
                this.dataFilterLastState = "free";
                if (i) {
                    delete(this.dataFilterLastState);
                    this.dataFilterLastX = null;
                    this.dataFilterLastY = null;
                    this.fade(o, 500, function () {
                        j.resetFade(o);
                        o.style.display = "none";
                        o.style.width = j.dataFilterWidth + "px";
                        o.style.height = j.canvas.height + "px"
                    })
                }
                c.style.display = "none";
                p = parseInt(b.style.width) + this.canvas.width;
                if (a) {
                    this.resizeMove(a, 0, 0, Math.max(p + 7, parseInt(m.clientWidth)) + 48, g + 54)
                }
                this.resizeMove(n, 0, 0, p + 7, this.canvas.height);
                this.resizeMove(k, 0, 0, 7, this.canvas.height);
                this.resizeMove(l, 0, 0, 0, this.canvas.height);
                if (!i) {
                    this.resizeMove(o, 0, 0, 0, this.canvas.height)
                }
            }
            if (a) {
                setTimeout(function () {
                    j.resizeExtContainer(Math.max(p + 7, parseInt(m.clientWidth)) + 48, g + 54)
                }, 500)
            }
        }
    };
    this.updateDataFilter = function () {
        var b = this;
        var a = function (k, i, l, g) {
            var j = {
                min: ">=",
                max: "<=",
                like: "like"
            };
            b[k].push(g);
            b[k + "Op"].push(j[l]);
            b[k + "Case"].push(false);
            if (l == "like") {
                b[k + "Value"].push("^" + b.toDoFilter[i][g][l].join("$|^") + "$")
            } else {
                b[k + "Value"].push(b.toDoFilter[i][g][l])
            }
        };
        if (this.filteringStringOn || this.filteringNumericOn) {
            this.resetFilters();
            var d = false;
            for (var f in this.toDoFilter) {
                for (var c in this.toDoFilter[f]) {
                    for (var e in this.toDoFilter[f][c]) {
                        if (f == "sample") {
                            a("filterSmpBy", f, e, c)
                        } else {
                            if (f == "variable") {
                                a("filterVarBy", f, e, c)
                            } else {
                                if (f == "node") {
                                    a("filterNodeBy", f, e, c)
                                } else {
                                    if (f == "edge") {
                                        a("filterEdgeBy", f, e, c)
                                    } else {
                                        if (f == "feature") {
                                            a("filterFeatureBy", f, e, c)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.reset();
            this.filterData();
            this.draw()
        }
    };
    this.showDataFilter = function (a) {
        return function (d) {
            if (!d) {
                d = window.event
            }
            var f = a.$(a.target + "canvasXpressDataFilter");
            if (f) {
                if (f.style.left == "0px" && f.style.top == "0px") {
                    var b = a.$("west-container-" + a.target);
                    var c = a.$("middle-container-" + a.target);
                    if (b && c) {
                        c.style.width = (parseInt(b.clientWidth) + a.canvas.width + a.dataFilterWidth + 7) + "px"
                    }
                }
                if (a.activeTarget) {
                    a.activeTarget.style.zIndex = 10000
                }
                a.activeTarget = f;
                f.style.display = "block";
                a.loadDataFilter();
                f.style.zIndex = 10001
            }
            return false
        }
    }(this);
    this.removeGenericDataFilterListenersOrReset = function (x) {
        var w = [];
        var u = [];
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Area":
            case "AreaLine":
            case "Dotplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Boxplot":
            case "Correlation":
            case "Pie":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
            case "Candlestick":
            case "Circular":
                var h = this.$(this.target + "canvasXpressDataFilterSampleContent");
                var k = this.$(this.target + "canvasXpressDataFilterVariableContent");
                if (h && k) {
                    w.push(h, k);
                    u.push(this.getSampleData(true));
                    u.push(this.getVariableData(true))
                }
                break;
            case "Venn":
                return;
            case "Network":
                var r = this.$(this.target + "canvasXpressDataFilterNodeContent");
                var n = this.$(this.target + "canvasXpressDataFilterEdgeContent");
                if (r && n) {
                    w.push(r, n);
                    u.push(this.getNodeData(true));
                    u.push(this.getEdgeData(true))
                }
                break;
            case "Genome":
                var f = this.$(this.target + "canvasXpressDataFilterGenomeContent");
                if (f) {
                    w.push(f);
                    u.push(this.getFeatureData(true))
                }
                break
        }
        for (var s = 0; s < u.length; s++) {
            var e = w[s];
            var l = u[s];
            var z = this.getKeys(l);
            z.sort();
            for (var p = 0; p < z.length; p++) {
                var y = l[z[p]]["t"];
                var v = z[p].replace(/\W/g, "_");
                if (y == "string") {
                    var a = this.$(this.target + ":" + v + ":canvasXpressDataFilterInput");
                    var o = this.$(this.target + ":" + v + ":canvasXpressDataFilterSelect");
                    if (o && a) {
                        if (x) {
                            a.value = "";
                            o.selectedIndex = 0
                        } else {
                            this.addRemoveNumericDataFilterListeners("removeEvtListener", o)
                        }
                    }
                } else {
                    var m = this.$(this.target + ":" + v + ":canvasXpressDataFilterMin");
                    var g = this.$(this.target + ":" + v + ":canvasXpressDataFilterMinLabel");
                    var b = this.$(this.target + ":" + v + ":canvasXpressDataFilterRange");
                    var q = this.$(this.target + ":" + v + ":canvasXpressDataFilterMax");
                    var t = this.$(this.target + ":" + v + ":canvasXpressDataFilterMaxLabel");
                    if (m && g && b && q && t) {
                        if (x) {
                            m.style.left = "0px";
                            g.innerHTML = this.bestFormatNumber(b.min, b.decis);
                            b.style.left = "0px";
                            b.style.width = (this.dataFilterWidth - 42) + "px";
                            q.style.left = "0px";
                            t.innerHTML = this.bestFormatNumber(b.max, b.decis)
                        } else {
                            this.addRemoveNumericDataFilterListeners("removeEvtListener", m, q)
                        }
                    }
                }
            }
        }
    };
    this.loadDataFilter = function () {
        if (!this.toDoFilter) {
            this.toDoFilter = {}
        }
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Area":
            case "AreaLine":
            case "Dotplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Boxplot":
            case "Correlation":
            case "Pie":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
            case "Candlestick":
            case "Circular":
                return this.loadDataFilterSmpVar();
            case "Venn":
                return;
            case "Network":
                return this.loadDataFilterNetwork();
            case "Genome":
                return this.loadDataFilterGenome()
        }
    };
    this.loadDataFilterGeneric = function (d, a, g) {
        var e = this.getKeys(g);
        e.sort();
        if (!a.loaded) {
            a.loaded = {}
        }
        for (var b = 0; b < e.length; b++) {
            var f = this.getKeys(g[e[b]]["o"]);
            var c = g[e[b]]["t"];
            if (c == "string") {
                if (!a.loaded[e[b]]) {
                    a.appendChild(this.createStringFilter(d, e[b], f));
                    a.loaded[e[b]] = true
                }
            } else {
                if (!a.loaded[e[b]]) {
                    a.appendChild(this.createNumericFilter(d, e[b], f));
                    a.loaded[e[b]] = true
                }
            }
        }
    };
    this.loadDataFilterSmpVar = function () {
        var b = this.$(this.target + "canvasXpressDataFilterSampleContent");
        var a = this.$(this.target + "canvasXpressDataFilterVariableContent");
        if (b && a) {
            this.loadDataFilterGeneric("sample", b, this.getSampleData(true));
            this.loadDataFilterGeneric("variable", a, this.getVariableData(true))
        }
    };
    this.loadDataFilterNetwork = function () {
        var b = this.$(this.target + "canvasXpressDataFilterNodeContent");
        var a = this.$(this.target + "canvasXpressDataFilterEdgeContent");
        if (b && a) {
            this.loadDataFilterGeneric("node", b, this.getNodeData(true));
            this.loadDataFilterGeneric("edge", a, this.getEdgeData(true))
        }
    };
    this.loadDataFilterGenome = function () {
        var a = this.$(this.target + "canvasXpressDataFilterGenomeContent");
        if (a) {
            this.loadDataFilterGeneric("feature", a, this.getFeatureData(true))
        }
    };
    this.createNumericFilter = function (u, h, q) {
        var i = function (d) {
            var b = 1000000;
            return (((d * b) - (parseInt(d) * b)) / b).toString().replace(/\./, "").length - 1
        };
        q.sort(function (e, d) {
            return e - d
        });
        var j = h.replace(/\W/g, "_");
        var m = document.createElement("div");
        m.id = this.target + ":" + j + ":canvasXpressDataFilterContainer";
        m.className = "hoverable";
        m.style.border = "1px solid " + this.skinBorderColor;
        m.style.margin = "2px";
        var g = document.createElement("div");
        g.innerHTML = h;
        g.style.width = (this.dataFilterWidth - 12) + "px";
        g.style.margin = "5px";
        var a = document.createElement("div");
        a.style.width = (this.dataFilterWidth - 12) + "px";
        a.style.height = "14px";
        a.style.margin = "2px";
        var w = document.createElement("div");
        w.id = this.target + ":" + j + ":canvasXpressDataFilterRange";
        w.min = parseFloat(q[0]);
        w.max = parseFloat(q[q.length - 1]);
        w.range = q[q.length - 1] - q[0];
        w.units = (q[q.length - 1] - q[0]) / (this.dataFilterWidth - 42);
        w.decis = i(q[q.length - 1] - q[0]);
        w.filter = u;
        w.uvalue = h;
        w.style.backgroundColor = this.skinBorderColor;
        w.style.height = "14px";
        w.style.zIndex = 10001;
        w.style.cssFloat = "left";
        w.style.position = "relative";
        w.style.left = "0px";
        w.style.width = (this.dataFilterWidth - 42) + "px";
        var f = document.createElement("div");
        f.id = this.target + ":" + j + ":canvasXpressDataFilterMinLabel";
        f.innerHTML = this.bestFormatNumber(q[0], w.decis);
        f.style.marginLeft = "2px";
        f.style.cssFloat = "left";
        var p = document.createElement("div");
        p.id = this.target + ":" + j + ":canvasXpressDataFilterMaxLabel";
        p.innerHTML = this.bestFormatNumber(q[q.length - 1], w.decis);
        p.style.marginRight = "2px";
        p.style.cssFloat = "right";
        var o = document.createElement("div");
        o.style.width = (this.dataFilterWidth - 14) + "px";
        o.style.border = "1px solid " + this.skinBorderColor;
        o.style.margin = "2px";
        o.style.height = "14px";
        o.style.clear = "both";
        var c = document.createElement("div");
        c.id = this.target + ":" + j + ":canvasXpressDataFilterMin";
        c.style.backgroundImage = "url('" + this.imageDir + "move_right.png')";
        c.style.backgroundRepeat = "no-repeat";
        c.style.height = "14px";
        c.style.width = "14px";
        c.style.zIndex = 10002;
        c.style.cssFloat = "left";
        c.style.position = "relative";
        c.style.left = "0px";
        var n = document.createElement("div");
        n.id = this.target + ":" + j + ":canvasXpressDataFilterMax";
        n.style.backgroundImage = "url('" + this.imageDir + "move_left.png')";
        n.style.backgroundRepeat = "no-repeat";
        n.style.position = "relative";
        n.style.height = "14px";
        n.style.width = "14px";
        n.style.zIndex = 10002;
        n.style.cssFloat = "left";
        n.style.position = "relative";
        n.style.left = "0px";
        a.appendChild(f);
        a.appendChild(p);
        o.appendChild(c);
        o.appendChild(w);
        o.appendChild(n);
        m.appendChild(g);
        m.appendChild(a);
        m.appendChild(o);
        this.addRemoveNumericDataFilterListeners("addEvtListener", c, n);
        return m
    };
    this.addRemoveNumericDataFilterListeners = function (c, b, a) {
        if (c && b && a) {
            this[c](b, "mousedown", this.mousedownNumericFilter, false);
            this[c](a, "mousedown", this.mousedownNumericFilter, false)
        }
    };
    this.mousedownNumericFilter = function (a) {
        return function (c) {
            if (!c) {
                c = window.event
            }
            var b = c.target || c.srcElement;
            if (b) {
                a.filteringNumericOn = b;
                a.xMouseDown = c.clientX;
                a.yMouseDown = c.clientY
            }
            return false
        }
    }(this);
    this.updateNumericFilter = function (m) {
        if (this.filteringNumericOn) {
            this.cancelEvent(m);
            var c = this.filteringNumericOn;
            var d, j, p, b, o, h;
            if (c.id.match(/canvasXpressDataFilterMin/)) {
                d = true;
                j = c.id;
                p = c.id.replace("canvasXpressDataFilterMin", "canvasXpressDataFilterMax");
                b = c.id.replace("canvasXpressDataFilterMin", "canvasXpressDataFilterRange");
                o = c.id.replace("canvasXpressDataFilterMin", "canvasXpressDataFilterMinLabel");
                h = c.id.replace("canvasXpressDataFilterMin", "canvasXpressDataFilterMaxLabel")
            } else {
                d = false;
                p = c.id;
                j = c.id.replace("canvasXpressDataFilterMax", "canvasXpressDataFilterMin");
                b = c.id.replace("canvasXpressDataFilterMax", "canvasXpressDataFilterRange");
                o = c.id.replace("canvasXpressDataFilterMax", "canvasXpressDataFilterMinLabel");
                h = c.id.replace("canvasXpressDataFilterMax", "canvasXpressDataFilterMaxLabel")
            }
            j = this.$(j);
            p = this.$(p);
            b = this.$(b);
            o = this.$(o);
            h = this.$(h);
            if (j && p && b && o && h) {
                var r = m.clientX - this.xMouseDown;
                var q = this.dataFilterWidth - 42;
                var n = d ? parseInt(b.style.width) - r : parseInt(b.style.width) + r;
                var i = parseInt(j.style.left) + r;
                var l = this.absoluteCoordinates(j);
                var a = this.absoluteCoordinates(p);
                if (d) {
                    if (i > 0 && n > 0) {
                        this.xMouseDown = m.clientX;
                        i = Math.max(0, Math.min(q, i));
                        n = Math.max(0, Math.min(q, n))
                    } else {
                        if (i > 0) {
                            i -= r;
                            n = (a.x - l.x) - 14
                        } else {
                            n += i;
                            i = 0
                        }
                    }
                    var f = Math.min((b.units * i) + b.min, parseFloat(h.innerHTML));
                    j.style.left = i + "px";
                    b.style.left = i + "px";
                    b.style.width = n + "px";
                    p.style.left = i + "px";
                    o.innerHTML = this.bestFormatNumber(f, b.decis)
                } else {
                    var f = Math.max(Math.min((b.units * (i + n)) + b.min, b.max), parseFloat(o.innerHTML));
                    if (i + n <= q && n >= 0) {
                        this.xMouseDown = m.clientX;
                        i = Math.max(0, Math.min(q, i));
                        n = Math.max(0, Math.min(q - i, n))
                    } else {
                        if (i + n > q) {
                            i -= r;
                            n = q - i
                        }
                    }
                    b.style.width = n + "px";
                    h.innerHTML = this.bestFormatNumber(f, b.decis)
                }
                var g = b.uvalue;
                var k = b.filter;
                if (o.innerHTML != b.min.toString() || h.innerHTML != b.max.toString()) {
                    if (!this.toDoFilter[k]) {
                        this.toDoFilter[k] = {}
                    }
                    if (!this.toDoFilter[k][g]) {
                        this.toDoFilter[k][g] = {}
                    }
                    if (o.innerHTML != b.min.toString()) {
                        this.toDoFilter[k][g]["min"] = parseFloat(o.innerHTML)
                    }
                    if (h.innerHTML != b.max.toString()) {
                        this.toDoFilter[k][g]["max"] = parseFloat(h.innerHTML)
                    }
                } else {
                    if (this.toDoFilter[k] && this.toDoFilter[k][g]) {
                        delete this.toDoFilter[k][g]
                    }
                }
                this.updateDataFilter()
            }
        }
        return false
    };
    this.endNumericFilter = function (a) {
        if (this.filteringNumericOn) {
            this.filteringNumericOn = false
        }
    };
    this.createStringFilter = function (u, f, q) {
        var m = f.replace(/\W/g, "_");
        var p = document.createElement("div");
        p.id = this.target + ":" + m + ":canvasXpressDataFilterContainer";
        p.className = "hoverable";
        p.style.border = "1px solid " + this.skinBorderColor;
        p.style.margin = "2px";
        var c = document.createElement("div");
        c.innerHTML = f;
        c.style.width = "98%";
        c.style.margin = "5px";
        var h = document.createElement("input");
        h.id = this.target + ":" + m + ":canvasXpressDataFilterInput";
        h.type = "text";
        h.style.cursor = "default";
        h.style.width = "98%";
        h.style.marginLeft = "3px";
        var w = document.createElement("select");
        w.id = this.target + ":" + m + ":canvasXpressDataFilterSelect";
        w.filter = u;
        w.uvalue = f;
        w.multiple = true;
        w.style.width = "98%";
        w.style.marginLeft = "3px";
        w.style.marginBottom = "3px";
        w.size = 5;
        var b = document.createElement("option");
        b.text = "(All) " + q.length + " values";
        b.value = "";
        b.selected = "selected";
        try {
            w.add(b, null)
        } catch (n) {
            w.add(b)
        }
        q.sort();
        for (var g = 0; g < q.length; g++) {
            b = document.createElement("option");
            var a = q[g].length > 30 ? q[g].substr(0, 30) + " ..." : q[g];
            b.text = a;
            b.value = q[g];
            try {
                w.add(b, null)
            } catch (n) {
                w.add(b)
            }
        }
        p.appendChild(c);
        p.appendChild(h);
        p.appendChild(w);
        this.addRemoveStringDataFilterListeners("addEvtListener", w);
        return p
    };
    this.addRemoveStringDataFilterListeners = function (a, b) {
        if (a && b) {
            this[a](b, "mousedown", this.registerStringFilter, false);
            this[a](b, "change", this.endStringFilter, false)
        }
    };
    this.registerStringFilter = function (a) {
        return function (d) {
            if (!d) {
                d = window.event
            }
            var b = d.target || d.srcElement;
            if (b) {
                var f = b.parentNode;
                if (f) {
                    var c = a.$(f.id.replace("canvasXpressDataFilterSelect", "canvasXpressDataFilterInput"));
                    if (c) {
                        c.value = ""
                    }
                    setTimeout(function () {
                        if (f) {
                            var g = f.uvalue;
                            var h = f.filter;
                            if (f[0].selected == true) {
                                for (var e = 1; e < f.length; e++) {
                                    f[e].selected = false
                                }
                            }
                            a.filteringStringOn = f;
                            a.loadStringSelectFilter(f, h, g)
                        }
                    }, 100)
                }
            }
            return false
        }
    }(this);
    this.updateStringSelectFilter = function (g) {
        if (g) {
            var d = this.$(g);
            if (d) {
                var a = this.$(g.replace("canvasXpressDataFilterInput", "canvasXpressDataFilterSelect"));
                var f = a.filter;
                var e = a.uvalue;
                if (a) {
                    if (d.value) {
                        var c = 0;
                        for (var b = 0; b < a.length; b++) {
                            if (a[b].value.toLowerCase().match(d.value.toLowerCase())) {
                                a[b].selected = true;
                                this.filteringStringOn = true;
                                c++
                            } else {
                                a[b].selected = false
                            }
                        }
                        if (this.filteringStringOn) {
                            if (c + 1 == a.length) {
                                a.selectedIndex = 0
                            }
                        }
                    } else {
                        a.selectedIndex = 0
                    }
                    this.loadStringSelectFilter(a, f, e)
                }
            }
        }
    };
    this.loadStringSelectFilter = function (a, d, c) {
        if (!a[0].selected) {
            if (!this.toDoFilter[d]) {
                this.toDoFilter[d] = {}
            }
            if (!this.toDoFilter[d][c]) {
                this.toDoFilter[d][c] = {
                    like: []
                }
            }
            this.toDoFilter[d][c]["like"] = [];
            for (var b = 1; b < a.length; b++) {
                if (a[b].selected) {
                    this.toDoFilter[d][c]["like"].push(a[b].value)
                }
            }
        } else {
            if (this.toDoFilter[d] && this.toDoFilter[d][c]) {
                delete this.toDoFilter[d][c]
            }
        }
        this.updateDataFilter()
    };
    this.endStringFilter = function (a) {
        return function (b) {
            if (this.filteringStringOn) {
                this.filteringStringOn = false
            }
        }
    }(this);
    this.hideDataFilter = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.moveDataFilter(true);
            return false
        }
    }(this);
    this.dockUndockDataFilter = function (a) {
        return function (c) {
            if (!c) {
                c = window.event
            }
            var b = a.$(a.target + "canvasXpressDataFilter");
            if (b) {
                a.moveDataFilter()
            }
            return false
        }
    }(this);
    this.resizeDataFilter = function () {
        var a = this.graphType == "Genome" ? 40 : 61;
        this.dataFilterHeight = this.canvas.height - a;
        if (this.activeAccordion) {
            this.activeAccordion.style.height = this.dataFilterHeight + "px"
        }
    };
    this.resetDataFilter = function (a) {
        return function (b) {
            a.resetFilters();
            a.toDoFilter = {};
            a.reset();
            a.removeGenericDataFilterListenersOrReset(true);
            a.draw();
            return false
        }
    }(this);
    this.initializeDataFilterEvents = function () {
        this.addDataFilterDiv()
    };
    this.initializeDataFilterEvents()
};
CanvasXpress.prototype.initDataTable = function () {
    this.addDataTableDiv = function (B, D) {
        if (this.$(this.target + "canvasXpressDataTable")) {
            return
        }
        var l = this;
        var K = function (n, d, b) {
            var o = d == 0 || b == 0 ? document.createElement("th") : document.createElement("td");
            o.id = l.target + "canvasXpressDataTableCell." + d + "." + b;
            if (!l.isIE) {
                o.style.width = l.colWidth + "px";
                o.style.height = l.rowHeight + "px"
            }
            if (d == 0 || b == 0) {
                o.style.backgroundColor = l.skinBackgroundColor
            }
            o.style.border = "1px solid " + l.skinBorderColor;
            n.appendChild(o)
        };
        if (!D) {
            this.setDataTableDimensions(B)
        }
        var z = 38;
        var e = 42;
        var k = this.dataTableLastX != null ? parseInt(this.dataTableLastX) : this.canvas.width * 0.1;
        var g = this.dataTableLastY != null ? parseInt(this.dataTableLastY) : -this.canvas.height * 0.9;
        this.dataTableLastScrollLeft = 0;
        this.dataTableLastScrollTop = 0;
        var I = document.createElement("div");
        I.id = this.target + "canvasXpressDataTable";
        I.style.fontFamily = "arial,tahoma,sans-serif";
        I.style.fontSize = "small";
        I.style.top = g + "px";
        I.style.left = k + "px";
        I.style.width = (this.dataTableColsWidth + z) + "px";
        I.style.height = (this.dataTableRowsHeight + e) + "px";
        I.style.minWidth = ((this.colWidth * 3) + z) + "px";
        I.style.minHeight = ((this.rowHeight * 3) + e) + "px";
        I.style.zIndex = 10000;
        I.style.overflow = "hidden";
        I.style.position = "absolute";
        I.style.display = "none";
        I.style.border = "1px solid " + this.skinBorderColor;
        I.style.background = this.skinBackgroundColor;
        I.style.borderRadius = "8px";
        I.style.clear = "both";
        I.className = "draggable-container";
        var h = document.createElement("div");
        h.id = this.target + "canvasXpressDataTableToolbar";
        h.style.left = "0px";
        h.style.top = "0px";
        h.style.width = (this.dataTableColsWidth + z) + "px";
        h.style.minWidth = ((this.colWidth * 3) + z) + "px";
        h.style.height = 19 + "px";
        h.style.position = "absolute";
        h.style.cursor = "move";
        h.style.background = this.skinBackgroundColor;
        h.style.borderRadius = "8px";
        h.className = "draggable";
        var f = document.createElement("img");
        f.id = this.target + "canvasXpressDataTableSaveImage";
        f.src = this.imageDir + "disk.png";
        f.style.width = "13px";
        f.style.height = "13px";
        f.style.left = "4px";
        f.style.top = "4px";
        f.style.cssFloat = "left";
        f.style.position = "relative";
        f.style.cursor = "default";
        var s = document.createElement("img");
        s.id = this.target + "canvasXpressDataTableIconifyImage";
        s.src = this.imageDir + "iconify_l.png";
        s.style.display = this.dockable ? "block" : "none";
        s.style.width = "13px";
        s.style.height = "13px";
        s.style.right = "4px";
        s.style.top = "4px";
        s.style.cssFloat = "right";
        s.style.position = "relative";
        s.style.cursor = "default";
        var p = document.createElement("img");
        p.id = this.target + "canvasXpressDataTableMinimizeImage";
        p.src = this.imageDir + "minimize_l.png";
        p.style.display = this.dockable ? "block" : "none";
        p.style.width = "13px";
        p.style.height = "13px";
        p.style.right = "4px";
        p.style.top = "4px";
        p.style.cssFloat = "right";
        p.style.position = "relative";
        p.style.cursor = "default";
        p.style.display = "none";
        var a = document.createElement("img");
        a.id = this.target + "canvasXpressDataTableMaximizeImage";
        a.src = this.imageDir + "maximize_l.png";
        a.style.display = this.dockable ? "block" : "none";
        a.style.width = "13px";
        a.style.height = "13px";
        a.style.right = "4px";
        a.style.top = "4px";
        a.style.cssFloat = "right";
        a.style.position = "relative";
        a.style.cursor = "default";
        var C = document.createElement("img");
        C.id = this.target + "canvasXpressDataTableCloseImage";
        C.src = this.imageDir + "close_l.png";
        C.style.width = "13px";
        C.style.height = "13px";
        C.style.right = "4px";
        C.style.top = "4px";
        C.style.cssFloat = "right";
        C.style.position = "relative";
        C.style.cursor = "default";
        var E = document.createElement("div");
        E.id = this.target + "canvasXpressDataTableContainer";
        E.style.left = "0px";
        E.style.top = "20px";
        E.style.width = (this.dataTableColsWidth + z) + "px";
        E.style.height = (this.dataTableRowsHeight + 24) + "px";
        E.style.minWidth = ((this.colWidth * 3) + z) + "px";
        E.style.minHeight = ((this.rowHeight * 3) + e) + "px";
        E.style.position = "absolute";
        E.style.display = "block";
        var A = document.createElement("div");
        A.id = this.target + "canvasXpressDataTableTable";
        A.style.left = "2px";
        A.style.top = "1px";
        A.style.width = this.dataTableColsWidth + "px";
        A.style.height = this.dataTableRowsHeight + "px";
        A.style.minWidth = (this.colWidth * 3) + "px";
        A.style.minHeight = (this.rowHeight * 3) + "px";
        A.style.position = "absolute";
        var x = document.createElement("div");
        x.id = this.target + "canvasXpressDataTableVer";
        x.style.overflow = "auto";
        x.style.right = "2px";
        x.style.top = "1px";
        x.style.width = "18px";
        x.style.height = this.dataTableRowsHeight + "px";
        x.style.position = "absolute";
        var c = document.createElement("img");
        c.id = this.target + "canvasXpressDataTableVerImage";
        c.src = this.getPixelImage();
        c.width = 1;
        c.height = this.dataTableTotalHeight;
        x.appendChild(c);
        var H = document.createElement("div");
        H.id = this.target + "canvasXpressDataTableHor";
        H.style.overflow = "auto";
        H.style.left = "20px";
        H.style.bottom = "4px";
        H.style.width = this.dataTableColsWidth + "px";
        H.style.height = "18px";
        H.style.position = "absolute";
        var v = document.createElement("img");
        v.id = this.target + "canvasXpressDataTableHorImage";
        v.src = this.getPixelImage();
        v.width = this.dataTableTotalWidth;
        v.height = 1;
        H.appendChild(v);
        var m = document.createElement("div");
        m.id = this.target + "canvasXpressDataTableResizer";
        m.style.right = "0px";
        m.style.bottom = "2px";
        m.style.width = "15px";
        m.style.height = "15px";
        m.style.position = "absolute";
        m.style.cursor = "se-resize";
        h.style.background = this.skinBackgroundColor;
        m.style.backgroundImage = "url('" + this.imageDir + "resize_w.png')";
        m.style.backgroundRepeat = "no-repeat";
        m.className = "resizable";
        var u = document.createElement("table");
        u.id = this.target + "canvasXpressTable";
        u.style.tableLayout = "fixed";
        u.style.border = "1px solid " + this.skinBorderColor;
        u.style.borderCollapse = "collapse";
        u.style.fontSize = "x-small";
        u.style.left = "18px";
        u.style.top = "0px";
        u.style.width = this.dataTableColsWidth + "px";
        u.style.height = this.dataTableRowsHeight + "px";
        u.style.minWidth = (this.colWidth * 3) + "px";
        u.style.minHeight = (this.rowHeight * 3) + "px";
        u.style.position = "absolute";
        u.style.background = "#fefefe";
        var J = document.createElement("tbody");
        for (var G = 0; G < this.maxRows; G++) {
            var y = document.createElement("tr");
            for (var F = 0; F < this.maxCols; F++) {
                K(y, G, F)
            }
            J.appendChild(y)
        }
        h.appendChild(f);
        h.appendChild(C);
        h.appendChild(a);
        h.appendChild(p);
        h.appendChild(s);
        u.appendChild(J);
        A.appendChild(u);
        E.appendChild(A);
        E.appendChild(x);
        E.appendChild(H);
        E.appendChild(m);
        I.appendChild(h);
        I.appendChild(E);
        var q = this.$("south-wrapper-" + this.target);
        if (q) {
            q.appendChild(I);
            this.addRemoveDataTableListeners("addEvtListener")
        }
    };
    this.fineAdjustDataTable = function () {
        var h = this.$(this.target + "canvasXpressDataTable");
        var j = this.$(this.target + "canvasXpressDataTableContainer");
        var g = this.$(this.target + "canvasXpressDataTableTable");
        var m = this.$(this.target + "canvasXpressTable");
        var l = this.$(this.target + "canvasXpressDataTableVer");
        var f = this.$(this.target + "canvasXpressDataTableVerImage");
        if (h && j && g && m && l && f) {
            var k = g.scrollHeight - g.clientHeight;
            var a = m.scrollWidth - m.clientWidth;
            if (k) {
                var b = this.dataTableRowsHeight + k;
                h.style.height = (b + 42) + "px";
                j.style.height = (b + 22) + "px";
                g.style.height = b + "px";
                m.style.height = b + "px";
                l.style.height = b + "px";
                f.height = this.dataTableTotalHeight + k
            }
            if (a) {}
        }
    };
    this.addRemoveDataTableListeners = function (d, f) {
        var g = this.$(this.target + "canvasXpressDataTableHor");
        var n = this.$(this.target + "canvasXpressDataTableVer");
        var p = this.$(this.target + "canvasXpressDataTableToolbar");
        var q = this.$(this.target + "canvasXpressDataTableSaveImage");
        var e = this.$(this.target + "canvasXpressDataTableIconifyImage");
        var b = this.$(this.target + "canvasXpressDataTableMinimizeImage");
        var l = this.$(this.target + "canvasXpressDataTableMaximizeImage");
        var k = this.$(this.target + "canvasXpressDataTableCloseImage");
        var a = this.$(this.target + "canvasXpressDataTableResizer");
        var j = 0;
        if (g) {
            this[d](g, "scroll", this.scrollTable, false)
        }
        if (n) {
            this[d](n, "scroll", this.scrollTable, false)
        }
        if (p) {
            this[d](p, "mousedown", this.registerMousemove, false)
        }
        if (q) {
            this[d](q, "click", this.saveTable, false)
        }
        if (e) {
            this[d](e, "click", this.dockTable, false)
        }
        if (b) {
            this[d](b, "click", this.minimizeTable, false)
        }
        if (l) {
            this[d](l, "click", this.maximizeTable, false)
        }
        if (k) {
            this[d](k, "click", this.hideTable, false)
        }
        if (a) {
            this[d](a, "mousedown", this.mousedownDataTableResizer, false)
        }
        if (f) {
            j = f[1]
        } else {
            j = this.maxCols
        }
        for (var o = 0; o < j; o++) {
            f = this.$(this.target + "canvasXpressDataTableCell.0." + o);
            if (f) {
                this[d](f, "mousemove", this.mousemoveDataTableHeader, false);
                this[d](f, "mousedown", this.mousedownDataTableHeader, false)
            }
        }
    };
    this.setDataTableDimensions = function (d, k) {
        var b = 0;
        var p = 0;
        var e = 0;
        var l = false;
        var j = function () {
            for (var a = 0; a < d.w.grps.length; a++) {
                e += d.w.grps[a].length
            }
            return e
        };
        if (!d) {
            d = this.data
        }
        var s = 0;
        if (d.x) {
            for (var h in d.x) {
                s++
            }
        }
        var m = 0;
        if (d.z) {
            for (var h in d.z) {
                m++
            }
        }
        var q = this.getAllNetworkAttributes(d);
        var u = this.getVennCompartments(d);
        var w = this.getDataTableDimensions();
        if (w[0] != this.maxRows || w[1] != this.maxCols) {
            this.initialMaxRows = this.maxRows;
            this.initialMaxCols = this.maxCols
        }
        if (this.graphType == "Network") {
            b = this.dataTableTransposed ? 1 + d[this.networkShowDataTable].length : 1 + q[1];
            p = this.dataTableTransposed ? 1 + q[1] : 1 + d[this.networkShowDataTable].length
        } else {
            if (this.graphType == "Genome") {
                b = 1;
                p = 1
            } else {
                if (this.graphType == "Venn") {
                    b = this.dataTableTransposed ? 1 + u[1] : 2;
                    p = this.dataTableTransposed ? 2 : 1 + u[1]
                } else {
                    if (this.graphType == "Correlation") {
                        b = this.correlationAxis == "samples" ? 1 + d.y.smps.length : 1 + d.y.vars.length;
                        p = b
                    } else {
                        if (this.graphType == "Candlestick") {
                            if (d.y) {
                                b = this.dataTableTransposed ? 1 + (d.y.smps.length * d.y.vars.length) : 6;
                                p = this.dataTableTransposed ? 6 : 1 + (d.y.smps.length * d.y.vars.length)
                            } else {
                                if (d.market) {
                                    b = this.dataTableTransposed ? 1 + (d.market.smps.length * d.market.vars.length) : 6;
                                    p = this.dataTableTransposed ? 6 : 1 + (d.market.smps.length * d.market.vars.length)
                                }
                            }
                        } else {
                            if (d.y && d.y.vars && d.y.smps) {
                                b = this.dataTableTransposed ? 1 + m + d.y.smps.length : 1 + s + d.y.vars.length;
                                p = this.dataTableTransposed ? 1 + s + d.y.vars.length : 1 + m + d.y.smps.length
                            } else {
                                if (d.w && d.w.vars && d.w.grps) {
                                    e = j();
                                    b = this.dataTableTransposed ? 1 + m + e : 1 + s + d.w.vars.length;
                                    p = this.dataTableTransposed ? 1 + s + d.w.vars.length : 1 + m + e
                                }
                            }
                        }
                    }
                }
            }
        }
        if (this.maxRows > b) {
            this.initialMaxRows = this.maxRows;
            this.maxRows = b
        }
        if (this.maxCols > p) {
            this.initialMaxCols = this.maxCols;
            this.maxCols = p
        }
        if (this.totalRows == null || this.totalCols == null) {
            this.totalRows = b;
            this.totalCols = p
        } else {
            if (k || b != this.totalRows || p != this.totalCols || w[0] != this.maxRows || w[1] != this.maxCols || w[2] != this.rowHeight || w[3] != this.colWidth) {
                this.totalRows = b;
                this.totalCols = p;
                l = true
            } else {
                this.totalRows = b;
                this.totalCols = p;
                if (this.showDataTable) {
                    this.hideUnhideDataTable()
                }
            }
        }
        this.dataTableTotalHeight = 0;
        for (var h = 0; h <= this.totalRows; h++) {
            this.dataTableTotalHeight += this.setDataTableRowHeight(h)
        }
        this.dataTableTotalWidth = 0;
        for (var h = 0; h <= this.totalCols; h++) {
            this.dataTableTotalWidth += this.setDataTableColumnWidth(h)
        }
        this.dataTableRowsHeight = this.setDataTableRowHeight(0);
        for (var h = this.startRow; h <= this.startRow + this.maxRows; h++) {
            this.dataTableRowsHeight += this.setDataTableRowHeight(h)
        }
        this.dataTableColsWidth = this.setDataTableColumnWidth(0);
        for (var h = this.startCol; h <= this.startCol + this.maxCols; h++) {
            this.dataTableColsWidth += this.setDataTableColumnWidth(h)
        }
        if (l) {
            this.resetDataTable(true, w)
        }
    };
    this.setDataTableColumnWidth = function (b, a) {
        if (!this.dataTableColumnWidth[b]) {
            this.dataTableColumnWidth[b] = this.colWidth
        } else {
            if (a) {
                this.dataTableColumnWidth[b] = Math.max(a, this.colWidth)
            }
        }
        return this.dataTableColumnWidth[b]
    };
    this.setDataTableRowHeight = function (a, b) {
        if (!this.dataTableRowHeight[a]) {
            this.dataTableRowHeight[a] = this.rowHeight
        } else {
            if (b) {
                this.dataTableRowHeight[a] = Math.max(b, this.rowHeight)
            }
        }
        return this.dataTableRowHeight[a]
    };
    this.getAllNetworkAttributes = function (g) {
        var b = {};
        var h = 0;
        var f = ["x", "y", "z"];
        if (g[this.networkShowDataTable]) {
            for (var d = 0; d < g[this.networkShowDataTable].length; d++) {
                for (var c in g[this.networkShowDataTable][d]) {
                    if (b.hasOwnProperty(c)) {
                        b[c]++
                    } else {
                        b[c] = 1;
                        h++
                    }
                }
            }
        }
        for (var d = 0; d < f.length; d++) {
            if (!b.hasOwnProperty(f[d])) {
                b[f[d]] = b.id;
                h++
            }
        }
        return [b, h]
    };
    this.getVennCompartments = function (c) {
        var b = {};
        var d = 0;
        if (c.venn && c.venn.data) {
            for (var a in c.venn.data) {
                b[a] = 1;
                d++
            }
        }
        return [b, d]
    };
    this.getDataTableDimensions = function () {
        var f = 0;
        var i = 0;
        var e = 0;
        var b = 0;
        var d = this.$(this.target + "canvasXpressDataTableTable");
        var g = this.$(this.target + "canvasXpressDataTableCell.0.0");
        if (d) {
            var a = d.childNodes[0].childNodes[0].rows;
            if (a) {
                f = a.length;
                i = a[0].cells.length;
                e = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.height) : 0;
                b = g && g.firstChild && g.firstChild.style ? parseInt(g.firstChild.style.width) : 0
            }
        }
        return [f, i, e, b]
    };
    this.resetDataTable = function (b, a) {
        this.addRemoveDataTableListeners("removeEvtListener", a);
        this.removeTarget(this.target + "canvasXpressDataTable");
        this.addDataTableDiv(false, b)
    };
    this.hideUnhideDataTable = function (a) {
        this.currentDataTableData = null;
        if (this.initialMaxRows) {
            this.maxRows = this.initialMaxRows
        }
        if (this.initialMaxCols) {
            this.maxCols = this.initialMaxCols
        }
        var b = this.$(this.target + "canvasXpressDataTable");
        if (b) {
            if (a == true) {
                b.style.display = "none"
            } else {
                b.style.display = "block"
            }
        }
    };
    this.scrollTable = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.resizeDataTable();
            return false
        }
    }(this);
    this.resizeDataTable = function (o, l) {
        var g = this.$(this.target + "canvasXpressDataTable");
        var m = this.$(this.target + "canvasXpressDataTableVer");
        var f = this.$(this.target + "canvasXpressDataTableHor");
        var k = this.$(this.target + "canvasXpressDataTableContainer");
        if (o) {
            if (k) {
                var n = 0;
                this.maxCols = 1;
                for (var e = this.startCol; e < this.totalCols; e++) {
                    n += this.dataTableColumnWidth[e];
                    if (parseInt(k.style.width) < n) {
                        break
                    } else {
                        this.maxCols++
                    }
                }
                if (parseInt(k.style.width) >= this.dataTableTotalWidth) {
                    this.maxCols = (this.totalCols - this.startCol) + 1
                }
                this.maxCols = Math.max(3, Math.min(this.maxCols, (this.totalCols - this.startCol) + 1));
                if (!l) {
                    var b = 0;
                    this.maxRows = 1;
                    for (var e = this.startRow; e < this.totalRows; e++) {
                        b += this.dataTableRowHeight[e];
                        if (parseInt(k.style.height) < b) {
                            break
                        } else {
                            this.maxRows++
                        }
                    }
                    if (parseInt(k.style.height) >= this.dataTableTotalHeight) {
                        this.totalRows = (this.totalRows - this.startRow) + 1
                    }
                    this.maxRows = Math.max(3, Math.min(this.maxRows, (this.totalRows - this.startRow) + 1))
                }
                this.dataTableLastX = g.style.left;
                this.dataTableLastY = g.style.top;
                this.updateDataTable(false, true);
                this.resizeViewportSouth()
            }
        } else {
            if (g && m && f) {
                var j = f.scrollLeft == 0 ? 1 : Math.ceil(f.scrollLeft * this.totalCols / this.dataTableTotalWidth) + 2;
                j = Math.max(1, Math.min(j, this.totalCols + 1 - this.maxCols));
                var a = m.scrollTop == 0 ? 1 : Math.ceil(m.scrollTop * this.totalRows / this.dataTableTotalHeight) + 2;
                a = Math.max(1, Math.min(a, this.totalRows + 1 - this.maxRows));
                if (j != this.startCol || a != this.startRow) {
                    this.startCol = j;
                    this.startRow = a;
                    this.updateDataTable()
                }
            }
        }
    };
    this.updateDataTable = function (x, D, E) {
        var h = 0;
        var b = 0;
        var w = 0;
        var q = 0;
        var F = [];
        var G = [];
        var u = [];
        var t = [];
        if (!x) {
            x = this.currentDataTableData ? this.currentDataTableData : this.data
        } else {
            if (this.isGroupedData) {
                var B = this.getVariableIndices(x.w.vars);
                var C = [];
                for (var A = 0; A < x.w.grps.length; A++) {
                    C = C.concat(x.w.grps[A])
                }
                this.isGroupedData = false;
                x = this.extractDataObject(C, B);
                this.isGroupedData = true
            }
        }
        if (!E) {
            this.setDataTableDimensions(x, D)
        }
        this.startRow--;
        this.startCol--;
        if (this.graphType == "Network") {
            var H = this.getAllNetworkAttributes(x);
            u.push("");
            t.push("cxb");
            if (this.dataTableTransposed) {
                for (var B in H[0]) {
                    if (b < this.maxCols && q >= this.startCol) {
                        u.push(B);
                        t.push("cxx");
                        b++
                    }
                    q++
                }
                F.push(u);
                G.push(t);
                for (var B = 0; B < x[this.networkShowDataTable].length; B++) {
                    if (h < this.maxRows && w >= this.startRow) {
                        b = 0;
                        q = 0;
                        u = [B + 1];
                        t = ["cxz"];
                        for (var A in H[0]) {
                            if (b < this.maxCols && q >= this.startCol) {
                                var p = x[this.networkShowDataTable][B][A];
                                u.push(p ? p : "");
                                t.push("cxy");
                                b++
                            }
                            q++
                        }
                        F.push(u);
                        G.push(t);
                        h++
                    }
                    w++
                }
            } else {
                for (var B = 0; B < x[this.networkShowDataTable].length; B++) {
                    if (b < this.maxCols && q >= this.startCol) {
                        u.push(B + 1);
                        t.push("cxz");
                        b++
                    }
                    q++
                }
                F.push(u);
                G.push(t);
                for (var B in H[0]) {
                    if (h < this.maxRows && w >= this.startRow) {
                        b = 0;
                        q = 0;
                        u = [B];
                        t = ["cxx"];
                        for (var A = 0; A < x[this.networkShowDataTable].length; A++) {
                            if (b < this.maxCols && q >= this.startCol) {
                                var p = x[this.networkShowDataTable][A][B];
                                u.push(p ? p : "");
                                t.push("cxy");
                                b++
                            }
                            q++
                        }
                        F.push(u);
                        G.push(t);
                        h++
                    }
                    w++
                }
            }
        } else {
            if (this.graphType == "Genome") {
                F = [
                    ["Not implemented"]
                ];
                G = [
                    ["cxb"]
                ]
            } else {
                if (this.graphType == "Venn") {
                    var p = this.getVennCompartments(x);
                    u.push("");
                    t.push("cxb");
                    if (this.dataTableTransposed) {
                        u.push("No");
                        t.push("cxz");
                        F.push(u);
                        G.push(t);
                        for (var B in p[0]) {
                            if (h < this.maxRows && w >= this.startRow) {
                                b = 0;
                                q = 0;
                                u = [B];
                                t = ["cxx"];
                                if (b < this.maxCols && q >= this.startCol) {
                                    u.push(x.venn.data[B]);
                                    t.push("cxy");
                                    b++
                                }
                                q++;
                                F.push(u);
                                G.push(t);
                                h++
                            }
                            w++
                        }
                    } else {
                        for (var B in p[0]) {
                            if (b < this.maxCols && q >= this.startCol) {
                                u.push(B);
                                t.push("cxx");
                                b++
                            }
                            q++
                        }
                        F.push(u);
                        G.push(t);
                        if (h < this.maxRows && w >= this.startRow) {
                            b = 0;
                            q = 0;
                            u = ["No"];
                            t = ["cxz"];
                            for (var B in p[0]) {
                                if (b < this.maxCols && q >= this.startCol) {
                                    u.push(x.venn.data[B]);
                                    t.push("cxy");
                                    b++
                                }
                                q++
                            }
                            F.push(u);
                            G.push(t)
                        }
                    }
                } else {
                    if (this.graphType == "Correlation") {
                        var n = this.correlationAxis == "samples" ? x.y.smps : x.y.vars;
                        var m = this.correlationAxis == "samples" ? "cxs" : "cxv";
                        u.push("");
                        t.push("cxb");
                        for (var B = 0; B < n.length; B++) {
                            if (b < this.maxCols && q >= this.startCol) {
                                u.push(n[B]);
                                t.push(m);
                                b++
                            }
                            q++
                        }
                        F.push(u);
                        G.push(t);
                        for (var B = 0; B < n.length; B++) {
                            if (h < this.maxRows && w >= this.startRow) {
                                b = 0;
                                q = 0;
                                u = [n[B]];
                                t = [m];
                                for (var A = 0; A < n.length; A++) {
                                    if (b < this.maxCols && q >= this.startCol) {
                                        if (x.y.cor) {
                                            u.push(x.y.cor[B][A])
                                        } else {
                                            u.push(B == A ? 1 : x.y.data)
                                        }
                                        t.push("cxy");
                                        b++
                                    }
                                    q++
                                }
                                F.push(u);
                                G.push(t);
                                h++
                            }
                            w++
                        }
                    } else {
                        if (this.graphType == "Candlestick") {
                            var H = ["open", "low", "high", "close", "volume"];
                            u.push("");
                            t.push("cxb");
                            if (this.dataTableTransposed) {
                                for (var B = 0; B < x.y.vars.length; B++) {
                                    for (var A = 0; A < H.length; A++) {
                                        if (b < this.maxCols && q >= this.startCol) {
                                            var y = x.y.vars.length > 1 ? x.y.vars[B] + ":" + H[A] : H[A];
                                            u.push(y);
                                            t.push("cxv");
                                            b++
                                        }
                                        q++
                                    }
                                }
                                F.push(u);
                                G.push(t);
                                for (var B = 0; B < x.y.smps.length; B++) {
                                    if (h < this.maxRows && w >= this.startRow) {
                                        b = 0;
                                        q = 0;
                                        u = [x.y.smps[B]];
                                        t = ["cxs"];
                                        for (var A = 0; A < x.y.vars.length; A++) {
                                            for (var z = 0; z < H.length; z++) {
                                                if (b < this.maxCols && q >= this.startCol) {
                                                    u.push(x.y[H[z]][A][B] != null ? x.y[H[z]][A][B] : x.y[H[z]][B]);
                                                    t.push("cxy");
                                                    b++
                                                }
                                                q++
                                            }
                                        }
                                        F.push(u);
                                        G.push(t);
                                        h++
                                    }
                                    w++
                                }
                            } else {
                                for (var B = 0; B < x.y.smps.length; B++) {
                                    if (b < this.maxCols && q >= this.startCol) {
                                        u.push(x.y.smps[B]);
                                        t.push("cxs");
                                        b++
                                    }
                                    q++
                                }
                                F.push(u);
                                G.push(t);
                                for (var B = 0; B < x.y.vars.length; B++) {
                                    for (var A = 0; A < H.length; A++) {
                                        if (h < this.maxRows && w >= this.startRow) {
                                            b = 0;
                                            q = 0;
                                            var y = x.y.vars.length > 1 ? x.y.vars[B] + ":" + H[A] : H[A];
                                            u = [y];
                                            t = ["cxv"];
                                            for (var z = 0; z < x.y.smps.length; z++) {
                                                if (b < this.maxCols && q >= this.startCol) {
                                                    u.push(x.y[H[A]][B][z] != null ? x.y[H[A]][B][z] : x.y[H[A]][z]);
                                                    t.push("cxy");
                                                    b++
                                                }
                                                q++
                                            }
                                            F.push(u);
                                            G.push(t);
                                            h++
                                        }
                                        w++
                                    }
                                }
                            }
                        } else {
                            if (x.y.vars && x.y.smps) {
                                u.push("");
                                t.push("cxb");
                                if (this.dataTableTransposed) {
                                    if (x.x) {
                                        for (var B in x.x) {
                                            if (b < this.maxCols && q >= this.startCol) {
                                                u.push(B);
                                                t.push("cxx");
                                                b++
                                            }
                                            q++
                                        }
                                    }
                                    for (var B = 0; B < x.y.vars.length; B++) {
                                        if (b < this.maxCols && q >= this.startCol) {
                                            u.push(x.y.vars[B]);
                                            t.push("cxv");
                                            b++
                                        }
                                        q++
                                    }
                                    F.push(u);
                                    G.push(t);
                                    if (x.z) {
                                        for (var B in x.z) {
                                            if (h < this.maxRows && w >= this.startRow) {
                                                b = 0;
                                                q = 0;
                                                u = [B];
                                                t = ["cxz"];
                                                if (x.x) {
                                                    for (var A in x.x) {
                                                        if (b < this.maxCols && q >= this.startCol) {
                                                            u.push("");
                                                            t.push("cxb");
                                                            b++
                                                        }
                                                        q++
                                                    }
                                                }
                                                for (var A = 0; A < x.y.vars.length; A++) {
                                                    if (b < this.maxCols && q >= this.startCol) {
                                                        u.push(x.z[B][A]);
                                                        t.push("cxz");
                                                        b++
                                                    }
                                                    q++
                                                }
                                                F.push(u);
                                                G.push(t);
                                                h++
                                            }
                                            w++
                                        }
                                    }
                                    for (var B = 0; B < x.y.smps.length; B++) {
                                        if (h < this.maxRows && w >= this.startRow) {
                                            b = 0;
                                            q = 0;
                                            u = [x.y.smps[B]];
                                            t = ["cxs"];
                                            if (x.x) {
                                                for (var A in x.x) {
                                                    if (b < this.maxCols && q >= this.startCol) {
                                                        u.push(x.x[A][B]);
                                                        t.push("cxx");
                                                        b++
                                                    }
                                                    q++
                                                }
                                            }
                                            for (var A = 0; A < x.y.vars.length; A++) {
                                                if (b < this.maxCols && q >= this.startCol) {
                                                    u.push(x.y.data[A][B] != null ? x.y.data[A][B] : x.y.data[B]);
                                                    t.push("cxy");
                                                    b++
                                                }
                                                q++
                                            }
                                            F.push(u);
                                            G.push(t);
                                            h++
                                        }
                                        w++
                                    }
                                } else {
                                    if (x.z) {
                                        for (var B in x.z) {
                                            if (b < this.maxCols && q >= this.startCol) {
                                                u.push(B);
                                                t.push("cxz");
                                                b++
                                            }
                                            q++
                                        }
                                    }
                                    for (var B = 0; B < x.y.smps.length; B++) {
                                        if (b < this.maxCols && q >= this.startCol) {
                                            u.push(x.y.smps[B]);
                                            t.push("cxs");
                                            b++
                                        }
                                        q++
                                    }
                                    F.push(u);
                                    G.push(t);
                                    if (x.x) {
                                        for (var B in x.x) {
                                            if (h < this.maxRows && w >= this.startRow) {
                                                b = 0;
                                                q = 0;
                                                u = [B];
                                                t = ["cxx"];
                                                if (x.z) {
                                                    for (var A in x.z) {
                                                        if (b < this.maxCols && q >= this.startCol) {
                                                            u.push("");
                                                            t.push("cxb");
                                                            b++
                                                        }
                                                        q++
                                                    }
                                                }
                                                for (var A = 0; A < x.y.smps.length; A++) {
                                                    if (b < this.maxCols && q >= this.startCol) {
                                                        u.push(x.x[B][A]);
                                                        t.push("cxx");
                                                        b++
                                                    }
                                                    q++
                                                }
                                                F.push(u);
                                                G.push(t);
                                                h++
                                            }
                                            w++
                                        }
                                    }
                                    for (var B = 0; B < x.y.vars.length; B++) {
                                        if (h < this.maxRows && w >= this.startRow) {
                                            b = 0;
                                            q = 0;
                                            u = [x.y.vars[B]];
                                            t = ["cxv"];
                                            if (x.z) {
                                                for (var A in x.z) {
                                                    if (b < this.maxCols && q >= this.startCol) {
                                                        u.push(x.z[A][B]);
                                                        t.push("cxz");
                                                        b++
                                                    }
                                                    q++
                                                }
                                            }
                                            for (var A = 0; A < x.y.smps.length; A++) {
                                                if (b < this.maxCols && q >= this.startCol) {
                                                    u.push(x.y.data[B][A] != null ? x.y.data[B][A] : x.y.data[A]);
                                                    t.push("cxy");
                                                    b++
                                                }
                                                q++
                                            }
                                            F.push(u);
                                            G.push(t);
                                            h++
                                        }
                                        w++
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        this.startRow++;
        this.startCol++;
        if (E) {
            return F
        } else {
            this.loadDataTableValues(F, G, x)
        }
    };
    this.loadDataTableValues = function (m, n, a) {
        var q = this.$(this.target + "canvasXpressDataTable");
        if (q) {
            var p = this.startRow;
            for (var g = 0; g < m.length; g++) {
                var k = this.startCol;
                for (var f = 0; f < m[g].length; f++) {
                    var l = this.$(this.target + "canvasXpressDataTableCell." + g + "." + f);
                    if (l) {
                        if (l.hasChildNodes()) {
                            while (l.childNodes.length >= 1) {
                                l.removeChild(l.firstChild)
                            }
                        }
                        var b = document.createElement("div");
                        b.className = "cxc";
                        if (g != 0) {
                            b.style.height = this.setDataTableRowHeight(p) + "px";
                            l.style.height = this.setDataTableRowHeight(p) + "px"
                        } else {
                            b.style.height = this.setDataTableRowHeight(0) + "px";
                            l.style.height = this.setDataTableRowHeight(0) + "px"
                        }
                        if (f != 0) {
                            b.style.width = this.setDataTableColumnWidth(k) + "px";
                            l.style.width = this.setDataTableColumnWidth(k) + "px"
                        } else {
                            b.style.width = this.setDataTableColumnWidth(0) + "px";
                            l.style.width = this.setDataTableColumnWidth(0) + "px"
                        }
                        b.appendChild(document.createTextNode(m[g][f]));
                        l.appendChild(b);
                        l.className = n[g][f];
                        l.title = m[g][f];
                        l.alt = m[g][f];
                        k++
                    }
                }
                p++
            }
            if (this.activeTarget) {
                this.activeTarget.style.zIndex = 10000
            }
            this.activeTarget = q;
            q.style.display = "block";
            q.style.zIndex = 10001;
            this.currentDataTableData = a;
            this.fineAdjustDataTable();
            if (this.dataTableLastState && this.dataTableLastState == "docked") {
                var h = this.$("south-handler-" + this.target);
                if (h) {
                    if (h.state == "closed") {
                        this.clickViewport(false, h)
                    } else {
                        return
                    }
                }
            }
        }
    };
    this.saveTable = function (a) {
        return function (g) {
            if (!g) {
                g = window.event
            }
            var b = a.maxCols;
            var f = a.maxRows;
            var c = a.startCol;
            var i = a.startRow;
            a.maxCols = a.totalCols;
            a.maxRows = a.totalRows;
            a.startCol = 1;
            a.startRow = 1;
            var h = a.updateDataTable(false, false, true);
            a.exportToExcel(h);
            a.maxCols = b;
            a.maxRows = f;
            a.startCol = c;
            a.startRow = i;
            return false
        }
    }(this);
    this.dockTable = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.moveDataTableDiv("dock");
            return false
        }
    }(this);
    this.moveDataTableDiv = function (e) {
        var m = this.$(this.target + "canvasXpressDataTable");
        if (m) {
            var o, q, i;
            var b = this.$(this.remoteParentId + "-canvasXpressRemoteWindow");
            var a = this.$("west-handler-" + this.target);
            var f = this.$("north-container-" + this.target);
            var c = this.$("west-container-" + this.target);
            var k = this.$("east-container-" + this.target);
            var n = this.$("south-container-" + this.target);
            var g = this.$("south-handler-" + this.target);
            var p = this.$("south-wrapper-" + this.target);
            var j = this;
            if (a && c && k && n && g && p) {
                if (e && e == "dock") {
                    this.dataTableLastState = "docked";
                    this.dataTableLastHeight = m.style.height;
                    this.dataTableLastX = m.style.left;
                    this.dataTableLastY = m.style.top;
                    m.style.borderRadius = "0px";
                    g.style.display = "block";
                    o = a && a.style.display == "none" ? 7 : 0;
                    q = Math.max(parseInt(m.style.width) + 2 + o, parseInt(c.style.width) + parseInt(k.style.width) + this.canvas.width);
                    i = parseInt(f.style.height) + this.canvas.height + parseInt(m.style.height) + 7 + 2;
                    if (b) {
                        this.resizeMove(b, 0, 0, q + 48, i + 54)
                    }
                    this.resizeMove(n, 0, 0, q, parseInt(m.style.height) + 7 + 2);
                    this.resizeMove(p, 0, 0, q, parseInt(m.style.height) + 2);
                    this.resizeMove(m, o, 0, parseInt(m.style.width), parseInt(m.style.height))
                } else {
                    if (e && e == "hide") {
                        delete(this.dataTableLastState);
                        delete(this.dataTableLastX);
                        delete(this.dataTableLastY);
                        g.style.display = "none";
                        q = parseInt(c.style.width) + parseInt(k.style.width) + this.canvas.width;
                        i = parseInt(f.style.height) + this.canvas.height + 7;
                        if (b) {
                            this.resizeMove(b, 0, 0, q + 48, i + 54)
                        }
                        this.fade(m);
                        this.resizeMove(p, 0, 0, q, 0);
                        this.resizeMove(n, 0, 0, q, 7)
                    } else {
                        if (e && e == "min") {
                            return
                        } else {
                            if (e && (e == "max" || e == "release")) {
                                this.dataTableLastState = "free";
                                m.style.borderRadius = "8px";
                                g.style.display = "none";
                                q = parseInt(c.style.width) + parseInt(k.style.width) + this.canvas.width;
                                i = parseInt(f.style.height) + this.canvas.height + 7;
                                if (b) {
                                    this.resizeMove(b, 0, 0, q + 48, i + 54)
                                }
                                if (e == "max") {
                                    this.resizeMove(m, parseInt(this.dataTableLastX), parseInt(this.dataTableLastY), parseInt(m.style.width), parseInt(this.dataTableLastHeight) || (this.dataTableRowsHeight + 42))
                                }
                                this.resizeMove(p, 0, 0, q, 0);
                                this.resizeMove(n, 0, 0, q, 7)
                            } else {
                                this.dataTableLastX = m.style.left;
                                this.dataTableLastY = m.style.top;
                                return
                            }
                        }
                    }
                }
                if (b) {
                    setTimeout(function () {
                        j.resizeExtContainer(q + 48, i + 54)
                    }, 500)
                }
            }
        }
    };
    this.minimizeTable = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.moveDataTableDiv("min");
            return false
        }
    }(this);
    this.maximizeTable = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.moveDataTableDiv("max");
            return false
        }
    }(this);
    this.hideTable = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            var c = a.$(a.target + "canvasXpressDataTable");
            if (c) {
                a.showDataTable = false;
                a.moveDataTableDiv("hide");
                setTimeout(function () {
                    a.hideUnhideDataTable(true);
                    a.resetFade(c);
                    a.resetDataTable(true)
                }, 500)
            }
            return false
        }
    }(this);
    this.mousedownDataTableResizer = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.registerDataTableResizer(b);
            return false
        }
    }(this);
    this.registerDataTableResizer = function (b) {
        if (!b) {
            b = window.event
        }
        var a = b.target || b.srcElement;
        if (a.className = "resizable") {
            var d = this.$(this.target + "canvasXpressDataTable");
            if (d) {
                this.dataTableTarget = d;
                this.xMouseDown = b.clientX;
                this.yMouseDown = b.clientY;
                this.dataTableWidth = parseInt(this.dataTableTarget.style.width) || 0;
                this.dataTableHeight = parseInt(this.dataTableTarget.style.height) || 0;
                this.resizingDataTableOn = true
            }
        }
    };
    this.updateDataTableResizerDiv = function (b) {
        if (!b) {
            b = window.event
        }
        if (this.dataTableTarget && this.dataTableTarget.style) {
            var f = this.$(this.target + "canvasXpressDataTable");
            var g = this.$(this.target + "canvasXpressDataTableContainer");
            var k = this.$(this.target + "canvasXpressDataTableVer");
            var a = this.$(this.target + "canvasXpressDataTableHor");
            var l = this.$(this.target + "canvasXpressDataTableToolbar");
            if (f && g && k && a && l) {
                f.style.MozUserSelect = "none";
                f.style.KhtmlUserSelect = "none";
                f.style.WebkitUserSelect = "none";
                f.style.OUserSelect = "none";
                f.style.UserSelect = "none";
                var n = this.xMouseDown - b.clientX;
                var m = this.yMouseDown - b.clientY;
                var j = Math.abs(this.dataTableWidth) - n;
                var i = Math.abs(this.dataTableHeight) - m;
                if (j < (this.dataTableTotalWidth + this.colWidth + 20)) {
                    this.dataTableTarget.style.width = j + "px";
                    g.style.width = j + "px";
                    a.style.width = (j - 20) + "px";
                    l.style.width = j + "px";
                    this.dataTableLastWidth = j
                }
                if (i < (this.dataTableTotalHeight + this.rowHeight + 42)) {
                    this.dataTableTarget.style.height = i + "px";
                    g.style.height = (i - 18) + "px";
                    k.style.height = (i - 42) + "px";
                    this.dataTableLastHeight = i
                }
            }
        }
    };
    this.endDataTableResizerDiv = function (a) {
        if (this.dataTableTarget != null) {
            var b = this.$(this.target + "canvasXpressDataTable");
            delete(b.style.MozUserSelect);
            delete(b.style.KhtmlUserSelect);
            delete(b.style.WebkitUserSelect);
            delete(b.style.OUserSelect);
            delete(b.style.UserSelect);
            this.resizeDataTable(true);
            this.xMouseDown = null;
            this.yMouseDown = null;
            this.dataTableWidth = null;
            this.dataTableHeight = null;
            this.dataTableTarget = false;
            this.resizingDataTableOn = false
        }
    };
    this.mousemoveDataTableHeader = function (a) {
        return function (o) {
            if (!o) {
                o = window.event
            }
            var d = a.resizingDataTableColumnOn ? a.dataTableColumnTarget : o.target || o.srcElement;
            var g = a.$(a.target + "canvasXpressDataTable");
            var q = a.$(a.target + "canvasXpressDataTableContainer");
            var k = a.$(a.target + "canvasXpressDataTableTable");
            var n = a.$(a.target + "canvasXpressDataTableToolbar");
            var p = a.$(a.target + "canvasXpressTable");
            var t = a.$(a.target + "canvasXpressDataTableHor");
            var l = a.$(a.target + "canvasXpressDataTableHorImage");
            var u = a.adjustedCoordinates(o, d);
            if (u && q && g && k && n && p && t && l) {
                if (a.resizingDataTableColumnOn) {
                    var b = a.dataTableColumnTarget.id.split(".");
                    var j = parseInt(b[2]);
                    var s = u.x - a.xMouseDown;
                    var r = Math.max(a.colWidth, (a.dataTableColumnWidth[a.startCol + j] || a.colWidth) + s);
                    if (r > a.colWidth) {
                        g.style.width = (parseInt(g.style.width) + s) + "px";
                        q.style.width = (parseInt(q.style.width) + s) + "px";
                        k.style.width = (parseInt(k.style.width) + s) + "px";
                        n.style.width = (parseInt(n.style.width) + s) + "px";
                        p.style.width = (parseInt(p.style.width) + s) + "px";
                        t.style.width = (parseInt(t.style.width) + s) + "px";
                        l.style.width = (parseInt(l.width) + s) + "px"
                    }
                    a.dataTableColumnTarget.style.width = r + "px";
                    a.dataTableColumnTarget.firstChild.style.width = r + "px";
                    for (var m = a.startRow; m < a.startRow + a.totalRows; m++) {
                        var f = a.$(a.target + "canvasXpressDataTableCell." + m + "." + j);
                        if (f) {
                            f.style.width = r + "px";
                            f.firstChild.style.width = r + "px"
                        }
                    }
                    a.dataTableColumnWidth[a.startCol + j] = r;
                    a.xMouseDown = u.x;
                    a.yMouseDown = u.y;
                    document.body.style.cursor = "ew-resize"
                } else {
                    var h = (d.offsetLeft + d.clientWidth) - u.x;
                    if (h < 5 && d.nodeName.toLowerCase() == "th") {
                        d.style.cursor = "ew-resize"
                    } else {
                        d.style.cursor = "default"
                    }
                }
            }
            return false
        }
    }(this);
    this.mousedownDataTableHeader = function (a) {
        return function (d) {
            if (!d) {
                d = window.event
            }
            var b = d.target || d.srcElement;
            var c = a.adjustedCoordinates(d, b);
            if (c) {
                var f = (b.offsetLeft + b.clientWidth) - c.x;
                if (f < 5 && b.nodeName.toLowerCase() == "th") {
                    a.dataTableColumnTarget = b;
                    a.xMouseDown = c.x;
                    a.yMouseDown = c.y;
                    a.resizingDataTableColumnOn = true;
                    document.body.style.cursor = "ew-resize"
                }
            }
            return false
        }
    }(this);
    this.endDataTableColumnResize = function (a) {
        this.xMouseDown = null;
        this.yMouseDown = null;
        this.resizingDataTableColumnOn = false;
        this.dataTableColumnTarget = false;
        document.body.style.cursor = "default"
    };
    this.initializeDataTableEvents = function () {
        this.addDataTableDiv()
    };
    this.initializeDataTableEvents()
};
CanvasXpress.prototype.initCanvasResizerEvents = function () {
    this.addCanvasResizerDiv = function (a) {
        
    };
    this.isCanvasResize = function (c) {
        if (this.resizable) {
            if (!c) {
                c = window.event
            }
            var b = this.adjustedCoordinates(c);
            if (b) {
                var a = b.x;
                var d = b.y;
                if (a > this.width - 18 && d > this.height - 18) {
                    this.resizeCanvasCursorShow = "se-resize";
                    return true
                } else {
                    if (a > this.width - 18) {
                        this.resizeCanvasCursorShow = "e-resize";
                        return true
                    } else {
                        if (d > this.height - 18) {
                            this.resizeCanvasCursorShow = "s-resize";
                            return true
                        } else {
                            this.resizeCanvasCursorShow = false;
                            return false
                        }
                    }
                }
            }
        }
    };
    this.updateCanvasResizerCursor = function (d) {
        if (this.resizable) {
            if (!d) {
                d = window.event
            }
            var b = document.getElementById(this.target);
            if (b) {
                var c = this.adjustedCoordinates(d);
                if (c) {
                    var a = c.x;
                    var f = c.y;
                    if (a > this.width - 18 && f > this.height - 18) {
                        b.style.cursor = "se-resize";
                        this.resizeCanvasCursorShow = "se-resize"
                    } else {
                        if (a > this.width - 18) {
                            b.style.cursor = "e-resize";
                            this.resizeCanvasCursorShow = "e-resize"
                        } else {
                            if (f > this.height - 18) {
                                b.style.cursor = "s-resize";
                                this.resizeCanvasCursorShow = "s-resize"
                            } else {
                                if (!this.movingOn) {
                                    b.style.cursor = "default";
                                    this.resizeCanvasCursorShow = false
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.updateCanvasResizer = function (f) {
       /* if (this.resizingCanvasOn && this.resizeCanvasCursorShow) { 
            document.body.style.cursor = this.resizeCanvasCursorShow;
            var c = document.getElementById(this.target + "canvasXpressCanvasResize");
            var a = document.getElementById("canvasXpressCanvasResize");
            var b = this.adjustedCoordinates(f);
            var d = this.relativeCoordinates(this.canvas);
            if (c && b && d) {
                if (this.resizeCanvasCursorShow == "se-resize") {
                    w = b.x;
                    h = b.y
                } else {
                    if (this.resizeCanvasCursorShow == "e-resize") {
                        w = b.x;
                        h = this.height
                    } else {
                        if (this.resizeCanvasCursorShow == "s-resize") {
                            w = this.width;
                            h = b.y
                        }
                    }
                }
                if (!a) {
                    a = this.addCanvasResizerDiv(true)
                }
                this.preventSelection();
                dx = b.x - this.canvas.width;
                dy = b.y - this.canvas.height;
                c.style.width = w + "px";
                c.style.height = h + "px";
                c.style.display = "block";
                a.style.left = d.x + "px";
                a.style.top = d.y + "px";
                a.style.width = w + "px";
                a.style.height = h + "px";
                a.style.display = "block";
                CanvasXpress.resizing = true
            }
        } */
    };
    this.endCanvasResizer = function (j) {
        /* if (this.resizingCanvasOn) {
            var f = document.getElementById(this.target);
            var g = document.getElementById(this.target + "canvasXpressCanvasResize");
            var d = document.getElementById("canvasXpressCanvasResize");
            var c = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
            if (f && g && d) {
                this.tmpHeight = false;
                this.tmpWidth = false;
                var a = parseInt(g.style.width.replace("px", ""));
                var k = parseInt(g.style.height.replace("px", ""));
                this.resetAxesResizer();
                this.draw(a, k);
                this.resizeAcknowledgementDiv();
                g.style.width = "0.5px";
                g.style.height = "0.5px";
                g.style.display = "none";
                f.style.cursor = "default";
                this.updateRemoteNavigationWindow();
                document.body.removeChild(d);
                this.resizeCanvasCursorShow = false;
                this.resizingCanvasOn = false;
                CanvasXpress.resizing = false
            }
        } */
    };
    this.initializeCanvasResizerEvents = function () {
        if (!this.disableEvents) {
            this.addCanvasResizerDiv()
        }
    };
    this.initializeCanvasResizerEvents()
};
CanvasXpress.prototype.initAxisResizerEvents = function () {
    this.addAxesResizeDiv = function () {
        if (document.getElementById(this.target + "canvasXpressAxesResize")) {
            return
        }
        var c = ["Previous", "Next", "Current", "Middle", "Min", "Max", "Close"];
        var b = 9001;
        var e = document.createElement("div");
        e.id = this.target + "canvasXpressAxesResize";
        if (this.resizerTransparency) {
            e.style.opacity = 0.85;
            e.style.filter = "alpha(opacity = 85)"
        }
        e.style.position = "absolute";
        e.style.display = "none";
        e.style.zIndex = b;
        for (var a = 0; a < c.length; a++) {
            b++;
            var f = document.createElement("div");
            f.id = this.target + "canvasXpressAxesResize" + c[a];
            if (this.resizerTransparency) {
                f.style.opacity = 0.85;
                f.style.filter = "alpha(opacity = 85)"
            }
            f.style.position = "absolute";
            f.style.zIndex = b;
            e.appendChild(f)
        }
        this.canvas.parentNode.appendChild(e)
    };
    this.clickAxesResizeClose = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.stopEvent(b);
            a.resetAxesResizer(b);
            a.resetFlags(b)
        }
    }(this);
    this.mousemoveActiveAxesResize = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.activateDeactivateAxesResizer(b)
        }
    }(this);
    this.mousedownAxesResize = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.cancelEvent(b);
            a.registerAxesResizer(b);
            return false
        }
    }(this);
    this.mousemoveAxesResize = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.cancelEvent(b);
            a.updateAxesResizer(b);
            return false
        }
    }(this);
    this.addRemoveAxesResizerListeners = function (p) {
        var a = document.getElementById(this.target + "canvasXpressAxesResize");
        var d = document.getElementById(this.target + "canvasXpressAxesResizeMin");
        var k = document.getElementById(this.target + "canvasXpressAxesResizeMax");
        var e = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
        var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
        var g = document.getElementById(this.target + "canvasXpressAxesResizeClose");
        var b = [a, d, k, e, i];
        if (a) {
            this[p](a, "mousemove", this.mousemoveActiveAxesResize, false);
            this[p](a, "mouseout", this.mousemoveActiveAxesResize, false)
        }
        if (g) {
            this[p](g, "click", this.clickAxesResizeClose, false)
        }
        for (var f = 0; f < b.length; f++) {
            if (b[f]) {
                this[p](b[f], "mousedown", this.mousedownAxesResize, false)
            }
        }
    };
    this.showAxesResizer = function (f, e, c, q, o, m, b, g, t, u, n, j, i) {
        if (!this.axesResizerShow) {
            var a = document.getElementById(this.target + "canvasXpressAxesResize");
            var k = document.getElementById(this.target + "canvasXpressAxesResizeClose");
            if (a && k) {
                this.updateResizerEventData(null, null, f, e, c, q, o, m, b, g, t, u, n, j, i);
                this.refreshAxesResizer();
                a.style.display = "block";
                if (this.resizerType && this.layoutValid) {
                    k.style.display = "none"
                }
                this.addRemoveAxesResizerListeners("addEvtListener");
                if (this.layoutValid) {
                    this.layoutValidR = j;
                    this.layoutValidC = i;
                    this.layoutValidN = n
                }
                this.axesResizerShow = true
            }
        }
    };
    this.refreshAxesResizer = function () {
        if (this.resizerEventData) {
            var b = document.getElementById(this.target + "canvasXpressAxesResize");
            var e = document.getElementById(this.target + "canvasXpressAxesResizeMin");
            var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
            var f = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
            var i = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
            var g = document.getElementById(this.target + "canvasXpressAxesResizeClose");
            var k = document.getElementById(this.target + "canvasXpressAxesResizePrevious");
            var j = document.getElementById(this.target + "canvasXpressAxesResizeNext");
            if (b && e && o && i && g && k && j) {
                var s = this.resizerEventData.areas.org[1] - this.resizerEventData.areas.org[0];
                var p = this.resizerEventData.areas.org[3] - this.resizerEventData.areas.org[2];
                var d = 14;
                var a = 9;
                var q = parseInt(a / 2);
                if (this.resizerEventData.pos == "h") {
                    l = this.resizerEventData.l.match(/^t/) ? "top" : "bottom";
                    b.style.left = (this.resizerEventData.areas.org[0] - q) + "px";
                    b.style.top = this.resizerEventData.areas.org[2] + "px";
                    b.style.width = ((s + a) - 1) + "px";
                    b.style.height = d + "px";
                    b.style.backgroundImage = "url('" + this.imageDir + "scroller_empty_hor_" + l + ".png')";
                    b.style.backgroundRepeat = "repeat-x";
                    k.style.left = "0px";
                    k.style.top = "0px";
                    k.style.width = a + "px";
                    k.style.height = d + "px";
                    k.style.backgroundImage = "url('" + this.imageDir + "prev_" + l + ".png')";
                    e.style.left = this.resizerEventData.areas.min[0] + "px";
                    e.style.top = "0px";
                    e.style.width = a + "px";
                    e.style.height = d + "px";
                    e.style.cursor = "e-resize";
                    e.style.backgroundImage = "url('" + this.imageDir + "handle_left_" + l + ".png')";
                    i.style.left = this.resizerEventData.areas.cur[0] + "px";
                    i.style.top = "0px";
                    i.style.width = this.resizerEventData.areas.cur[1] + "px";
                    i.style.height = d + "px";
                    i.style.cursor = "move";
                    i.style.backgroundImage = "url('" + this.imageDir + "scroller_body_hor_" + l + ".png')";
                    i.style.backgroundRepeat = "repeat-x";
                    o.style.left = this.resizerEventData.areas.max[0] + "px";
                    o.style.top = "0px";
                    o.style.width = a + "px";
                    o.style.height = d + "px";
                    o.style.cursor = "e-resize";
                    o.style.backgroundImage = "url('" + this.imageDir + "handle_right_" + l + ".png')";
                    o.style.backgroundRepeat = "no-repeat";
                    f.style.left = (this.resizerEventData.areas.min[0] + ((this.resizerEventData.areas.cur[1] - 1) / 2)) + "px";
                    f.style.top = "0px";
                    f.style.width = "8px";
                    f.style.height = d + "px";
                    f.style.cursor = "move";
                    f.style.backgroundImage = "url('" + this.imageDir + "scroller_handle_hor_" + l + ".png')";
                    j.style.left = (s - 1) + "px";
                    j.style.top = "0px";
                    j.style.width = a + "px";
                    j.style.height = d + "px";
                    j.style.backgroundImage = "url('" + this.imageDir + "next_" + l + ".png')";
                    g.style.left = (s + a) + "px";
                    g.style.top = "0px";
                    g.style.width = a + "px";
                    g.style.height = d + "px";
                    g.style.backgroundImage = "url('" + this.imageDir + "close.png')"
                } else {
                    l = this.resizerEventData.l.match(/^l/) ? "left" : "right";
                    b.style.left = this.resizerEventData.areas.org[0] + "px";
                    b.style.top = (this.resizerEventData.areas.org[2] - q) + "px";
                    b.style.width = d + "px";
                    b.style.height = (p + a) + "px";
                    b.style.backgroundImage = "url('" + this.imageDir + "scroller_empty_ver_" + l + ".png')";
                    b.style.backgroundRepeat = "repeat-y";
                    k.style.left = "0px";
                    k.style.top = p + "px";
                    k.style.width = d + "px";
                    k.style.height = a + "px";
                    k.style.backgroundImage = "url('" + this.imageDir + "prev_" + l + ".png')";
                    e.style.left = "0px";
                    e.style.top = this.resizerEventData.areas.min[2] + "px";
                    e.style.width = d + "px";
                    e.style.height = a + "px";
                    e.style.cursor = "n-resize";
                    e.style.backgroundImage = "url('" + this.imageDir + "handle_bottom_" + l + ".png')";
                    e.style.backgroundRepeat = "no-repeat";
                    i.style.left = "0px";
                    i.style.top = this.resizerEventData.areas.cur[2] + "px";
                    i.style.width = d + "px";
                    i.style.height = this.resizerEventData.areas.cur[3] + "px";
                    i.style.cursor = "move";
                    i.style.backgroundImage = "url('" + this.imageDir + "scroller_body_ver_" + l + ".png')";
                    i.style.backgroundRepeat = "repeat-y";
                    o.style.left = "0px";
                    o.style.top = this.resizerEventData.areas.max[2] + "px";
                    o.style.width = d + "px";
                    o.style.height = a + "px";
                    o.style.cursor = "n-resize";
                    o.style.backgroundImage = "url('" + this.imageDir + "handle_top_" + l + ".png')";
                    o.style.backgroundRepeat = "no-repeat";
                    f.style.left = "0px";
                    f.style.top = (this.resizerEventData.areas.max[2] + (this.resizerEventData.areas.cur[3] / 2)) + "px";
                    f.style.width = d + "px";
                    f.style.height = d + "px";
                    f.style.cursor = "move";
                    f.style.backgroundImage = "url('" + this.imageDir + "scroller_handle_ver_" + l + ".png')";
                    f.style.backgroundRepeat = "no-repeat";
                    j.style.left = "0px";
                    j.style.top = "0px";
                    j.style.width = d + "px";
                    j.style.height = a + "px";
                    j.style.backgroundImage = "url('" + this.imageDir + "next_" + l + ".png')";
                    g.style.left = (d + 1) + "px";
                    g.style.top = -a + "px";
                    g.style.width = a + "px";
                    g.style.height = d + "px";
                    g.style.backgroundImage = "url('" + this.imageDir + "close.png')"
                }
                this.drawAxesResizerMasks()
            }
        }
    };
    this.updateResizerEventData = function (i, H, B, q, o, a, X, U, K, O, I, J, z, t, r) {
        var j, G, F, m, k, A, y, f, c, Q, P, E, D, n, W;
        B = B ? B : this.resizerEventData.axis;
        q = q ? q : this.resizerEventData.areas.org[0];
        o = o ? o : this.resizerEventData.areas.org[1];
        a = a ? a : this.resizerEventData.areas.org[2];
        X = X ? X : this.resizerEventData.areas.org[3];
        U = U ? U : this.resizerEventData.dim;
        K = K ? K : this.resizerEventData.pos;
        O = O ? O : this.resizerEventData.l;
        I = I ? I : this.resizerEventData.vals;
        J = J ? J : this.resizerEventData.set ? this.resizerEventData.set : "";
        z = z ? z : this.resizerEventData.c;
        t = t ? t : this.resizerEventData.i;
        r = r ? r : this.resizerEventData.j;
        var S = I.graphType;
        var e = o - q;
        var b = X - a;
        if (S == "Heatmap") {
            if (U == "y") {
                j = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0
            } else {
                j = this.data.y ? this.data.y.vars.length : 0
            }
        } else {
            j = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0
        }
        var V = this.resizerType == "samples" || S == "Heatmap" ? 0 : I[B + "AbsMin"];
        var C = this.resizerType == "samples" || S == "Heatmap" ? j : I[B + "AbsMax"];
        var u = K == "h" ? e : b;
        var R = u / (C - V);
        if (i == null || isNaN(i)) {
            if (this.resizerType == "samples") {
                i = this.isGroupedData ? this.grpIndices[0] : this.smpIndices[0]
            } else {
                if (S == "Heatmap") {
                    i = U == "y" ? Math.max(0, I.smpIndicesStart) : Math.max(0, I.varIndicesStart)
                } else {
                    i = S.match(/Scatter/) ? I["setMin" + U.toUpperCase()] : S == "BarLine" && O.match(/b|r/) ? I.setMin2 : I.setMin
                }
                if (i == null || isNaN(i)) {
                    i = V
                }
            }
        }
        i = Math.max(i, V);
        if (H == null || isNaN(H)) {
            if (this.resizerType == "samples") {
                H = this.isGroupedData ? this.grpIndices[this.grpIndices.length - 1] : this.smpIndices[this.smpIndices.length - 1]
            } else {
                if (S == "Heatmap") {
                    H = U == "x" ? I.varIndices.length : this.isGroupedData ? I.grpIndices.length : I.smpIndices.length;
                    H += i
                } else {
                    H = S.match(/Scatter/) ? I["setMax" + U.toUpperCase()] : S == "BarLine" && O.match(/b|r/) ? I.setMax2 : I.setMax
                }
                if (H == null || isNaN(H)) {
                    H = C
                }
            }
        }
        H = Math.min(H, C);
        var x = (i - V) * R;
        var T = (H - V) * R;
        var N = 14;
        var M = 9;
        var L = parseInt(M / 2);
        if (K == "h") {
            G = parseInt(x);
            F = M;
            m = 0;
            k = N;
            Q = parseInt(x + L + 1);
            P = parseInt(T - (x + 1));
            E = 0;
            D = N;
            A = parseInt(T - 1);
            y = M;
            f = 0;
            c = N;
            n = o + (M - 1);
            W = X
        } else {
            G = 0;
            F = N;
            m = this.resizerType == "samples" || S == "Heatmap" ? parseInt(T) : parseInt(b - (x + 1));
            k = M;
            Q = 0;
            P = N;
            E = this.resizerType == "samples" || S == "Heatmap" ? parseInt(x + L) : parseInt((b - T) + L);
            D = parseInt(T - x);
            A = 0;
            y = N;
            f = this.resizerType == "samples" || S == "Heatmap" ? parseInt(x + 1) : parseInt(b - T);
            c = M;
            n = o;
            W = X + (M - 1)
        }
        this.resizerEventData = {
            g: S,
            axis: B,
            dim: U,
            pos: K,
            l: O,
            vals: I,
            min: V,
            max: C,
            smin: i,
            smax: H,
            len: u,
            unit: R,
            width: N,
            set: J,
            c: z,
            i: t,
            j: r,
            areas: {
                org: [q, o, a, X],
                lim: [q, n, a, W],
                min: [G, F, m, k],
                max: [A, y, f, c],
                cur: [Q, P, E, D]
            }
        }
    };
    this.updateAxesResizer = function (v) {
        if (this.axesResizingOn) {
            if (!v) {
                v = window.event
            }
            var q = this.resizerEventData.areas;
            var A = this.adjustedCoordinates(v);
            if (A) {
                var n, B, b, c, a;
                var f = this.xMouseDown - A.x;
                var d = this.yMouseDown - A.y;
                var j, i;
                var s = null;
                var u = null;
                var z = "";
                var F = 14;
                var E = 9 - 1;
                var C = parseInt(E / 2);
                if (this.resizerEventData.g == "Heatmap") {
                    if (this.resizerEventData.dim == "y") {
                        n = this.isGroupedData ? this.data.w.smps.length : this.data.y ? this.data.y.smps.length : 0;
                        b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length : this.data.y.smps.length
                    } else {
                        n = this.data.y ? this.data.y.vars.length : 0;
                        b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.data.y.vars.length
                    }
                    B = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
                    a = this.resizerEventData.pos == "h" ? (q.org[1] - q.org[0]) / n : (q.org[3] - q.org[2]) / n
                } else {
                    n = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y ? this.data.y.smps.length - 1 : 0;
                    B = this.resizerEventData.lastMin != null ? this.resizerEventData.lastMin : this.resizerEventData.smin != null ? this.resizerEventData.smin : 0;
                    b = this.resizerEventData.lastMax != null ? this.resizerEventData.lastMax : this.resizerEventData.smax != null ? this.resizerEventData.smax : this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
                    a = this.resizerEventData.pos == "h" ? (q.org[1] - q.org[0]) / n : (q.org[3] - q.org[2]) / n
                }
                if (this.resizerEventData.active == "min") {
                    j = f > q.min[0] ? this.xMouseDown - q.min[0] : f < (q.min[0] + q.min[1]) - q.max[0] ? this.xMouseDown - ((q.min[0] + q.min[1]) - q.max[0]) : A.x;
                    i = d > q.min[2] - (q.max[2] + q.max[3]) ? this.yMouseDown - (q.min[2] - (q.max[2] + q.max[3])) : d < (q.lim[2] + q.min[2] + q.min[3]) - q.lim[3] ? (q.lim[3] - (q.lim[2] + q.min[2] + q.min[3])) + this.yMouseDown : A.y
                } else {
                    if (this.resizerEventData.active == "max") {
                        j = f > q.max[0] - (q.min[0] + q.min[1]) ? this.xMouseDown - (q.max[0] - (q.min[0] + q.min[1])) : f < (q.lim[0] + q.max[0] + q.max[1]) - q.lim[1] ? (q.lim[1] - (q.lim[0] + q.max[0] + q.max[1])) + this.xMouseDown : A.x;
                        i = d > q.max[2] ? this.yMouseDown - q.max[2] : d < (q.lim[2] + q.max[2] + q.max[3]) - (q.lim[2] + q.min[2]) ? ((q.lim[2] + q.min[2]) - (q.lim[2] + q.max[2] + q.max[3])) + this.yMouseDown : A.y
                    } else {
                        if (this.resizerEventData.active == "cur") {
                            j = f > q.min[0] ? this.xMouseDown - q.min[0] : f < (q.lim[0] + q.max[0] + q.max[1]) - q.lim[1] ? (q.lim[1] - (q.lim[0] + q.max[0] + q.max[1])) + this.xMouseDown : A.x;
                            i = d > q.max[2] ? this.yMouseDown - q.max[2] : d < (q.lim[2] + q.min[2] + q.min[3]) - q.lim[3] ? (q.lim[3] - (q.lim[2] + q.min[2] + q.min[3])) + this.yMouseDown : A.y
                        } else {
                            return
                        }
                    }
                }
                var m = j - this.xMouseDown;
                var k = i - this.yMouseDown;
                if (this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") {
                    m -= m % a;
                    k -= k % a
                }
                var r = m / this.resizerEventData.unit;
                var p = k / this.resizerEventData.unit;
                var t = document.getElementById(this.target + "canvasXpressAxesResizeMin");
                var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
                var D = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
                var g = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
                if (t && o && D && g) {
                    if (this.resizerEventData.active == "min") {
                        if (this.resizerEventData.pos == "h") {
                            t.style.left = (q.min[0] + m) + "px";
                            D.style.left = ((q.min[0] + m) + ((q.cur[1] - m) / 2)) + "px";
                            g.style.left = (q.min[0] + m + C + 1) + "px";
                            g.style.width = (q.cur[1] - m) + "px";
                            B = parseInt((q.min[0] + E + m) / a);
                            if (this.resizerType == "samples") {
                                s = dateFormat(this.data.y.smps[B], this.timeFormat)
                            } else {
                                if (this.resizerEventData.g == "Heatmap") {
                                    s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]]
                                } else {
                                    s = this.formatNumber(this.resizerEventData.smin + r)
                                }
                            }
                        } else {
                            t.style.top = (q.min[2] + k) + "px";
                            D.style.top = ((q.min[2] + k) - ((q.cur[3] + k) / 2)) + "px";
                            g.style.height = ((q.cur[3] + k)) + "px";
                            b = parseInt((q.min[2] + E + k) / a);
                            if (this.resizerType == "samples") {
                                s = dateFormat(this.data.y.smps[b], this.timeFormat)
                            } else {
                                if (this.resizerEventData.g == "Heatmap") {
                                    s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
                                } else {
                                    s = this.formatNumber(this.resizerEventData.smin - p)
                                }
                            }
                        }
                        this.showInfoSpan(v, s)
                    } else {
                        if (this.resizerEventData.active == "max") {
                            if (this.resizerEventData.pos == "h") {
                                o.style.left = (q.max[0] + m) + "px";
                                D.style.left = ((q.min[0] + m) + ((q.cur[1] - m) / 2)) + "px";
                                g.style.width = (q.cur[1] + m) + "px";
                                b = parseInt((q.max[0] + E + m) / a);
                                if (this.resizerType == "samples") {
                                    u = dateFormat(this.data.y.smps[b], this.timeFormat)
                                } else {
                                    if (this.resizerEventData.g == "Heatmap") {
                                        u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
                                    } else {
                                        u = this.formatNumber(this.resizerEventData.smax + r)
                                    }
                                }
                            } else {
                                o.style.top = (q.max[2] + k) + "px";
                                D.style.top = ((q.max[2] + k) + ((q.cur[3] - k) / 2)) + "px";
                                g.style.top = (q.max[2] + k + C) + "px";
                                g.style.height = (q.cur[3] - k) + "px";
                                B = parseInt((q.max[2] + E + k) / a);
                                if (this.resizerType == "samples") {
                                    u = dateFormat(this.data.y.smps[B], this.timeFormat)
                                } else {
                                    if (this.resizerEventData.g == "Heatmap") {
                                        u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]]
                                    } else {
                                        u = this.formatNumber(this.resizerEventData.smax - p)
                                    }
                                }
                            }
                            this.showInfoSpan(v, u)
                        } else {
                            if (this.resizerEventData.active == "cur") {
                                if (this.resizerEventData.pos == "h") {
                                    t.style.left = (q.min[0] + m) + "px";
                                    D.style.left = ((q.min[0] + m) + (q.cur[1] / 2)) + "px";
                                    o.style.left = (q.max[0] + m) + "px";
                                    g.style.left = (q.min[0] + m + C + 1) + "px";
                                    B = parseInt((q.min[0] + E + m) / a);
                                    b = parseInt((q.max[0] + E + m) / a);
                                    if (this.resizerType == "samples") {
                                        s = dateFormat(this.data.y.smps[B], this.timeFormat);
                                        u = dateFormat(this.data.y.smps[b], this.timeFormat)
                                    } else {
                                        if (this.resizerEventData.g == "Heatmap") {
                                            s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]];
                                            u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]]
                                        } else {
                                            s = this.formatNumber(this.resizerEventData.smin + r);
                                            u = this.formatNumber(this.resizerEventData.smax + r)
                                        }
                                    }
                                    this.showInfoSpan(v, s + "--" + u)
                                } else {
                                    t.style.top = (q.min[2] + k) + "px";
                                    D.style.top = ((q.max[2] + k) + (q.cur[3] / 2)) + "px";
                                    o.style.top = (q.max[2] + k) + "px";
                                    g.style.top = (q.max[2] + k + C) + "px";
                                    b = parseInt((q.min[2] + E + k) / a);
                                    B = parseInt((q.max[2] + E + k) / a);
                                    if (this.resizerType == "samples") {
                                        s = dateFormat(this.data.y.smps[b], this.timeFormat);
                                        u = dateFormat(this.data.y.smps[B], this.timeFormat);
                                        this.showInfoSpan(v, u + "--" + s)
                                    } else {
                                        if (this.resizerEventData.g == "Heatmap") {
                                            s = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[b]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[b]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[b]];
                                            u = this.resizerEventData.dim == "x" ? this.data.y.vars[this.resizerEventData.vals.varIndices[B]] : this.isGroupedData ? this.data.w.smps[this.resizerEventData.vals.grpIndices[B]] : this.data.y.smps[this.resizerEventData.vals.smpIndices[B]];
                                            this.showInfoSpan(v, u + "--" + s)
                                        } else {
                                            s = this.formatNumber(this.resizerEventData.smin - p);
                                            u = this.formatNumber(this.resizerEventData.smax - p);
                                            this.showInfoSpan(v, s + "--" + u)
                                        }
                                    }
                                }
                            }
                        }
                    }
                    this.resizerEventData.lastMin = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? B : s;
                    this.resizerEventData.lastMax = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? b : u;
                    if (this.resizerDraw) {
                        this.drawAxesResizerUpdate()
                    }
                }
            }
        }
    };
    this.drawAxesResizerUpdate = function (n) {
        var d = this.resizerEventData.lastMin != null ? parseFloat(this.resizerEventData.lastMin) : parseFloat(this.resizerEventData.smin);
        var k = this.resizerEventData.lastMax != null ? parseFloat(this.resizerEventData.lastMax) : parseFloat(this.resizerEventData.smax);
        var j = this.resizerEventData.c || 0;
        if (this.resizerType == "samples") {
            var m = this.isGroupedData ? this.data.w.smps.length - 1 : this.data.y.smps.length - 1;
            var a = [];
            var g = [];
            for (var f = 0; f < d; f++) {
                g.push(true)
            }
            for (var f = d; f <= k; f++) {
                a.push(f);
                g.push(false)
            }
            for (var f = k + 1; f < m; f++) {
                g.push(true)
            }
            if (this.isGroupedData) {
                this.grpIndices = a;
                this.hiddenGrps = g
            } else {
                this.smpIndices = a;
                this.hiddenSmps = g
            }
        } else {
            if (this.resizerEventData.g == "Heatmap") {
                if (!this.startingVarIndices || !this.startingSmpIndices) {
                    this.setOriginalIndices(j)
                }
                var b = this.startingVarIndices[j];
                var e = this.startingSmpIndices[j];
                if (this.resizerEventData.dim == "y") {
                    if (this.isGroupedData) {
                        if (this.layoutComb) {
                            this.layoutParams[j]["grpIndices"] = [];
                            for (var f = d; f < k; f++) {
                                this.layoutParams[j]["grpIndices"].push(e[f])
                            }
                            this.layoutParams[j]["smpIndicesStart"] = d
                        } else {
                            this.grpIndices = [];
                            for (var f = d; f < k; f++) {
                                this.grpIndices.push(e[f])
                            }
                            this.smpIndicesStart = d
                        }
                    } else {
                        if (this.layoutComb) {
                            this.layoutParams[j]["smpIndices"] = [];
                            for (var f = d; f < k; f++) {
                                this.layoutParams[j]["smpIndices"].push(e[f])
                            }
                            this.layoutParams[j]["smpIndicesStart"] = d
                        } else {
                            this.smpIndices = [];
                            for (var f = d; f < k; f++) {
                                this.smpIndices.push(e[f])
                            }
                            this.smpIndicesStart = d
                        }
                    }
                } else {
                    if (this.layoutComb) {
                        this.layoutParams[j]["varIndices"] = [];
                        for (var f = d; f < k; f++) {
                            this.layoutParams[j]["varIndices"].push(b[f])
                        }
                        this.layoutParams[j]["varIndicesStart"] = d
                    } else {
                        this.varIndices = [];
                        for (var f = d; f < k; f++) {
                            this.varIndices.push(b[f])
                        }
                        this.varIndicesStart = d
                    }
                }
            } else {
                if (this.resizerEventData.lastMin) {
                    this["setMin" + this.resizerEventData.set] = d
                }
                if (this.resizerEventData.lastMax) {
                    this["setMax" + this.resizerEventData.set] = k
                }
            }
        }
        if (n) {
            this.updateResizerEventData(d, k)
        }
        this.draw()
    };
    this.drawAxesResizerBackgroundData = function (d, p, b, o) {
        if (this.resizerType && this.resizerDataIndex > -1) {
            this.setAllSamplesVisible();
            var a, k, c, n;
            var m = this.graphType == "Candlestick" ? "close" : false;
            var g = [];
            var e = [];
            var q = [];
            for (var f = 0; f < this.smpIndices.length; f++) {
                g.push(this.getDataAtPos(this.resizerDataIndex, f, m))
            }
            var j = this.range(g);
            if (this.resizerPosition.match(/top|bottom/)) {
                a = b / (this.smpIndices.length - 1);
                k = o / ((j[1] - j[0]) * 1.2);
                c = (j[1] - j[0]) * 0.1 * k;
                n = p + o;
                e.push(d);
                q.push(n);
                for (var f = 0; f < g.length; f++) {
                    e.push(d);
                    q.push(n - (((g[f] - j[0]) * k) + c));
                    d += a
                }
                d -= a;
                e.push(d);
                q.push(n)
            } else {
                a = o / (this.smpIndices.length - 1);
                k = b / ((j[1] - j[0]) * 1.2);
                c = (j[1] - j[0]) * 0.1 * k;
                e.push(d);
                q.push(p);
                for (var f = 0; f < g.length; f++) {
                    e.push(d + ((g[f] - j[0]) * k) + c);
                    q.push(p);
                    p += a
                }
                p -= a;
                e.push(d);
                q.push(p)
            }
            this.drawShape("polygon", e, q, false, false, this.resizerBackgroundColorCurrent, this.resizerBackgroundColorOutlineCurrent, "closed")
        }
    };
    this.drawAxesResizerMasks = function () {
        if (this.resizerType) {
            var e, i, d, f;
            var c = this.resizerEventData.areas;
            var b = this.isGroupedData ? this.data.w.grps.length - 1 : this.data.y.smps.length - 1;
            var a = this.resizerEventData.pos == "h" ? (c.org[1] - c.org[0]) / b : (c.org[3] - c.org[2]) / b;
            var g = 9 - 1;
            if (this.resizerEventData.pos == "h") {
                if (this.resizerEventData.smin > 0) {
                    e = c.org[0] - 1;
                    i = c.org[2] - this.resizerWidth;
                    d = a * this.resizerEventData.smin;
                    f = this.resizerWidth;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e, i, e + d + 1, i, this.foreground);
                    this.drawLine("line", e + d, i, e + d, i + f, this.foreground)
                }
                if (this.resizerEventData.smax < b) {
                    e = c.org[0] + c.max[0] + 1;
                    i = c.org[2] - this.resizerWidth;
                    d = (a * (b - this.resizerEventData.smax)) + 1;
                    f = this.resizerWidth;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e - 1, i, e + d + 2, i, this.foreground);
                    this.drawLine("line", e - 1, i, e - 1, i + f, this.foreground)
                }
                e = c.org[0] + c.max[0];
                i = c.org[2] - 1;
                d = c.org[0] + a * this.resizerEventData.smin;
                this.drawLine("line", e, i, d, i, this.foreground)
            } else {
                if (this.resizerEventData.smin > 0) {
                    e = c.org[0] + 14;
                    i = c.org[2];
                    d = this.resizerWidth;
                    f = a * this.resizerEventData.smin;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e, i + f, e + d, i + f, this.foreground);
                    this.drawLine("line", e + d, i, e + d, i + f, this.foreground)
                }
                if (this.resizerEventData.smax < b) {
                    e = c.org[0] + 14;
                    i = c.org[2] + c.min[2];
                    d = this.resizerWidth;
                    f = (b - this.resizerEventData.smax) * a;
                    this.rectangle(e, i, d, f, this.resizerBackgroundColor, this.resizerBackgroundColor);
                    this.drawLine("line", e, i, e + d, i, this.foreground);
                    this.drawLine("line", e + d, i, e + d, i + f, this.foreground)
                }
                e = c.org[0] + 14;
                i = c.org[2] + c.min[2];
                f = c.org[2] + (a * this.resizerEventData.smin);
                this.drawLine("line", e, i, e, f, this.foreground)
            }
        }
    };
    this.registerAxesResizer = function (d) {
        if (!d) {
            d = window.event
        }
        var i = this.adjustedCoordinates(d);
        if (i) {
            var g = i.x;
            var f = i.y;
            var c = this.resizerEventData.areas;
            var k = c.lim[1] - c.lim[0];
            var j = c.lim[3] - c.lim[2];
            var a = 5;
            var b = k > j ? "h" : "v";
            if (g >= c.min[0] + c.lim[0] && g <= c.min[0] + c.min[1] + c.lim[0] && f >= c.min[2] + c.lim[2] && f <= c.min[2] + c.min[3] + c.lim[2]) {
                this.resizerEventData.active = "min";
                this.axesResizingOn = true
            } else {
                if (g >= c.max[0] + c.lim[0] && g <= c.max[0] + c.max[1] + c.lim[0] && f >= c.max[2] + c.lim[2] && f <= c.max[2] + c.max[3] + c.lim[2]) {
                    this.resizerEventData.active = "max";
                    this.axesResizingOn = true
                } else {
                    if (g >= c.cur[0] + c.lim[0] && g <= c.cur[0] + c.cur[1] + c.lim[0] && f >= c.cur[2] + c.lim[2] && f <= c.cur[2] + c.cur[3] + c.lim[2]) {
                        this.resizerEventData.active = "cur";
                        this.axesResizingOn = true
                    } else {
                        if (b == "h") {
                            if (g >= c.lim[0] && g < c.min[0] + c.lim[0]) {
                                this.resizerEventData.active = "prev";
                                this.axesResizingOn = true
                            } else {
                                if (g > c.lim[0] + c.max[0] + c.max[1] && g <= c.lim[1] - a) {
                                    this.resizerEventData.active = "next";
                                    this.axesResizingOn = true
                                }
                            }
                        } else {
                            if (f >= c.lim[2] + c.min[2] + c.min[3] && f <= c.lim[2] + c.lim[3]) {
                                this.resizerEventData.active = "prev";
                                this.axesResizingOn = true
                            } else {
                                if (f >= c.lim[2] && f <= c.lim[2] + c.max[2]) {
                                    this.resizerEventData.active = "next";
                                    this.axesResizingOn = true
                                }
                            }
                        }
                    }
                }
            }
            this.xMouseDown = g;
            this.yMouseDown = f
        }
    };
    this.activateDeactivateAxesResizer = function (j) {
        if (!j) {
            j = window.event
        }
        var s = this.adjustedCoordinates(j);
        if (s) {
            var q;
            var r = s.x;
            var m = s.y;
            var i = this.resizerEventData.areas;
            var u = i.lim[1] - i.lim[0];
            var t = i.lim[3] - i.lim[2];
            var c = 5;
            var f = u > t ? "h" : "v";
            if (f == "h") {
                if (r >= i.lim[0] && r <= i.lim[0] + i.min[0]) {
                    q = "prev"
                } else {
                    if (r >= i.lim[0] + i.max[0] + i.max[1] && r <= i.lim[1] - c) {
                        q = "next"
                    }
                }
            } else {
                if (m >= i.lim[2] + i.min[2] + i.min[3] && m <= i.lim[2] + i.lim[3]) {
                    q = "prev"
                } else {
                    if (m >= i.lim[2] && m <= i.lim[2] + i.max[2]) {
                        q = "next"
                    }
                }
            }
            var d = document.getElementById(this.target + "canvasXpressAxesResizePrevious");
            var g = document.getElementById(this.target + "canvasXpressAxesResizeNext");
            if (d && g) {
                if (q == "prev") {
                    var k = d.style.backgroundImage;
                    if (j.type.match(/mouseout|touchcancel/i)) {
                        if (k.match(/_active.png/)) {
                            d.style.backgroundImage = k.replace("_active.png", ".png")
                        }
                    } else {
                        if (!k.match(/_active.png/)) {
                            d.style.backgroundImage = k.replace(".png", "_active.png")
                        }
                    }
                } else {
                    if (q == "next") {
                        var k = g.style.backgroundImage;
                        if (j.type.match(/mouseout|touchcancel/i)) {
                            if (k.match(/_active.png/)) {
                                g.style.backgroundImage = k.replace("_active.png", ".png")
                            }
                        } else {
                            if (!k.match(/_active.png/)) {
                                g.style.backgroundImage = k.replace(".png", "_active.png")
                            }
                        }
                    } else {
                        var k = d.style.backgroundImage;
                        if (k.match(/_active.png/)) {
                            d.style.backgroundImage = k.replace("_active.png", ".png")
                        }
                        k = g.style.backgroundImage;
                        if (k.match(/_active.png/)) {
                            g.style.backgroundImage = k.replace("_active.png", ".png")
                        }
                    }
                }
            }
            return false
        }
    };
    this.moveAxesResizer = function (k) {
        var g = this.resizerEventData.smin;
        var m = this.resizerEventData.smax;
        var c = this.resizerType == "samples" || this.resizerEventData.g == "Heatmap" ? 1 : (m - g) / 10;
        if ((this.resizerType == "samples" || this.resizerEventData.g == "Heatmap") && this.resizerEventData.pos == "v") {
            if (this.resizerEventData.active == "prev") {
                if (g + c < this.resizerEventData.min) {
                    c = g - this.resizerEventData.min;
                    this.resizerEventData.lastMin = this.resizerEventData.min;
                    this.resizerEventData.lastMax = m + c
                } else {
                    this.resizerEventData.lastMin = g + c;
                    this.resizerEventData.lastMax = m + c
                }
            } else {
                if (m - c > this.resizerEventData.max) {
                    c = this.resizerEventData.max - m;
                    this.resizerEventData.lastMin = g - c;
                    this.resizerEventData.lastMax = this.resizerEventData.max
                } else {
                    this.resizerEventData.lastMin = g - c;
                    this.resizerEventData.lastMax = m - c
                }
            }
        } else {
            if (this.resizerEventData.active == "prev") {
                if (g - c < this.resizerEventData.min) {
                    c = g - this.resizerEventData.min;
                    this.resizerEventData.lastMin = this.resizerEventData.min;
                    this.resizerEventData.lastMax = m - c
                } else {
                    this.resizerEventData.lastMin = g - c;
                    this.resizerEventData.lastMax = m - c
                }
            } else {
                if (m + c > this.resizerEventData.max) {
                    c = this.resizerEventData.max - m;
                    this.resizerEventData.lastMin = g + c;
                    this.resizerEventData.lastMax = this.resizerEventData.max
                } else {
                    this.resizerEventData.lastMin = g + c;
                    this.resizerEventData.lastMax = m + c
                }
            }
        }
        var f = this.resizerEventData.areas;
        var d = document.getElementById(this.target + "canvasXpressAxesResizeMin");
        var o = document.getElementById(this.target + "canvasXpressAxesResizeMax");
        var n = document.getElementById(this.target + "canvasXpressAxesResizeMiddle");
        var j = document.getElementById(this.target + "canvasXpressAxesResizeCurrent");
        var b = 14;
        var a = 9 - 1;
        var p = parseInt(a / 2);
        var i = c * this.resizerEventData.unit;
        if ((this.resizerEventData.pos == "h" && this.resizerEventData.active == "prev") || (this.resizerEventData.pos == "v" && this.resizerEventData.active == "next")) {
            i *= -1
        }
        if (this.resizerEventData.pos == "h") {
            d.style.left = (f.min[0] + i + 1) + "px";
            n.style.left = ((f.min[0] + i) + (f.cur[1] / 2)) + "px";
            o.style.left = (f.max[0] + i) + "px";
            j.style.left = (f.min[0] + i + p + 1) + "px"
        } else {
            d.style.top = (f.min[2] + i + 1) + "px";
            n.style.top = ((f.max[2] + i) + (f.cur[3] / 2)) + "px";
            o.style.top = (f.max[2] + i) + "px";
            j.style.top = (f.max[2] + i + p + 1) + "px"
        }
    };
    this.getAxesVals = function (e) {
        var d = ["minData", "maxData", "xAxisMin", "xAxisMax", "xAxis2Min", "xAxis2Max", "yAxisMin", "yAxisMax", "zAxisMin", "zAxisMax", "xAxisUnit", "xAxis2Unit", "yAxisUnit", "zAxisUnit", "setMin", "setMax", "setMin2", "setMax2", "setMinX", "setMaxX", "setMinY", "setMaxY", "setMinZ", "setMaxZ", "xAxisAbsMin", "xAxisAbsMax", "xAxis2AbsMin", "xAxis2AbsMax", "yAxisAbsMin", "yAxisAbsMax", "zAxisAbsMin", "zAxisAbsMax", "graphType", "x", "y", "varIndices", "smpIndices", "grpIndices", "varIndicesStart", "smpIndicesStart"];
        var b = {};
        if (this.layoutComb) {
            for (var a = 0; a < d.length; a++) {
                b[d[a]] = this.layoutParams[e][d[a]]
            }
        } else {
            for (var a = 0; a < d.length; a++) {
                b[d[a]] = this[d[a]]
            }
        }
        return b
    };
    this.isAxis = function (k) {
        if (!k) {
            k = window.event
        }
        if (this.resizerType && this.layoutValid) {
            return false
        }
        var t = this.adjustedCoordinates(k);
        if (t) {
            var r = t.x;
            var p = t.y;
            var n = 0;
            var s = (this.margin * 1);
            var q = (this.margin * 2);
            var a = 18;
            for (var d = 0; d < this.layoutRows; d++) {
                for (var b = 0; b < this.layoutCols; b++) {
                    var f = this.layoutComb ? this.layoutParams[n].graphType : this.graphType;
                    if (f.match(/Network|Pie|Venn|Stacked|Area|Correlation|Circular/)) {
                        return false
                    }
                    var m = this.getBoundsXY(n);
                    if (f.match(/Scatter/)) {
                        if (r >= m[0] && r <= m[1] && p >= m[3] && p <= m[3] + a) {
                            var o = this.getAxesVals(n);
                            this.showAxesResizer("xAxis", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "X", n, d, b);
                            return true
                        } else {
                            if (r >= m[0] - a && r <= m[0] && p >= m[2] && p <= m[3]) {
                                var o = this.getAxesVals(n);
                                this.showAxesResizer("yAxis", m[0] - (this.getAxisFont(o.y) + q), m[0] - s, m[2], m[3], "y", "v", "l", o, "Y", n, d, b);
                                return true
                            }
                        }
                    } else {
                        if (f.match(/Heatmap/)) {
                            if (r >= m[0] - a && r <= m[0] && p >= m[2] && p <= m[3]) {
                                var o = this.getAxesVals(n);
                                this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + q), m[0] - s, m[2], m[3], "y", "v", "l", o, "", n, d, b);
                                return true
                            } else {
                                if (r >= m[1] && r <= m[1] + a && p >= m[2] && p <= m[3]) {
                                    var o = this.getAxesVals(n);
                                    this.showAxesResizer("xAxis", m[1] + s, m[1] + this.getAxisFont(o.y) + q, m[2], m[3], "y", "v", "r", o, "", n, d, b);
                                    return true
                                } else {
                                    if (r >= m[0] && r <= m[1] && p >= m[2] - a && p <= m[2]) {
                                        var o = this.getAxesVals(n);
                                        this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + q), m[2] - s, "x", "h", "t", o, "", n, d, b);
                                        return true
                                    } else {
                                        if (r >= m[0] && r <= m[1] && p >= m[3] && p <= m[3] + a) {
                                            var o = this.getAxesVals(n);
                                            this.showAxesResizer("xAxis", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "", n, d, b);
                                            return true
                                        }
                                    }
                                }
                            }
                        } else {
                            if (this.graphOrientation == "vertical") {
                                if (r >= m[0] - a && r <= m[0] && p >= m[2] && p <= m[3]) {
                                    var o = this.getAxesVals(n);
                                    this.showAxesResizer("xAxis", m[0] - (this.getAxisFont(o.y) + q), m[0] - s, m[2], m[3], "y", "v", "l", o, "", n, d, b);
                                    return true
                                } else {
                                    if (r >= m[1] && r <= m[1] + a && p >= m[2] && p <= m[3]) {
                                        var o = this.getAxesVals(n);
                                        if (f == "BarLine") {
                                            this.showAxesResizer("xAxis2", m[1] + s, m[1] + this.getAxisFont(o.y) + q, m[2], m[3], "y", "v", "r", o, "2", n, d, b)
                                        } else {
                                            this.showAxesResizer("xAxis", m[1] + s, m[1] + this.getAxisFont(o.y) + q, m[2], m[3], "y", "v", "r", o, "", n, d, b)
                                        }
                                        return true
                                    }
                                }
                            } else {
                                if (r >= m[0] && r <= m[1] && p >= m[2] - a && p <= m[2]) {
                                    var o = this.getAxesVals(n);
                                    this.showAxesResizer("xAxis", m[0], m[1], m[2] - (this.getAxisFont(o.x) + q), m[2] - s, "x", "h", "t", o, "", n, d, b);
                                    return true
                                } else {
                                    if (r >= m[0] && r <= m[1] && p >= m[3] && p <= m[3] + a) {
                                        var o = this.getAxesVals(n);
                                        if (f == "BarLine") {
                                            this.showAxesResizer("xAxis2", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "2", n, d, b)
                                        } else {
                                            this.showAxesResizer("xAxis", m[0], m[1], m[3] + s, m[3] + this.getAxisFont(o.x) + q, "x", "h", "b", o, "", n, d, b)
                                        }
                                        return true
                                    }
                                }
                            }
                        }
                    }
                    n++
                }
            }
        }
        return false
    };
    this.endAxesResizer = function (a) {
        if (this.axesResizingOn) {
            this.resetInfoSpan(a);
            if (this.resizerEventData.active == "prev" || this.resizerEventData.active == "next") {
                this.moveAxesResizer(a)
            }
            this.drawAxesResizerUpdate(true);
            this.axesResizingOn = false
        } else {
            if (this.resizerType) {
                this.updateResizerEventData();
                this.refreshAxesResizer()
            }
        }
    };
    this.resetAxesResizer = function (b) {
        if (this.axesResizerShow) {
            var a = document.getElementById(this.target + "canvasXpressAxesResize");
            if (a) {
                this.addRemoveAxesResizerListeners("removeEvtListener");
                a.style.display = "none";
                this.resizerEventData = {};
                this.resetInfoSpan(b);
                this.axesResizerShow = false
            }
        }
    };
    this.initializeAxisResizerEvents = function () {
        if (!this.disableEvents) {
            this.addAxesResizeDiv()
        }
    };
    this.initializeAxisResizerEvents()
};
CanvasXpress.prototype.initLinkEvents = function () {
    this.addLinkDiv = function () {
        if (document.getElementById(this.target + "canvasXpressLink")) {
            this.resetLinkDiv();
            return
        }
        var e = document.createElement("span");
        e.style.paddingRight = "5px";
        var a = document.createElement("b");
        a.id = this.target + "canvasXpressLinkTitle";
        a.innerHTML = "";
        var c = document.createElement("img");
        c.id = this.target + "canvasXpressLinkClose";
        c.src = this.imageDir + "cancel1.png";
        c.style.cssFloat = "right";
        c.style.cursor = "default";
        var f = document.createElement("div");
        f.id = this.target + "canvasXpressLink";
        f.className = "draggable";
        f.style.cursor = "move";
        f.style.display = "none";
        f.style.padding = "10px";
        f.style.border = "1px solid " + this.skinBorderColor;
        f.style.backgroundColor = this.skinBackgroundColor;
        f.style.boxShadow = "2px 2px 2px " + this.skinShadowColor;
        f.style.MozBoxShadow = "2px 2px 2px " + this.skinShadowColor;
        f.style.color = this.skinColor;
        f.style.borderRadius = "8px";
        f.style.whiteSpace = "nowrap";
        f.style.position = "absolute";
        f.style.zIndex = 10002;
        e.appendChild(a);
        f.appendChild(e);
        f.appendChild(c);
        f.appendChild(document.createElement("br"));
        var g = document.getElementById("north-wrapper-" + this.target);
        if (f) {
            g.appendChild(f);
            this.addRemoveLinkListeners("addEvtListener")
        }
    };
    this.addRemoveLinkListeners = function (b) {
        var c = document.getElementById(this.target + "canvasXpressLink");
        var a = document.getElementById(this.target + "canvasXpressLinkClose");
        if (c && a) {
            this[b](c, "mousedown", this.registerMousemove, false);
            this[b](c, "touchstart", this.registerMousemove, false);
            this[b](a, "click", this.closeLinkDiv, false)
        }
    };
    this.closeLinkDiv = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.resetLinkDiv();
            return false
        }
    }(this);
    this.resetLinkDiv = function () {
        var a = document.getElementById(this.target + "canvasXpressLink");
        if (a && a.childNodes) {
            while (a.childNodes.length > 3) {
                a.removeChild(a.childNodes[3])
            }
            a.style.display = "none"
        }
    };
    this.showLinkDiv = function (D, b, v) {
        var E = document.getElementById(this.target + "canvasXpressLink");
        var z = document.getElementById(this.target + "canvasXpressLinkTitle");
        var G = false;
        if (E) {
            this.resetLinkDiv();
            var F = this.adjustedCoordinates(D);
            if (F) {
                var f = F.x;
                var c = F.y;
                z.innerHTML = "Links for " + v;
                for (var B = 0; B < b.length; B++) {
                    var C = document.createElement("img");
                    var H = document.createElement("a");
                    var h = b[B].url;
                    var r = b[B].name;
                    var k = b[B].title;
                    var w = b[B].icon;
                    var o = b[B].source;
                    var q = b[B].params;
                    if (h) {
                        H.href = h;
                        G = true
                    } else {
                        if (o && this.data.links && this.data.links[o]) {
                            H.href = this.data.links[o].url;
                            G = true;
                            if (q) {
                                for (var A in q) {
                                    H.href = H.href.replace("$" + A + "$", q[A])
                                }
                            }
                        }
                    }
                    H.innerHTML = r ? r : this.data.links && o && this.data.links[o] && this.data.links[o].name ? this.data.links[o].name : B;
                    H.alt = k ? k : this.data.links && o && this.data.links[o] && this.data.links[o].title ? this.data.links[o].title : "";
                    H.title = H.alt;
                    H.target = "_blank";
                    C.src = w ? w : this.data.links && o && this.data.links[o] && this.data.links[o].icon ? this.data.links[o].icon : this.getPixelImage();
                    C.height = "16px";
                    C.width = "16px";
                    E.appendChild(C);
                    E.appendChild(H);
                    E.appendChild(document.createElement("br"))
                }
                E.style.left = f + "px";
                E.style.top = c + "px";
                E.style.display = G ? "block" : "hidden"
            }
        }
    };
    this.initializeLinkEvents = function () {
        if (!this.disableEvents) {
            this.addLinkDiv()
        }
    };
    this.initializeLinkEvents()
};
CanvasXpress.prototype.initDraggingEvents = function () {
    this.addDragDiv = function () {
        if (document.getElementById(this.target + "canvasXpressDrag")) {
            return
        }
        var a = document.createElement("div");
        a.id = this.target + "canvasXpressDrag";
        a.style.width = "0.5px";
        a.style.height = "0.5px";
        a.style.opacity = 0.5;
        a.style.filter = "alpha(opacity = 50)";
        a.style.backgroundColor = this.skinBackgroundColor;
        a.style.position = "absolute";
        a.style.zIndex = 9000;
        this.canvas.parentNode.appendChild(a)
    };
    this.registerDragNetwork = function (l) {
        var c, j, f;
        var k = this.isEvent(l, true);
        var b = l.target || l.srcElement;
        var a = k[1];
        if (a && a.match(/-legend-/)) {
            if (a.match(/-legend-Nodes/)) {
                this.moveLegend = "Nodes"
            } else {
                if (a.match(/-legend-Edges/)) {
                    this.moveLegend = "Edges"
                } else {
                    if (a.match(/-legend-Decorations/)) {
                        this.moveLegend = "Decorations"
                    } else {
                        this.moveLegend = a.split(/-legend-/)[1]
                    }
                }
            }
        } else {
            if (a && a.match(/-lab$/)) {
                if (l.shiftKey) {
                    j = true
                }
                c = k[0][0]
            } else {
                if (a && a.match(/-dec$/)) {
                    if (l.shiftKey) {
                        c = k[0][0];
                        f = true
                    } else {
                        this.resetDrag(l);
                        this.resetFlags(l)
                    }
                } else {
                    c = k ? k[0][0] : "NaN"
                }
            }
            if (!isNaN(c) && c < this.data.nodes.length) {
                b.style.cursor = "move";
                this.moveNode = true;
                this.moveNodeIndex = c;
                if (j) {
                    this.moveNodeLab = true
                } else {
                    if (f) {
                        this.moveNodeDec = true
                    }
                }
                var d = this.data.nodes[this.moveNodeIndex];
                this.moveNodeW = d.width ? d.width : d.size ? (this.nodeSize * d.size) : this.nodeSize;
                this.moveNodeH = d.height ? d.height : d.size ? (this.nodeSize * d.size) : this.nodeSize;
                if (this.moveNodeLab) {
                    this.moveNodeX = d.labelX != null ? d.labelX - ((this.xMouseDown / this.scaleFactor) - this.offsetX) : 0;
                    this.moveNodeY = d.labelY != null ? d.labelY - ((this.yMouseDown / this.scaleFactor) - this.offsetY) : 0
                } else {
                    if (this.moveNodeDec) {
                        this.moveNodeX = d.decorationsX ? d.decorationsX - ((this.xMouseDown / this.scaleFactor) - this.offsetX) : 0;
                        this.moveNodeY = d.decorationsY ? d.decorationsY - ((this.yMouseDown / this.scaleFactor) - this.offsetY) : 0
                    } else {
                        if (this.is3DNetwork) {
                            this.moveNodeX = d.x3d - ((this.xMouseDown / this.scaleFactor) - this.offsetX);
                            this.moveNodeY = d.y3d - ((this.yMouseDown / this.scaleFactor) - this.offsetY)
                        } else {
                            this.moveNodeX = d.x - ((this.xMouseDown / this.scaleFactor) - this.offsetX);
                            this.moveNodeY = d.y - ((this.yMouseDown / this.scaleFactor) - this.offsetY)
                        }
                    }
                }
            }
        }
        if (this.networkStack.length < 1 || this.networkStack.length - 1 != this.networkStackIndex) {
            var h = this.cloneObject(this.networkStack);
            var m = this.networkStackIndex;
            this.clearNetworkStack();
            for (var g = 0; g < m; g++) {
                this.networkStack.push(this.cloneObject(h[g]))
            }
            this.addToNetworkStack();
            h = false
        }
    };
    this.registerDragGenome = function (b) {
        var a = this.isEvent(b, true);
        if (a && isNaN(a[0][0])) {
            this.moveGenome = a[0][0]
        } else {
            this.moveGenome = false
        }
    };
    this.registerDrag = function (n) {
        if (!n) {
            n = window.event
        }
        if (this.isCanvasResize(n)) {
            this.resizingCanvasOn = true;
            this.hideViewport()
        } else {
            if (!n) {
                return false
            }
            if (!this.touches) {
                this.touches = []
            }
            var a = n.target || n.srcElement;
            var s = this.adjustedCoordinates(n);
            if (s) {
				CanvasXpress.current = a.id;
                var f = s.x;
                var u = s.y;
                var r = 0;
                for (var k = 0; k < this.layoutRows; k++) {
                    for (var h = 0; h < this.layoutCols; h++) {
                        var m = this.layoutComb ? this.layoutParams[r].graphType : this.graphType;
                        var q = this.getBoundsXY(r);
                        if (m.match(/Correlation|Pie|Venn|Stacked|Area/)) {
                            if (this.mobileApp) {
                                if (f >= q[0] && f <= q[1] && u >= q[2] && u <= q[3] || this.moveGenome) {
                                    this.skipClick = false;
                                    this.draggingOn = true;
                                    this.xMouseDown = f;
                                    this.yMouseDown = u;
                                    this.touches.push([f, u, new Date().getTime()]);
                                    return false
                                }
                            } else {
                                return false
                            }
                        } else {
                            if (m == "Genome") {
                                this.registerDragGenome(n)
                            }
                        }
                        if (f >= q[0] && f <= q[1] && u >= q[2] && u <= q[3] || this.moveGenome) {
                            this.skipClick = false;
                            this.draggingOn = true;
                            this.xMouseDown = f;
                            this.yMouseDown = u;
                            this.touches.push([f, u, new Date().getTime()]);
                            var p = document.getElementById(this.target + "canvasXpressDrag");
                            if (m == "Network") {
                                this.registerDragNetwork(n)
                            }
                            if ((!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !n.shiftKey) || (!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && n.shiftKey)) {
                                p.style.left = q[0] + "px"
                            } else {
                                p.style.left = this.xMouseDown + "px"
                            }
                            if ((!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !n.shiftKey) || (!m.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && n.shiftKey) || m == "Genome") {
                                p.style.top = q[2] + "px"
                            } else {
                                p.style.top = this.yMouseDown + "px"
                            }
                            if (this.layoutValid) {
                                this.layoutValidR = k;
                                this.layoutValidC = h;
                                this.layoutValidN = r
                            }
                            return false
                        } else {
                            if (f >= q[4] && f <= q[5] && u >= q[6] && u <= q[7]) {
                                var b = this.isEvent(n);
                                if (b) {
                                    this.skipClick = false;
                                    this.draggingOn = true;
                                    this.xMouseDown = f;
                                    this.yMouseDown = u;
                                    this.touches.push([f, u, new Date().getTime()]);
                                    var p = document.getElementById(this.target + "canvasXpressDrag");
                                    if (b[0].match("Smp")) {
                                        this.moveSmp = b[0];
                                        if (m.match(/Heatmap/) || this.graphOrientation == "horizontal") {
                                            p.style.left = q[4] + "px";
                                            p.style.width = (q[5] - q[4]) + "px";
                                            p.style.height = "3px"
                                        } else {
                                            p.style.width = "3px";
                                            p.style.top = q[6] + "px";
                                            p.style.height = (q[7] - q[6]) + "px"
                                        }
                                    } else {
                                        if (b[0].match("Var")) {
                                            this.moveVar = b[0];
                                            p.style.width = "3px";
                                            p.style.top = q[6] + "px";
                                            p.style.height = (q[7] - q[6]) + "px"
                                        }
                                    }
                                    return false
                                }
                            }
                        }
                        r++
                    }
                }
                return false
            }
        }
    };
    this.updateDragScatter3D = function (b, f, e, d, k) {

        if (this.mobileApp && this.touches && this.touches.length > 1) {
            return
        }
        var g = this;
        var h = this.mobileApp ? 100 : 1;
        var a = function () {
            clearTimeout(a);
            var i = g.xMouseDown;
            var n = g.yMouseDown;
            var c = b;
            var m = f;
            var j = g.lineLength(i, n, c, m);
            var p = g.layoutComb ? g.layoutParams[k].x : g.x;
            var l = g.layoutComb ? g.layoutParams[k].y : g.y;
            var r = ((c - i) * g.rotationSensitivity) / p;
            var q = ((m - n) * g.rotationSensitivity) / l;
            var o = (j * g.rotationSensitivity) / p;
            g.xRotate -= r;
            g.yRotate += q;
            g.zRotate -= o;
            g.draw();
            g.skipClick = true
        };
        setTimeout(a, h)
    };
    
    this.updateDrag = function (k) {
	
        if (this.draggingOn) {
            if (!k) {
                k = window.event
            }
            var u = this.adjustedCoordinates(k);
            if (this.resetOn) {
                this.resetOn = false;
                this.stopEvent(k);
                return
            }
            if (u) {
                this.touchEvent = "drag";
                var a = u.x;
                var v = u.y;
                var f = this.layoutValidR;
                var b = this.layoutValidC;
                var o = this.layoutValidN || 0;
                var h = this.layoutComb ? this.layoutParams[o].graphType : this.graphType;
                var q = this.layoutComb ? this.layoutParams[o].varIndices : this.varIndices;
                var s;
                if (this.isGroupedData) {
                    s = this.layoutComb ? this.layoutParams[o].grpIndices : this.grpIndices
                } else {
                    s = this.layoutComb ? this.layoutParams[o].smpIndices : this.smpIndices
                }
                if (h.match(/Correlation|Pie|Venn|Stacked|Area/)) {
                    if (this.mobileApp) {
                        this.movingOn = true;
                        this.resetOn = false
                    }
                    return false
                }
                if ((h == "Scatter3D" && !k.shiftKey) || this.is3DPlot) {
                    this.updateDragScatter3D(a, v, f, b, o)
                } else {
                    if (h == "Network" && ((this.moveNode || this.moveLegend) || (!k.ctrlKey && !k.shiftKey && !k.altKey))) {
                        this.updateDragNetwork(k, a, v, f, b, o)
                    } else {
                        if (h == "Genome" && (this.moveGenome || !k.shiftKey)) {
                            this.updateDragGenome(k, a, v, f, b, o)
                        } else {
                            if (this.moveVar || this.moveSmp) {
                                var n = this.getBoundsXY(o);
                                var m = document.getElementById(this.target + "canvasXpressDrag");
                                this.skipClick = true;
                                if (a >= n[4] && a <= n[5] && v >= n[6] && v <= n[7]) {
                                    if (this.moveSmp) {
                                        if (h.match(/Heatmap/) || this.graphOrientation == "horizontal") {
                                            m.style.top = v + "px"
                                        } else {
                                            m.style.left = a + "px"
                                        }
                                    } else {
                                        m.style.left = a + "px"
                                    }
                                }
                            } else {
                                if (this.mobileApp && this.touches && this.touches.length > 1) {
                                    return
                                }
                                var p;
                                if (this.varIndicesStart > 0 || this.smpIndicesStart > 0) {
                                    p = true
                                } else {
                                    if (this.varIndicesStart == 0 && this.startingVarIndices && this.startingVarIndices[o]) {
                                        if (this.varIndicesStart + q.length < this.startingVarIndices[o].length) {
                                            p = true
                                        } else {
                                            p = false
                                        }
                                    } else {
                                        if (this.smpIndicesStart == 0 && this.startingSmpIndices && this.startingSmpIndices[o]) {
                                            if (this.smpIndicesStart + s.length < this.startingSmpIndices[o].length) {
                                                p = true
                                            } else {
                                                p = false
                                            }
                                        } else {
                                            p = false
                                        }
                                    }
                                }
                                var n = this.getBoundsXY(o);
                                var m = document.getElementById(this.target + "canvasXpressDrag");
                                this.skipClick = true;
                                if ((!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && !k.shiftKey) || (!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && k.shiftKey)) {
                                    m.style.width = (n[1] - n[0]) + "px"
                                } else {
                                    if (a > this.xMouseDown) {
                                        if (a > n[1]) {
                                            m.style.width = (n[1] - this.xMouseDown) + "px"
                                        } else {
                                            m.style.width = (a - this.xMouseDown) + "px"
                                        }
                                    } else {
                                        if (a < n[0]) {
                                            m.style.left = n[0] + "px";
                                            m.style.width = (this.xMouseDown - n[0]) + "px"
                                        } else {
                                            m.style.left = a + "px";
                                            m.style.width = (this.xMouseDown - a) + "px"
                                        }
                                    }
                                }
                                if ((!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation != "vertical" && !k.shiftKey) || (!h.match(/Scatter|Heatmap|Network|Genome|Circular/) && this.graphOrientation == "vertical" && k.shiftKey) || h == "Genome") {
                                    m.style.height = (n[3] - n[2]) + "px"
                                } else {
                                    if (v > this.yMouseDown) {
                                        if (v > n[3]) {
                                            m.style.height = (n[3] - this.yMouseDown) + "px"
                                        } else {
                                            m.style.height = (v - this.yMouseDown) + "px"
                                        }
                                    } else {
                                        if (v < n[2]) {
                                            m.style.top = n[2] + "px";
                                            m.style.height = (this.yMouseDown - n[2]) + "px"
                                        } else {
                                            m.style.top = v + "px";
                                            m.style.height = (this.yMouseDown - v) + "px"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.movingOn = true;
            this.resetOn = false
        }
    };
    this.endDrag = function (z) {
        if (this.draggingOn) {
            var b = this.layoutComb ? this.layoutParams[this.layoutValidN].graphType : this.graphType;
            if (b.match(/Correlation|Pie|Venn|Stacked|Area|Circular/)) {
                return false
            }
            if (!z) {
                z = window.event
            }
            var j = document.getElementById(this.target);
            if (j) {
                j.style.cursor = "default";
                var w = z.target || z.srcElement;
                if (w && w.style) {
                    w.style.cursor = "default"
                }
            }
            this.panningGlobalX += this.panningX;
            this.panningGlobalY += this.panningY;
            this.panningX = 0;
            this.panningY = 0;
            if ((b == "Scatter3D" && !z.shiftKey) || this.is3DPlot) {
                this.resetDrag(z)
            }
        } else {
            this.resetDrag(z)
        }
    };
    this.validateMinMax = function (b, a) {
        if (!isNaN(b) && !isNaN(a)) {
            if (b > a) {
                return false
            }
            return true
        } else {
            return false
        }
    };
    this.setOriginalIndices = function (f, e, a, d) {
        if (!e) {
            e = this.layoutComb ? this.layoutParams[f].varIndices : this.varIndices
        }
        if (!a) {
            if (this.isGroupedData) {
                a = this.layoutComb ? this.layoutParams[f].grpIndices : this.grpIndices
            } else {
                a = this.layoutComb ? this.layoutParams[f].smpIndices : this.smpIndices
            }
        }
        if (d) {
            this.startingVarIndices = [];
            this.startingSmpIndices = []
        }
        if (!this.startingVarIndices) {
            this.startingVarIndices = []
        }
        if (!this.startingSmpIndices) {
            this.startingSmpIndices = []
        }
        if (!this.startingVarIndices[f]) {
            this.startingVarIndices[f] = [];
            for (var b = 0; b < e.length; b++) {
                this.startingVarIndices[f][b] = e[b]
            }
        }
        if (!this.startingSmpIndices[f]) {
            this.startingSmpIndices[f] = [];
            for (var b = 0; b < a.length; b++) {
                this.startingSmpIndices[f][b] = a[b]
            }
        }
    };
    this.handleDragEventScatter = function (z, d, A, y, l, w, k) {
        this.selectDataPoint = [];
        var a = {
            v: {},
            s: {}
        };
        var p = 0;
        if (z.shiftKey) {
            for (var u = 0; u < this.dataEvent.length; u++) {
                var n = this.dataEvent[u][0];
                var v = this.dataEvent[u][1];
                var m = this.dataEvent[u][2];
                if (this.isObjectInsideArea(v, m, y, l, w, k)) {
                    this.addRemoveToSelectedDataPoints(d, n);
                    a.v[n.shift()] = 1;
                    for (var t = 0; t < n.length; t++) {
                        a.s[n[t]] = 1
                    }
                    p++
                }
            }
            if (p > 0) {
                this.isSelectDataPoints = p;
                this.draw();
                if (this.showDataTableOnSelect) {
                    var r = [];
                    var x = [];
                    for (u in a.v) {
                        r.push(parseInt(u))
                    }
                    for (u in a.s) {
                        x.push(parseInt(u))
                    }
                    r.sort(function (e, c) {
                        return (e - c)
                    });
                    x.sort(function (e, c) {
                        return (e - c)
                    });
                    var q = this.extractDataObject(x, r);
                    this.updateDataTable(q)
                }
            }
        } else {
            var q = this.layoutComb ? this.layoutParams[A] : this;
            var h = q.xAxisMin + ((y - (this.marginLeft + q.offsetX + q.left)) / q.xAxisUnit);
            var g = q.xAxisMin + ((w - (this.marginLeft + q.offsetX + q.left)) / q.xAxisUnit);
            var b = q.yAxisMax - ((l - (this.marginTop + q.offsetY + q.top)) / q.yAxisUnit);
            var f = q.yAxisMax - ((k - (this.marginTop + q.offsetY + q.top)) / q.yAxisUnit);
            if (this.validateMinMax(h, g) && this.validateMinMax(f, b)) {
                this.setMinX = h;
                this.setMaxX = g;
                this.setMaxY = b;
                this.setMinY = f;
                this.draw()
            }
        }
    };
    this.handleDragEvent = function (h, b, f, a, d) {
        var i = this.layoutComb ? this.layoutValidN : 0;
        var g = this.layoutComb ? this.layoutParams[i].graphType : this.graphType;
        if (g == "Network") {
            this.handleDragEventNetwork(h, b, f, a, d)
        } else {
            if (g == "Heatmap" && !this.moveVar && !this.moveSmp) {
                this.handleDragEventHeatmap(i, b, f, a, d)
            } else {
                if (g.match(/Scatter/)) {
                    this.handleDragEventScatter(h, g, i, b, f, a, d)
                } else {
                    if (g == "Genome") {
                        this.handleDragEventGenome(i, b, f, a, d)
                    } else {
                        this.handleDragEventOneDimension(h, g, i, b, f, a, d)
                    }
                }
            }
        }
    };
    this.resetDrag = function (a) {
        var b = document.getElementById(this.target + "canvasXpressDrag");
        if (b) {
            b.style.left = "0px";
            b.style.top = "0px";
            b.style.width = "0px";
            b.style.height = "0px"
        }
    };
    this.initializeDraggingEvents = function () {
        if (!this.disableEvents) {
            this.addDragDiv()
        }
    };
    this.initializeDraggingEvents()
};
CanvasXpress.prototype.initInfoEvents = function () {
    this.addTooltipDiv = function (l, k, j) {
        var g = document.createElement("div");
        var a = 0;
        var b = this.target + "canvasXpressTooltipDiv" + a;
        var o = document.getElementById(this.target + "canvasXpressInfo");
        if (o && o.style.display != "none") {
            k = parseInt(o.style.left);
            j = parseInt(o.style.top)
        }
        var f = document.getElementById(b);
        while (f) {
            a++;
            b = this.target + "canvasXpressTooltipDiv" + a;
            f = document.getElementById(b)
        }
        g.id = b;
        g.className = "draggable";
        g.style.fontFamily = "arial,tahoma,sans-serif";
        g.style.cursor = "move";
        g.style.color = this.skinColor;
        g.style.backgroundColor = this.skinBackgroundColor;
        g.style.margin = "2px 3px";
        g.style.padding = "2px 3px";
        g.style.whiteSpace = "nowrap";
        g.style.fontSize = "x-small";
        g.style.border = "1px solid " + this.skinBorderColor;
        g.style.boxShadow = "2px 2px 2px " + this.skinShadowColor;
        g.style.MozBoxShadow = "2px 2px 2px " + this.skinShadowColor;
        g.style.borderRadius = "3px";
        g.style.position = "absolute";
        g.style.display = "block";
        g.style.left = k + "px";
        g.style.top = j + "px";
        g.style.zIndex = 29010;
        var h = document.createElement("img");
        h.id = b + "Close";
        h.src = this.imageDir + "cancel1.png";
        h.alt = "Close";
        h.title = "Close";
        h.style.margin = "2px";
        h.style.cssFloat = "right";
        h.style.height = "10px";
        h.style.cursor = "default";
        var m = document.createElement("div");
        m.id = b + "HTML";
        m.style.clear = "both";
        m.innerHTML = l || "";
        g.appendChild(h);
        g.appendChild(m);
        document.body.appendChild(g);
        this.resetInfoSpan();
        return g
    };
    this.addRemoveTooltipDivsListeners = function (a, b) {
        var e = b.firstChild;
        this[a](b, "mousedown", this.registerMousemove, false);
        this[a](b, "touchstart", this.registerMousemove, false);
        this[a](e, "click", this.closeTooltipDiv, false)
    };
    this.showTooltipDiv = function (c, g) {
        var b = this.adjustedCoordinates(c);
        if (b) {
            var a = b.x;
            var h = c ? b.y : b.y + 25;
            var f = this.addTooltipDiv(g, a, h);
            this.addRemoveTooltipDivsListeners("addEvtListener", f)
        }
    };
    this.closeTooltipDiv = function (a) {
        return function (c) {
            if (!c) {
                c = window.event
            }
            var b = c.target || c.srcElement;
            if (b) {
                var f = b.parentNode;
                a.addRemoveTooltipDivsListeners("removeEvtListener", f);
                f.parentNode.removeChild(f)
            }
            return false
        }
    }(this);
    this.resetTooltipDivs = function () {
        var c = 0;
        var a = this.target + "canvasXpressTooltipDiv" + c;
        var b = document.getElementById(a);
        while (b) {
            this.addRemoveTooltipDivsListeners("removeEvtListener", b);
            b.parentNode.removeChild(b);
            c++;
            a = this.target + "canvasXpressTooltipDiv" + c;
            b = document.getElementById(a)
        }
    };
    this.addInfoSpan = function () {
        if (document.getElementById(this.target + "canvasXpressInfo")) {
            this.resetInfoSpan();
            return
        }
        var a = document.createElement("span");
        a.id = this.target + "canvasXpressInfo";
        a.style.color = this.skinColor;
        a.style.backgroundColor = this.skinBackgroundColor;
        a.style.margin = "2px 3px";
        a.style.padding = "2px 3px";
        a.style.fontFamily = "arial,tahoma,sans-serif";
        a.style.whiteSpace = "nowrap";
        a.style.fontSize = "x-small";
        a.style.border = "1px solid " + this.skinBorderColor;
        a.style.boxShadow = "2px 2px 2px " + this.skinShadowColor;
        a.style.MozBoxShadow = "2px 2px 2px " + this.skinShadowColor;
        a.style.borderRadius = "3px";
        a.style.position = "absolute";
        a.style.display = "none";
        a.style.zIndex = 29010;
        document.body.appendChild(a)
    };
    this.resetInfoSpan = function (d, c) {
        var b = document.getElementById(this.target + "canvasXpressInfo");
        if (b) {
            var a = new Date().getTime() - this.infoStartTime;
            if (a > this.infoTimeIn || c) {
                b.style.left = "0px";
                b.style.top = "0px";
                b.style.display = "none";
                b.innerHTML = ""
            }
        }
    };
    this.showInfoSpan = function (c, j) {
        if (this.draggingOn || this.remoteUpdating) {
            return
        }
        var l = new Date().getTime() - this.infoStartTime;
        var m = document.getElementById(this.target + "canvasXpressInfo");
        if (m && j && j != "" && l > this.infoTimeIn) {
            var k = this.adjustedCoordinates(c, m);
            if (k) {
                var f = k.x;
                var d = c ? k.y : k.y + 25;
                if (!isNaN(j)) {
                    j = j.toString()
                }
                if (j.match(/\w/)) {
                    m.innerHTML = j;
                    m.style.left = (f + 10) + "px";
                    m.style.top = (d - 20) + "px";
                    m.style.display = "inline";
                    m.style.zIndex = parseInt(m.style.zIndex);
                    var i = parseInt(m.clientWidth);
                    var a = parseInt(m.clientHeight);
                    if (i < window.innerWidth && i > (window.innerWidth + window.pageXOffset) - f && (i + 5) < (f - window.pageXOffset)) {
                        m.style.left = (f - (i + 5)) + "px";
                        m.style.left = (f - (parseInt(m.clientWidth) + 5)) + "px"
                    }
                    if (a < window.innerHeight && a > (window.innerHeight + window.pageYOffset) - d && (a - 15) < (d - window.pageYOffset)) {
                        m.style.top = (d - (a - 15)) + "px";
                        m.style.top = (d - (parseInt(m.clientHeight) - 15)) + "px"
                    }
                    this.infoStartTime = new Date().getTime();
                    var b = this;
                    var g = function () {
                        this.update = function () {
                            var h = new Date().getTime();
                            if (h - b.infoStartTime > b.infoTimeOut) {
                                b.resetInfoSpan();
                                clearInterval(e)
                            }
                        };
                        var e = setInterval(this.update, 100)
                    };
                    g.call()
                }
            }
        }
    };
    this.initializeInfoEvents = function () {
        if (!this.disableEvents) {
            this.addInfoSpan()
        }
    };
    this.initializeInfoEvents()
};
CanvasXpress.prototype.initKeyEvents = function () {
	this.getKeyCode = function (a) {
        if (a) {
			if ((a.charCode) && (a.keyCode == 0)) {
                return a.charCode
            } else {
                return a.keyCode
            }
        }
    };
    this.registerKey = function (b) {
	
        if (!b) {
            b = window.event
        }
        var a = b.target || b.srcElement;
        var d = this.getKeyCode(b);
        if (this.eventKeys || (b.ctrlKey && b.altKey && d == 107)) {
            if (d == 27) {
                if (this.animationOn) {
                    this.animationOn = false;
                    return false
                }
                this.masterReset(b)
            } else {
                if (this.configuringOn) {
                    return
                } else {
                    if (d == 16 && this.helpKeyEvents) {
                        if (b.ctrlKey && b.altKey) {
                            this.showCtrlShiftAltShorts()
                        } else {
                            if (b.ctrlKey) {
                                this.showCtrlShiftShorts()
                            } else {
                                if (b.altKey) {
                                    this.showShiftAltShorts()
                                } else {
                                    this.showShiftShorts()
                                }
                            }
                        }
                    } else {
                        if (d == 17 && this.helpKeyEvents) {
                            
                        } else {
                            if ((d == 18 || d == 224) && this.helpKeyEvents) {
                                
                            } else {
                                if (b.ctrlKey && b.shiftKey) {
                                    if (d >= 33 && d <= 40) {
                                        this.arrowMove(d, true)
                                    } else {
                                        if (d == 80 && !this.keyOn) {
                                            this.keyOn = true;
                                            this.print()
                                        } else {
                                            if (d == 88 && !this.keyOn) {
                                                
                                            } else {
                                                if (d == 90 && this.graphType == "Network" && !this.keyOn) {
                                                    
                                                }
                                            }
                                        }
                                    }
                                    document.defaultAction = true
                                } else {
                                    if (b.ctrlKey && b.altKey) {
                                        if (d == 80 && !this.keyOn) {
                                            this.keyOn = true;
                                            this.print()
                                        }
                                        document.defaultAction = true
                                    } else {
                                        if (b.shiftKey && b.altKey) {
                                            
                                        } else {
                                            if (b.ctrlKey) {
                                                if (d >= 33 && d <= 40) {
													if (d == 36 && this.isSelectDataPoints && this.graphType == "Scatter3D") {
                                                        this.showHideSelectedDataPoint(b, d)
                                                    } else {
														this.arrowMove(d)
                                                    }
                                                } else {
                                                    if (d == 80 && !this.keyOn) {
														this.keyOn = true;
														this.print()
                                                    }
                                                }
                                                document.defaultAction = true
                                            } else {
                                                if (d == 107 || d == 109 || d == 61 || d == 187 || d == 189) {
                                                    if (this.eventPlusMinusKeys && !/input|textarea|select/i.test(a.tagName)) {
                                                        if (d == 109 || d == 189) {
                                                            this.handleWheelEvent(b, - 1)
                                                        } else {
                                                            this.handleWheelEvent(b, 1)
                                                        }
                                                    }
                                                } else {
                                                    if (d >= 33 && d <= 40) {
                                                        if (this.eventArrowKeys && !/input|textarea|select/i.test(a.tagName)) {
                                                            this.handlePanning(b, d)
                                                        }
                                                    } else {
                                                        if (b.shiftKey) {
                                                            document.defaultAction = true
                                                        } else {
                                                            if (b.altKey) {
                                                                document.defaultAction = true
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.handlePanning = function (f, j) {
		if (this.graphType == "Network") {
            this.cancelEvent(f);
            var m = Math.abs(this.x * this.panningStep);
            var k = Math.abs(this.y * this.panningStep);
            if (j == 33) {
                this.panningY -= k * 5
            } else {
                if (j == 34) {
                    this.panningY += k * 5
                } else {
                    if (j == 35) {
                        this.panningX = m * 20;
                        this.panningY = k * 20
                    } else {
                        if (j == 36) {
                            this.panningX = 0;
                            this.panningY = 0
                        } else {
                            if (j == 37) {
                                this.panningX -= m
                            } else {
                                if (j == 38) {
                                    this.panningY -= k
                                } else {
                                    if (j == 39) {
                                        this.panningX += m
                                    } else {
                                        if (j == 40) {
                                            this.panningY += k
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
			this.draw(false, false, false, true)
        } 
		else {
            if (this.graphType == "Genome") {
                var p = this.genomeResolution == "high" ? 1 : this.xAxisRange * this.panningStep;
                if (this.setMin == null) {
                    this.setMin = this.xAxisMin
                }
                if (this.setMax == null) {
                    this.setMax = this.xAxisMax
                }
                this.cancelEvent(f);
                if (j == 37 || j == 38) {
                    this.setMin -= p;
                    this.setMax -= p
                } else {
                    if (j == 39 || j == 40) {
                        this.setMin += p;
                        this.setMax += p
                    } else {
                        if (j == 33) {
                            this.setMin += this.xAxisRange * 0.95;
                            this.setMax += this.xAxisRange * 0.95
                        } else {
                            if (j == 34) {
                                this.setMin -= this.xAxisRange * 0.95;
                                this.setMax -= this.xAxisRange * 0.95
                            } else {
                                if (j == 35) {
                                    this.setMax = null
                                } else {
                                    if (j == 36) {
                                        this.setMin = null
                                    }
                                }
                            }
                        }
                    }
                }
                this.draw()
            } else {
                if (this.graphType == "Heatmap") {
                    this.cancelEvent(f);
                    this.resetAxesResizer(f);
                    var g = this.layoutComb ? this.layoutValidN : 0;
                    var q;
                    var n = this.layoutComb ? this.layoutParams[g].varIndices : this.varIndices;
                    if (this.isGroupedData) {
                        q = this.layoutComb ? this.layoutParams[g].grpIndices : this.grpIndices
                    } else {
                        q = this.layoutComb ? this.layoutParams[g].smpIndices : this.smpIndices
                    }
                    this.setOriginalIndices(j, n, q);
                    if (j == 35) {
                        return false
                    } else {
                        if (j == 36) {
                            this.varIndicesStart = -1;
                            this.smpIndicesStart = -1;
                            this.varIndices = this.startingVarIndices[g];
                            if (this.isGroupedData) {
                                this.grpIndices = this.startingSmpIndices[g]
                            } else {
                                this.smpIndices = this.startingSmpIndices[g]
                            }
                            this.draw()
                        } else {
                            if (j == 37) {
                                if (this.varIndicesStart > 0) {
                                    this.varIndices.unshift(this.startingVarIndices[g][this.varIndicesStart - 1]);
                                    this.varIndices.pop();
                                    this.varIndicesStart--;
                                    this.draw()
                                }
                            } else {
                                if (j == 38 || j == 33) {
                                    var o = j == 33 ? 5 : 1;
                                    var h = false;
                                    var a = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                    for (var b = 0; b < o; b++) {
                                        if (this.smpIndicesStart > 0) {
                                            a.unshift(this.startingSmpIndices[g][this.smpIndicesStart - 1]);
                                            a.pop();
                                            this.smpIndicesStart--;
                                            h = true
                                        }
                                    }
                                    if (h) {
                                        this.draw()
                                    }
                                } else {
                                    if (j == 39) {
                                        if (this.varIndicesStart > -1 && this.varIndicesStart + n.length < this.startingVarIndices[g].length) {
                                            this.varIndices.push(this.startingVarIndices[g][this.varIndicesStart + this.varIndices.length]);
                                            this.varIndices.shift();
                                            this.varIndicesStart++;
                                            this.draw()
                                        }
                                    } else {
                                        if (j == 40 || j == 34) {
                                            var o = j == 34 ? 5 : 1;
                                            var h = false;
                                            var a = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                            for (var b = 0; b < o; b++) {
                                                if (this.smpIndicesStart > -1 && this.smpIndicesStart + q.length < this.startingSmpIndices[g].length) {
                                                    a.push(this.startingSmpIndices[g][this.smpIndicesStart + a.length]);
                                                    a.shift();
                                                    this.smpIndicesStart++;
                                                    h = true
                                                }
                                            }
                                            if (h) {
                                                this.draw()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked/)) {
                        this.cancelEvent(f);
                        this.resetAxesResizer(f);
                        var g = this.layoutComb ? this.layoutValidN : 0;
                        var q;
                        var h = false;
                        var n = this.layoutComb ? this.layoutParams[g].varIndices : this.varIndices;
                        if (this.isGroupedData) {
                            q = this.layoutComb ? this.layoutParams[g].grpIndices : this.grpIndices
                        } else {
                            q = this.layoutComb ? this.layoutParams[g].smpIndices : this.smpIndices
                        }
                        this.setOriginalIndices(g, n, q);
                        if (j == 35 || j == 36) {
                            return false
                        } else {
                            if (j == 37 || j == 38 || j == 33) {
                                var o = j == 33 ? 5 : 1;
                                for (var b = 0; b < o; b++) {
                                    if (this.smpIndicesStart > 0) {
                                        this.smpIndicesStart--;
                                        q.unshift(this.startingSmpIndices[g][this.smpIndicesStart]);
                                        q.pop();
                                        h = true
                                    }
                                }
                            } else {
                                if (j == 39 || j == 40 || j == 34) {
                                    var o = j == 34 ? 5 : 1;
                                    for (var b = 0; b < o; b++) {
                                        if (this.smpIndicesStart + q.length < this.startingSmpIndices[g].length) {
                                            q.push(this.startingSmpIndices[g][this.smpIndicesStart + q.length]);
                                            q.shift();
                                            this.smpIndicesStart++;
                                            h = true
                                        }
                                    }
                                }
                            }
                        }
                        if (h) {
                            this.draw()
                        }
                    }
                }
            }
        }
        return false
    };
    this.showCtrlShiftAltShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Ctrl + Shift + Alt</th></tr>";
        a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showCtrlShiftShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Shift + Ctrl</th></tr>";
        if (this.graphType == "Network") {
            if (this.is3DNetwork) {
                a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (this.rotationStep * 3) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (this.rotationStep * 3) + "&deg; continuously</td></tr>"
            } else {
                a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 3) + "&deg; continuously</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (this.rotationStep * 3) + "&deg; continuously</td></tr>"
            }
        } else {
            if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                if (this.type2D == "XYZ") {
                    if (this.xAxis.length > 1) {
                        a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes continuously (1x)</td></tr>";
                        a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes continuously (2x)</td></tr>"
                    }
                } else {
                    if (this.type2D == "XY") {
                        if (this.zAxis.length > 1) {
                            a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis continuously (1x)</td></tr>";
                            a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis continuously (2x)</td></tr>"
                        }
                    } else {
                        if (this.type2D == "X") {
                            if (this.yAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes continuously (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes continuously (2x)</td></tr>"
                            }
                        } else {
                            if (this.xAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes continuously (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes continuously (2x)</td></tr>"
                            }
                        }
                    }
                }
            } else {
                if (this.graphType == "Scatter3D") {
                    a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Rotate continuously</td></tr>";
                    a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Rotate continuously</td></tr>"
                }
            }
        }
        a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showCtrlAltShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Ctrl + Alt</th></tr>";
        a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showShiftAltShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Shift + Alt</th></tr>";
        a += "<tr><td class=k>2</td><td class=d>Scatter2D</td></tr>";
        a += "<tr><td class=k>3</td><td class=d>Scatter3D</td></tr>";
        a += "<tr><td class=k>4</td><td class=d>ScatterBubble2D</td></tr>";
        a += "<tr><td class=k>A</td><td class=d>Area</td></tr>";
        a += "<tr><td class=k>B</td><td class=d>Bar</td></tr>";
        a += "<tr><td class=k>C</td><td class=d>BarLine</td></tr>";
        a += "<tr><td class=k>D</td><td class=d>Dotplot</td></tr>";
        a += "<tr><td class=k>G</td><td class=d>Genome</td></tr>";
        a += "<tr><td class=k>H</td><td class=d>Heatmap</td></tr>";
        a += "<tr><td class=k>I</td><td class=d>Boxplot</td></tr>";
        a += "<tr><td class=k>L</td><td class=d>Line</td></tr>";
        a += "<tr><td class=k>M</td><td class=d>Candlestick</td></tr>";
        a += "<tr><td class=k>N</td><td class=d>Network</td></tr>";
        a += "<tr><td class=k>P</td><td class=d>Pie</td></tr>";
        a += "<tr><td class=k>R</td><td class=d>Circular</td></tr>";
        a += "<tr><td class=k>S</td><td class=d>Stacked</td></tr>";
        a += "<tr><td class=k>T</td><td class=d>StackedPercent</td></tr>";
        a += "<tr><td class=k>U</td><td class=d>StackedLine</td></tr>";
        a += "<tr><td class=k>W</td><td class=d>StackedPercentLine</td></tr>";
        a += "<tr><td class=k>V</td><td class=d>Venn</td></tr>";
        a += "<tr><td class=k>X</td><td class=d>Correlation</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showCtrlShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Ctrl</th></tr>";
        if (this.graphType == "Network") {
            if (this.is3DNetwork) {
                a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (this.rotationStep * 3) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (this.rotationStep * 3) + "&deg;</td></tr>"
            } else {
                a += "<tr><td class=k>&rarr; or &darr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>&larr; or &uarr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 3) + "&deg;</td></tr>";
                a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise " + (this.rotationStep * 3) + "&deg;</td></tr>"
            }
            a += "<tr><td class=k>click</td><td class=d>Select/Unselect node</td></tr>";
            if (this.isSelectNodes) {
                a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
                a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
                a += "<tr><td class=k>Home</td><td class=d>Show connected nodes to slected nodes</td></tr>";
                a += "<tr><td class=k>t</td><td class=d>Align top</td></tr>";
                a += "<tr><td class=k>r</td><td class=d>Align right</td></tr>";
                a += "<tr><td class=k>b</td><td class=d>Align bottom</td></tr>";
                a += "<tr><td class=k>l</td><td class=d>Align left</td></tr>";
                a += "<tr><td class=k>v</td><td class=d>Distribute verticaly</td></tr>";
                a += "<tr><td class=k>h</td><td class=d>Distribute Horizontaly</td></tr>";
                a += "<tr><td class=k>z</td><td class=d>Undo</td></tr>";
                a += "<tr><td class=k>y</td><td class=d>Redo</td></tr>"
            }
        } else {
            if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                if (this.type2D == "XYZ") {
                    if (this.xAxis.length > 1) {
                        a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X, Y and Z axes (1x)</td></tr>";
                        a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X, Y and Z axes (2x)</td></tr>"
                    }
                } else {
                    if (this.type2D == "XY") {
                        if (this.zAxis.length > 1) {
                            a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update sample in Z axis (1x)</td></tr>";
                            a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update sample in Z axis (2x)</td></tr>"
                        }
                    } else {
                        if (this.type2D == "X") {
                            if (this.yAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in Y and Z axes (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in Y and Z axes (2x)</td></tr>"
                            }
                        } else {
                            if (this.xAxis.length > 1) {
                                a += "<tr><td class=k>&rarr; or &darr; or &larr; or &uarr;</td><td class=d>Update samples in X and Z axes (1x)</td></tr>";
                                a += "<tr><td class=k>PgUp or PgDn</td><td class=d>Update samples in X and Z axes (2x)</td></tr>"
                            }
                        }
                    }
                }
                if (this.isSelectDataPoints) {
                    a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
                    a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>"
                }
            } else {
                if (this.graphType == "Scatter3D") {
                    a += "<tr><td class=k>&rarr;</td><td class=d>Rotate clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>&larr;</td><td class=d>Rotate anti-clockwise " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>&darr;</td><td class=d>Rotate forward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>&uarr;</td><td class=d>Rotate backward " + (this.rotationStep * 1) + "&deg;</td></tr>";
                    a += "<tr><td class=k>PgUp</td><td class=d>Rotate anti-clockwise and backward " + (this.rotationStep * 3) + "&deg;</td></tr>";
                    a += "<tr><td class=k>PgDn</td><td class=d>Rotate clockwise and forward " + (this.rotationStep * 3) + "&deg;</td></tr>";
                    a += "<tr><td class=k>click</td><td class=d>Select/Unselect data points</td></tr>";
                    if (this.isSelectDataPoints) {
                        a += "<tr><td class=k>Delete</td><td class=d>Hide selected nodes</td></tr>";
                        a += "<tr><td class=k>Insert</td><td class=d>Show selected-hidden nodes</td></tr>";
                        a += "<tr><td class=k>Home</td><td class=d>Zoom to selected nodes</td></tr>"
                    }
                } else {
                    if (this.isSegregable()) {}
                }
            }
        }
        a += "<tr><td class=k>P</td><td class=d>Print</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showShiftShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Shift</th></tr>";
        if (this.isSegregable()) {
            a += "<tr><td class=k>Click and Drag</td><td class=d>Select Samples</td></tr>"
        } else {
            a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>"
        }
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.showAltShorts = function () {
        var a = "<table class=shorts>";
        a += "<tr><th colspan=2>Alt</th></tr>";
        a += "<tr><td class=k>&nbsp;</td><td class=d>&nbsp;</td></tr>";
        a += "</table>";
        this.showInfoSpan(false, a)
    };
    this.arrowMove = function (j, b) {
		var e = this.graphType;
        if (this.is3DPlot) {
            e = "Scatter3D;"
        }
		
        switch (e) {
            case "Scatter3D":
                if (j == 33) {
                    this.xRotate += (this.rotationStep * 3);
                    this.yRotate -= (this.rotationStep * 3)
                } 
				else {
                    if (j == 34) {
                        this.xRotate -= (this.rotationStep * 3);
                        this.yRotate += (this.rotationStep * 3)
                    } else {
                        if (j == 35) {
                            this.xRotate = 0;
                            this.yRotate = 0;
                            this.zRotate = 45
                        } else {
                            if (j == 36) {
                                this.xRotate = 45;
                                this.yRotate = 0;
                                this.zRotate = 0
                            } else {
                                if (j == 37) {
                                    this.xRotate += this.rotationStep
                                } else {
                                    if (j == 38) {
                                        this.yRotate -= this.rotationStep
                                    } else {
                                        if (j == 39) {
                                            this.xRotate -= this.rotationStep
                                        } else {
                                            if (j == 40) {
                                                this.yRotate += this.rotationStep
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                break
        }
		if (b && !this.animationOn) {
            this.animationOn = true;
            this.animate(j)
        } else {
			this.draw(false, false, false, true)
        }
    };
    this.animate = function (d) {
		var a = this;
        var b = function () {
            this.update = function () {
                if (!a.animationOn) {
                    clearInterval(c)
                }
                a.arrowMove(d);
                var e = a.graphType;
                if (a.is3DPlot) {
                    e = "Scatter3D"
                }
                switch (e) {
                    case "Network":
                        if (this.is3DNetwork) {
                            if (d == 33) {
                                this.xRotate += (this.rotationStep * 3);
                                this.yRotate -= (this.rotationStep * 3)
                            } else {
                                if (d == 34) {
                                    this.xRotate -= (this.rotationStep * 3);
                                    this.yRotate += (this.rotationStep * 3)
                                } else {
                                    if (d == 37) {
                                        this.xRotate -= this.rotationStep
                                    } else {
                                        if (d == 38) {
                                            this.yRotate -= this.rotationStep
                                        } else {
                                            if (d == 39) {
                                                this.xRotate += this.rotationStep
                                            } else {
                                                if (d == 40) {
                                                    this.yRotate += this.rotationStep
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (d == 33) {
                                this.network2DRotate += (this.rotationStep * 3)
                            } else {
                                if (d == 34) {
                                    this.network2DRotate -= (this.rotationStep * 3)
                                } else {
                                    if (d == 37 || d == 38) {
                                        this.network2DRotate -= this.rotationStep
                                    } else {
                                        if (d == 39 || d == 40) {
                                            this.network2DRotate += this.rotationStep
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Scatter2D":
                    case "ScatterBubble2D":
                        if (d != 37) {
                            if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
                                if (a.xAxisCurrent >= a.xAxis.length - 1) {
                                    a.xAxisCurrent = a.xAxis.length - 1;
                                    a.yAxisCurrent = a.yAxis.length - 1;
                                    a.zAxisCurrent = a.zAxis.length - 1;
                                    d = 37
                                }
                            } else {
                                if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
                                    if (a.zAxisCurrent >= a.zAxis.length - 1) {
                                        a.zAxisCurrent = a.zAxis.length - 1;
                                        d = 37
                                    }
                                } else {
                                    if (a.xAxisIndices.length > a.yAxisIndices.length) {
                                        if (a.yAxisCurrent >= a.yAxis.length - 1) {
                                            a.yAxisCurrent = a.yAxis.length - 1
                                        }
                                        if (a.zAxisCurrent >= a.zAxis.length - 1) {
                                            a.zAxisCurrent = a.zAxis.length - 1
                                        }
                                        if (a.yAxisCurrent >= a.yAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
                                            d = 37
                                        }
                                    } else {
                                        if (a.xAxisCurrent >= a.xAxis.length - 1) {
                                            a.xAxisCurrent = a.xAxis.length - 1
                                        }
                                        if (a.zAxisCurrent >= a.zAxis.length - 1) {
                                            a.zAxisCurrent = a.zAxis.length - 1
                                        }
                                        if (a.xAxisCurrent >= a.xAxis.length - 1 && a.zAxisCurrent >= a.zAxis.length - 1) {
                                            d = 37
                                        }
                                    }
                                }
                            }
                        } else {
                            if (d != 39) {
                                if (a.graphType == "ScatterBubble2D" && a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length && a.xAxisIndices.length == a.zAxisIndices.length) {
                                    if (a.xAxisCurrent <= 0) {
                                        a.xAxisCurrent = 0;
                                        a.yAxisCurrent = 0;
                                        a.zAxisCurrent = 0;
                                        d = 39
                                    }
                                } else {
                                    if (a.xAxisIndices.length > 1 && a.xAxisIndices.length == a.yAxisIndices.length) {
                                        if (a.zAxisCurrent <= 0) {
                                            a.zAxisCurrent = 0;
                                            d = 39
                                        }
                                    } else {
                                        if (a.xAxisIndices.length > a.yAxisIndices.length) {
                                            if (a.yAxisCurrent <= 0) {
                                                a.yAxisCurrent = 0
                                            }
                                            if (a.zAxisCurrent <= 0) {
                                                a.zAxisCurrent = 0
                                            }
                                            if (a.yAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
                                                d = 39
                                            }
                                        } else {
                                            if (a.xAxisCurrent <= 0) {
                                                a.xAxisCurrent = 0
                                            }
                                            if (a.zAxisCurrent <= 0) {
                                                a.zAxisCurrent = 0
                                            }
                                            if (a.xAxisCurrent <= 0 && a.zAxisCurrent <= 0) {
                                                d = 39
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        break;
                    case "Scatter3D":
						if (a.xRotate <= 0 && (d == 39 || d < 37)) {
                            a.xRotate = 0;
                            a.yRotate = 0;
                            d = 40
                        } else {
                            if (a.xRotate >= 90 && (d == 37 || d < 37)) {
                                a.xRotate = 90;
                                a.yRotate = 90;
                                d = 38
                            } else {
                                if (a.yRotate <= 0 && (d == 38 || d < 37)) {
                                    a.yRotate = 0;
                                    a.xRotate = 90;
                                    d = 39
                                } else {
                                    if (a.yRotate >= 90 && (d == 40 || d < 37)) {
                                        a.yRotate = 90;
                                        a.xRotate = 0;
                                        d = 37
                                    }
                                }
                            }
                        }
						break
                }
            };
            var c = setInterval(this.update, a.animationTime)
        };
        b.call()
    };
    this.setGraphType = function (b) {
        var a;
        if (b == 66) {
            a = "Bar"
        } else {
            if (b == 76) {
                a = "Line"
            } else {
                if (b == 65) {
                    a = "Area"
                } else {
                    if (b == 67) {
                        a = "BarLine"
                    } else {
                        if (b == 73) {
                            a = "Boxplot"
                        } else {
                            if (b == 68) {
                                a = "Dotplot"
                            } else {
                                if (b == 72) {
                                    a = "Heatmap"
                                } else {
                                    if (b == 83) {
                                        a = "Stacked"
                                    } else {
                                        if (b == 85) {
                                            a = "StackedLine"
                                        } else {
                                            if (b == 84) {
                                                a = "StackedPercent"
                                            } else {
                                                if (b == 87) {
                                                    a = "StackedPercentLine"
                                                } else {
                                                    if (b == 50) {
                                                        a = "Scatter2D"
                                                    } else {
                                                        if (b == 52) {
                                                            a = "ScatterBubble2D"
                                                        } else {
                                                            if (b == 51) {
                                                                a = "Scatter3D"
                                                            } else {
                                                                if (b == 88) {
                                                                    a = "Correlation"
                                                                } else {
                                                                    if (b == 86) {
                                                                        a = "Venn"
                                                                    } else {
                                                                        if (b == 80) {
                                                                            a = "Pie"
                                                                        } else {
                                                                            if (b == 78) {
                                                                                a = "Network"
                                                                            } else {
                                                                                if (b == 71) {
                                                                                    a = "Genome"
                                                                                } else {
                                                                                    if (b == 77) {
                                                                                        a = "Candlestick"
                                                                                    } else {
                                                                                        if (b == 82) {
                                                                                            a = "Circular"
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (a && this.isValidGraphType(a)) {
            this.graphType = a;
            this.draw()
        } else {
            alert("Dude! You cannot plot this data in a " + a + " graph")
        }
    };
    this.reset = function () {
        this.varIndicesStart = -1;
        this.smpIndicesStart = -1;
        switch (this.graphType) {
            case "Area":
            case "AreaLine":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Heatmap":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Bar":
            case "Line":
            case "BarLine":
            case "Boxplot":
            case "Dotplot":
            case "Candlestick":
            case "Circular":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
                this.resetSelectedDataPoints();
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Network":
                this.resetSelectedNodes();
                this.setAllNodesVisible();
                this.ctx.translate(-this.offsetX, - this.offsetY);
                this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor);
                break;
            case "Genome":
                this.setAllFeaturesVisible();
                break
        }
    };
    this.redraw = function () {
		this.setInitialConfig();
        this.varIndicesStart = -1;
        this.smpIndicesStart = -1;
        switch (this.graphType) {
            case "Area":
            case "AreaLine":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Circular":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                return true;
            case "Bar":
            case "Line":
            case "BarLine":
            case "Boxplot":
            case "Dotplot":
            case "Genome":
            case "Candlestick":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                this.setMin = null;
                this.setMax = null;
                this.setMin2 = null;
                this.setMax2 = null;
                this.xRotate = 45;
                this.yRotate = 0;
                break;
            case "Scatter2D":
            case "ScatterBubble2D":
                this.resetSelectedDataPoints();
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                this.setMinX = null;
                this.setMaxX = null;
                this.setMinY = null;
                this.setMaxY = null;
                break;
            case "Scatter3D":
                this.resetSelectedDataPoints();
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                this.xRotate = 45;
                this.yRotate = 0;
                break;
            case "Heatmap":
                this.setAllVariablesVisible();
                this.setAllSamplesVisible();
                break;
            case "Network":
                this.resetSelectedNodes();
                this.setAllNodesVisible();
                this.network2DRotate = 0;
                if (this.randomNetwork) {
                    this.layoutDone = false
                }
                this.ctx.translate(-this.offsetX, - this.offsetY);
                this.ctx.scale(1 / this.scaleFactor, 1 / this.scaleFactor);
                break
        }
        this.draw();
        return true
    };
    this.resetZoomPan = function () {
        this.zoom = 1;
        this.panningX = 0;
        this.panningY = 0;
        this.panningGlobalX = 0;
        this.panningGlobalY = 0;
        this.padX = this.x / 2;
        this.padY = this.y / 2;
        this.padZ = this.y / 2
    };
    this.resetSelectedObjects = function () {
        if (this.isSelectDataPoints || this.isSelectNodes) {
            this.resetSelectedDataPoints();
            this.resetSelectedNodes();
            this.redraw()
        }
    };
    this.masterReset = function (a) {
        this.resetTooltipDivs();
        this.resetDrag(a);
        this.resetSelectedDataPoints();
        this.resetSelectedNodes();
        if (this.dataTableLastState && this.dataTableLastState != "docked") {
            this.hideUnhideDataTable(true)
        }
        this.resetConfigurator();
        this.resetAxesResizer(a);
        this.resetFlags(a);
        this.resetZoomPan();
        this.redraw()
    }
};
CanvasXpress.prototype.initSelectEvents = function () {
    this.showHideSelectedDataPoint = function (j, l) {
        if (j) {
            this.stopEvent(j)
        }
        var o = this.layoutComb ? this.layoutValidN : 0;
        var r = this.layoutComb ? this.layoutParams[o].graphType : this.graphType;
        var q = [];
        if (l == 45 || l == 46) {
            if (r == "Network") {
                var a = [];
                var k = l == 45 ? false : true;
                for (var d in this.selectNode) {
                    a.push(d)
                }
                if (a.length > 0) {
                    this.hideUnhideNodes(a, k)
                }
            } else {
                if (r.match(/Scatter/)) {
                    if (l == 45) {
                        this.selectDataPoint = this.hideDataPoint;
                        this.hideDataPoint = []
                    } else {
                        if (l == 46) {
                            this.hideDataPoint = this.selectDataPoint;
                            this.selectDataPoint = []
                        }
                    }
                    if (r == "Scatter3D") {
                        var m = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
                        for (var g = 0; g < this.data.y.vars.length; g++) {
                            if (this.isVisibleSelectedDataPoint(g, m)) {
                                q.push(g)
                            }
                        }
                        this.varIndices = q
                    }
                }
            }
            this.draw()
        } else {
            if (l == 36) {
                if (r == "Network") {
                    var b = {};
                    var h = [];
                    var a = this.data.nodes;
                    var f = this.data.edges;
                    for (var g = 0; g < f.length; g++) {
                        if (this.selectNode.hasOwnProperty(f[g].id1) || this.selectNode.hasOwnProperty(f[g].id2)) {
                            b[f[g].id1] = true;
                            b[f[g].id2] = true
                        }
                    }
                    for (var g = 0; g < a.length; g++) {
                        if (!b.hasOwnProperty(a[g].id)) {
                            h.push(a[g].id)
                        }
                    }
                    this.resetSelectedNodes();
                    if (h.length > 0) {
                        this.hideUnhideNodes(h, true);
                        this.draw()
                    }
                } else {
                    if (r == "Scatter3D") {
                        if (this.isSelectDataPoints) {
                            for (var g in this.selectDataPoint) {
                                var p = parseInt(g);
                                if (!isNaN(p)) {
                                    q.push(this.varIndices[p])
                                }
                            }
                            this.isSelectDataPoints = 0;
                            this.selectDataPoint = [];
                            this.varIndices = q;
                            this.draw()
                        }
                    }
                }
            }
        }
    };
    this.addRemoveToSelectedDataPoints = function (h, f) {
        var b = this.broadcast ? CanvasXpress.references : [this];
        for (var e = 0; e < b.length; e++) {
            var g = b[e];
            if (!h) {
                var j = g.layoutComb ? g.layoutValidN : 0;
                h = g.layoutComb ? g.layoutParams[j].graphType : g.graphType
            }
            if (h == "Network") {
                var a = parseInt(f.join(", "));
                if (a < g.data.nodes.length) {
                    var d = g.data.nodes[a].id;
                    if (g.selectNode.hasOwnProperty(d)) {
                        g.isSelectNodes--;
                        delete g.selectNode[d]
                    } else {
                        g.isSelectNodes++;
                        g.selectNode[d] = true
                    }
                }
            } else {
                if (h.match(/Scatter/)) {
                    var d;
                    if (!g.selectDataPoint[f[0]]) {
                        g.selectDataPoint[f[0]] = {}
                    }
                    if (h == "Scatter3D") {
                        d = f[1] + ":" + f[2] + ":" + f[3]
                    } else {
                        d = f[1] + ":" + f[2]
                    }
                    if (g.selectDataPoint[f[0]].hasOwnProperty(d)) {
                        g.isSelectDataPoints--;
                        if (this.broadcastType == "var") {
                            delete g.selectDataPoint[f[0]]
                        } else {
                            delete g.selectDataPoint[f[0]][d]
                        }
                    } else {
                        g.isSelectDataPoints++;
                        if (this.broadcastType == "var") {
                            g.selectDataPoint[f[0]] = true
                        } else {
                            g.selectDataPoint[f[0]][d] = true
                        }
                    }
                }
            }
        }
    };
    this.resetSelectedDataPoints = function () {
        if (this.isSelectDataPoints) {
            this.selectDataPoint = [];
            this.hideDataPoint = [];
            this.isSelectDataPoints = 0
        }
    };
    this.resetSelectedNodes = function () {
        if (this.isSelectNodes) {
            this.selectNode = {};
            this.isSelectNodes = 0
        }
    }
};
CanvasXpress.prototype.initDendrogramEvents = function () {
    this.modifyDendrogram = function (g) {
        var e = g.t.t == "varDendrogram" ? this.varIndicesStart : this.smpIndicesStart;
        var c = g.t.t.replace("Dendrogram", "s");
        var f = this[g.t.t].object;
        var h = g.t.d + "-" + g.t.o;
        var d = this.findDendrogramBranch(f, h);
        var b = this.reverseDendrogramBranch(d);
        var a = this.writeNewick(f, true);
        this.data.t[c] = a;
        this.draw()
    };
    this.findDendrogramBranch = function (b, c, a) {
        if (b.id == c) {
            a = b
        }
        if (!a) {
            if (b.left) {
                a = this.findDendrogramBranch(b.left, c, a)
            }
            if (b.right) {
                a = this.findDendrogramBranch(b.right, c, a)
            }
        } else {
            return a
        }
        return a
    };
    this.reverseDendrogramBranch = function (b) {
        if (b && b.right && b.left) {
            b.right = this.reverseDendrogramBranch(b.right);
            b.left = this.reverseDendrogramBranch(b.left);
            var a = b.left;
            b.left = b.right;
            b.right = a;
            if (b.mid) {
                b.mid = b.mid.reverse()
            }
        }
        return b
    }
};
CanvasXpress.prototype.initCanvasEvents = function () {
    this.contextmenuCanvas = function (a) {
        
    }(this);
    this.mousedownCanvas = function (a) {
		return function (c) {
            if (!c) {
                c = window.event
            }
            if (c && c.which ? c.which != 3 : c.button != 2) {
                if (!a.configuringOn) {
                    a.touchEvent = "hold";
                    a.registerDrag(c);
                    if (a.mobileApp) {
                        var b = function () {
                            clearTimeout(b);
                            if (a.touches && a.touches.length == 1 && a.touchEvent == "hold") {
                                a.masterReset(c)
                            }
                        };
                        setTimeout(b, 500)
                    }
                }
            }
            return false
        }
    }(this);
    this.clickCanvas = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            a.clickBuffer = function () {
                if (!a.doubleClick) {
                    if (!a.configuringOn) {
                        if (!a.skipClick && (a.lastCanvasEvent != "drag")) {
                            if (a.isHelp(b)) {
                                a.stopEvent(b);
                                a.showInfoSpan(b, 'Modify "helpKeyEvents"<br>&nbsp;&nbsp;&nbsp;to show or hide help<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;on key events"')
                            } else {
                                if (a.isAxis(b)) {
                                    a.stopEvent(b)
                                } else {
                                    if (a.axesResizerShow && !a.resizerType) {
                                        a.stopEvent(b);
                                        a.resetAxesResizer(b)
                                    } else {
                                        if (a.mobileApp) {
                                            a.stopEvent(b);
                                            a.addConfigurator(b)
                                        } else {
                                            var c = a.getEventDataId(b);
                                            if (c) {
                                                a.handleMouseEvents("click", b, c)
                                            } else {
                                                a.resetSelectedObjects()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } else {
                        a.resetConfigurator()
                    }
                    a.lastCanvasEvent = "click"
                }
            };
            setTimeout(a.clickBuffer, 250);
            setTimeout(function () {
                a.doubleClick = false
            }, 500)
        }
    }(this);
    
    this.wheelCanvas = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            var c = 0;
            if (!b) {
                b = window.event
            }
            if (b.wheelDelta) {
                c = b.wheelDelta / 120;
                if (window.opera) {
                    c = -c
                }
            } else {
                if (b.detail) {
                    c = -b.detail / 3
                }
            }
            if (c) {
                a.handleWheelEvent(b, c)
            }
        }
    }(this);
    this.addRemoveCanvasListeners = function (a) {
        this[a](this.canvas, "contextmenu", this.contextmenuCanvas, false);
        this[a](this.canvas, "mousedown", this.mousedownCanvas, false);
        this[a](this.canvas, "touchstart", this.mousedownCanvas, false);
        this[a](this.canvas, "click", this.clickCanvas, false);
        this[a](this.canvas, "mousewheel", this.wheelCanvas, false)
    };
    this.isVersion = function (b) {
        if (this.showVersion) {
            var a = this.adjustedCoordinates(b);
            return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
        }
    };
    this.isHelp = function (b) {
        var a = this.adjustedCoordinates(b);
        return a && a.x > 0 && a.x <= 10 && a.y > 0 && a.y <= 10 ? true : false
    };
    this.handleWheelEvent = function (G, H, K) {
        var F = G.target || G.srcElement;
        if (/CanvasXpress/.test(F.className)) {
			CanvasXpress.current = F.id
        }
        if (this.graphType == "Network") {
            this.cancelEvent(G);
            if (!K) {
                K = this.adjustedCoordinates(G)
            }
            if (K) {
                if (G.type == "keydown") {
                    K.x = this.width / 2;
                    K.y = this.height / 2
                }
                var u = this.scaleFactor * this.zoomStep;
                var m = (this.widthBounds / 2) - (K.x / this.scaleFactor);
                var k = (this.heightBounds / 2) - (K.y / this.scaleFactor);
                this.scaleFactor = H > 0 ? this.scaleFactor + u : this.scaleFactor - u;
                this.widthBounds = this.x / this.scaleFactor;
                this.heightBounds = this.y / this.scaleFactor;
                var g = (this.widthBounds / 2) - (K.x / this.scaleFactor);
                var M = (this.heightBounds / 2) - (K.y / this.scaleFactor);
                this.panningX = m - g;
                this.panningY = k - M;
                if (!this.networkFreeze) {
                    u = this.zoom * this.zoomStep;
                    this.zoom = H > 0 ? this.zoom + u : this.zoom - u
                }
                this.draw(false, false, false, true);
                this.panningGlobalX += this.panningX;
                this.panningGlobalY += this.panningY
            }
        } else {
            if (this.graphType == "Genome") {
                this.cancelEvent(G);
                if (this.xAxisUnit > 100 && H > 0) {
                    return
                }
                if (!K) {
                    K = this.adjustedCoordinates(G)
                }
                if (K) {
                    var j = (K.x - (this.marginLeft + this.left)) / this.x;
                    var v = 1 - j;
                    var y = this.xAxisRange * this.zoomStep;
                    if (H > 0) {
                        this.setMin = this.setMin != null ? this.setMin + (y * j) : this.xAxisMin + (y * j);
                        this.setMax = this.setMax != null ? this.setMax - (y * v) : this.xAxisMax - (y * v)
                    } else {
                        this.setMin = this.setMin != null ? this.setMin - (y * j) : this.xAxisMin - (y * j);
                        this.setMax = this.setMax != null ? this.setMax + (y * v) : this.xAxisMax + (y * v)
                    }
                    this.draw()
                }
            } else {
                if (this.graphType == "Heatmap") {
                    this.cancelEvent(G);
                    this.resetAxesResizer(G);
                    var I = this.layoutComb ? this.layoutValidN : 0;
                    var z;
                    var B = this.layoutComb ? this.layoutParams[I].varIndices : this.varIndices;
                    var n = this.isGroupedData ? this.grpIndices : this.smpIndices;
                    if (this.isGroupedData) {
                        z = this.layoutComb ? this.layoutParams[I].grpIndices : this.grpIndices
                    } else {
                        z = this.layoutComb ? this.layoutParams[I].smpIndices : this.smpIndices
                    }
                    this.setOriginalIndices(I, B, z);
                    if (!K) {
                        K = this.adjustedCoordinates(G)
                    }
                    if (K) {
                        if (G.type == "keydown") {
                            K.x = this.width / 2;
                            K.y = this.height / 2
                        }
                        K.x -= (this.marginLeft + this.left);
                        K.y -= (this.marginTop + this.top);
                        var A = Math.min(Math.max(K.x, 0), this.x) / this.x;
                        var J = Math.ceil(B.length / 10) * 2;
                        var a = Math.round(A * J);
                        var q = J - a;
                        var D = Math.min(Math.max(K.y, 0), this.y) / this.y;
                        var L = Math.ceil(z.length / 10) * 2;
                        var f = Math.round(D * L);
                        var t = L - f;
                        var s = false;
                        if (H > 0) {
                            if (!this.zoomVariablesDisable && B.length > 3) {
                                if (this.varIndicesStart < 0) {
                                    this.varIndicesStart++
                                }
                                for (var E = 0; E < a; E++) {
                                    this.varIndices.shift();
                                    this.varIndicesStart++
                                }
                                for (var E = 0; E < q; E++) {
                                    this.varIndices.pop()
                                }
                                s = true
                            }
                            if (!this.zoomSamplesDisable && z.length > 3) {
                                if (this.smpIndicesStart < 0) {
                                    this.smpIndicesStart++
                                }
                                for (var E = 0; E < f; E++) {
                                    this.smpIndices.shift();
                                    this.smpIndicesStart++
                                }
                                for (var E = 0; E < t; E++) {
                                    this.smpIndices.pop()
                                }
                                s = true
                            }
                        } else {
                            if (!this.zoomVariablesDisable) {
                                for (var E = 0; E < a; E++) {
                                    if (this.varIndicesStart >= 0 && this.varIndicesStart + B.length < this.startingVarIndices[I].length) {
                                        this.varIndices.push(this.startingVarIndices[I][this.varIndicesStart + B.length]);
                                        s = true
                                    } else {
                                        if (this.varIndicesStart > 0) {
                                            this.varIndicesStart--;
                                            this.varIndices.unshift(this.startingVarIndices[I][this.varIndicesStart]);
                                            s = true
                                        }
                                    }
                                }
                                for (var E = 0; E < q; E++) {
                                    if (this.varIndicesStart > 0) {
                                        this.varIndicesStart--;
                                        this.varIndices.unshift(this.startingVarIndices[I][this.varIndicesStart]);
                                        s = true
                                    } else {
                                        if (this.varIndicesStart >= 0 && this.varIndicesStart + B.length < this.startingVarIndices[I].length) {
                                            this.varIndices.push(this.startingVarIndices[I][this.varIndicesStart + B.length]);
                                            s = true
                                        }
                                    }
                                }
                            }
                            if (!this.zoomSamplesDisable) {
                                for (var E = 0; E < f; E++) {
                                    if (this.smpIndicesStart >= 0 && this.smpIndicesStart + z.length < this.startingSmpIndices[I].length) {
                                        this.smpIndices.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length]);
                                        s = true
                                    } else {
                                        if (this.smpIndicesStart > 0) {
                                            this.smpIndicesStart--;
                                            this.smpIndices.unshift(this.startingSmpIndices[I][this.smpIndicesStart]);
                                            s = true
                                        }
                                    }
                                }
                                for (var E = 0; E < t; E++) {
                                    if (this.smpIndicesStart > 0) {
                                        this.smpIndicesStart--;
                                        this.smpIndices.unshift(this.startingSmpIndices[I][this.smpIndicesStart]);
                                        s = true
                                    } else {
                                        if (this.smpIndicesStart >= 0 && this.smpIndicesStart + z.length < this.startingSmpIndices[I].length) {
                                            this.smpIndices.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length]);
                                            s = true
                                        }
                                    }
                                }
                            }
                        }
                        if (s) {
                            this.draw()
                        }
                    }
                } else {
                    if (this.graphType.match(/Bar|Line|Dotplot|Boxplot|Area|Stacked|Circular/) && !this.is3DPlot) {
                        this.cancelEvent(G);
                        this.resetAxesResizer(G);
                        var I = this.layoutComb ? this.layoutValidN : 0;
                        var z;
                        var B = this.layoutComb ? this.layoutParams[I].varIndices : this.varIndices;
                        var n = this.isGroupedData ? this.grpIndices : this.smpIndices;
                        if (this.isGroupedData) {
                            z = this.layoutComb ? this.layoutParams[I].grpIndices : this.grpIndices
                        } else {
                            z = this.layoutComb ? this.layoutParams[I].smpIndices : this.smpIndices
                        }
                        this.setOriginalIndices(I, B, z);
                        if (!K) {
                            K = this.adjustedCoordinates(G)
                        }
                        if (K) {
                            if (G.type == "keydown") {
                                K.x = this.width / 2;
                                K.y = this.height / 2
                            }
                            K.x -= (this.marginLeft + this.left);
                            K.y -= (this.marginTop + this.top);
                            var p = this.graphOrientation == "vertical" ? Math.min(Math.max(K.x, 0), this.x) / this.x : Math.min(Math.max(K.y, 0), this.y) / this.y;
                            var C = Math.ceil(z.length / 10) * 2;
                            var l = Math.round(p * C);
                            var h = C - l;
                            var b = [];
                            if (H > 0) {
                                if (z.length > 3) {
                                    if (this.smpIndicesStart < 0) {
                                        this.smpIndicesStart++
                                    }
                                    this.smpIndicesStart += l;
                                    for (var E = l; E < z.length - h; E++) {
                                        b.push(z[E])
                                    }
                                    this.setSamplesVisible(b, true);
                                    this.draw()
                                }
                            } else {
                                if (this.startingSmpIndices[I].length > z.length) {
                                    b = z;
                                    for (var E = 0; E < h; E++) {
                                        if (this.startingSmpIndices[I].length > this.smpIndicesStart + z.length) {
                                            b.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length])
                                        } else {
                                            if (this.smpIndicesStart > 0) {
                                                this.smpIndicesStart--;
                                                b.unshift(this.startingSmpIndices[I][this.smpIndicesStart])
                                            }
                                        }
                                    }
                                    for (var E = 0; E < l; E++) {
                                        if (this.smpIndicesStart > 0) {
                                            this.smpIndicesStart--;
                                            b.unshift(this.startingSmpIndices[I][this.smpIndicesStart])
                                        } else {
                                            if (this.startingSmpIndices[I].length > this.smpIndicesStart + z.length) {
                                                b.push(this.startingSmpIndices[I][this.smpIndicesStart + z.length])
                                            }
                                        }
                                    }
                                    this.setSamplesVisible(b, true);
                                    this.draw()
                                }
                            }
                        }
                    } else {
                        if (this.graphType == "Scatter3D" || this.is3DPlot) {
                            this.cancelEvent(G);
                            if (!K) {
                                K = this.adjustedCoordinates(G)
                            }
                            if (K) {
                                K.x -= (this.marginLeft + this.left);
                                K.y -= (this.marginTop + this.top);
                                var x = (Math.min(Math.max(K.x, 0), this.x) / this.x) - 0.5;
                                var w = (Math.min(Math.max(K.y, 0), this.y) / this.y) - 0.5
                            }
                            if (H > 0) {
                                if (this.zoom >= 4) {
                                    return
                                }
                                this.zoom *= 1.1;
                                this.padX -= x * this.padX / 4;
                                this.padY -= w * this.padY / 4
                            } else {
                                if (this.zoom <= 0.5) {
                                    return
                                }
                                this.zoom *= 0.9;
                                this.padX += x * this.padX / 4;
                                this.padY += w * this.padY / 4
                            }
                            this.draw()
                        } else {
                            if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                                this.cancelEvent(G);
                                return;
                                if (!K) {
                                    K = this.adjustedCoordinates(G)
                                }
                                if (K) {
                                    K.x -= (this.marginLeft + this.left);
                                    K.y -= (this.marginTop + this.top);
                                    var x = Math.min(Math.max(K.x, 0), this.x) / this.x;
                                    var w = Math.min(Math.max(K.y, 0), this.y) / this.y;
                                    var r = this.xAxisMin + (x * this.xAxisRange);
                                    var o = this.yAxisMax - (w * this.yAxisRange)
                                }
                            }
                        }
                    }
                }
            }
        }
        return false
    };
    this.setLayoutValidIndices = function (k) {
        if (this.layoutComb) {
            var h = this.adjustedCoordinates(k);
            if (h) {
                var a = h.x;
                var g = h.y;
                var m = 0;
                for (var f = 0; f < this.layoutRows; f++) {
                    for (var d = 0; d < this.layoutCols; d++) {
                        var b = this.getBoundsXY(m);
                        if (a >= b[0] && a <= b[1] && g >= b[2] && g <= b[3]) {
                            if (this.layoutValid) {
                                this.layoutValidR = f;
                                this.layoutValidC = d;
                                this.layoutValidN = m
                            }
                        }
                        m++
                    }
                }
            }
        }
    };
    this.getNetworkEventDataId = function (c) {
        var a = this.isEvent(c, true);
        var d = a[0];
        var b = a[1];
        if (d) {
            return b && b.match(/-legend-/) ? false : d
        } else {
            return false
        }
    };
    this.getEventDataId = function (a) {
        return this.graphType == "Network" ? this.getNetworkEventDataId(a) : this.isEvent(a)
    };
    this.getEventAreaData = function (a) {
        return this.extractDataObject(this.getEventDataId(a))
    };
    this.handleMouseEvents = function (b, c, a) {
        if (a[0] == -1) {
            this.showInfoSpan(c, "CanvasXpress (" + this.version + ")")
        } else {
            if (this.layoutComb && !this.layoutValidN) {
                this.setLayoutValidIndices(c)
            }
            var d = this.extractDataObject(a);
            if (this.userEvents[b]) {
                if (typeof (this.userEvents[b]) == "object" && this.userEvents[b].handler && this.userEvents[b].scope) {
                    if (c.ctrlKey && b == "click") {
                        if (c.shiftKey && b == "click") {
                            alert(this.prettyJSON(d))
                        } else {
                            if (c.shiftKey && b == "click") {
                                this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                this.draw()
                            } else {
                                this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                this.draw()
                            }
                        }
                    } else {
                        if (c.shiftKey && b == "click" && this.graphType == "Network" && this.networkLayoutType == "radial") {
                            this.reRootRadialNetwork(this.getEventDataId(c))
                        } else {
                            if (c.shiftKey && b == "click") {} else {
                                if (c.altKey && b == "click") {} else {
                                    this.userEvents[b].handler.apply(this.userEvents[b].scope, [d, c, this, a])
                                }
                            }
                        }
                    }
                } else {
                    if (typeof (this.userEvents[b]) == "object" && this.userEvents[b].handler) {
                        if (c.ctrlKey && b == "click") {
                            if (c.shiftKey && b == "click") {
                                alert(this.prettyJSON(d))
                            } else {
                                if (c.shiftKey && b == "click") {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                } else {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                }
                            }
                        } else {
                            if (c.shiftKey && b == "click" && this.graphType == "Network" && this.networkLayoutType == "radial") {
                                this.reRootRadialNetwork(this.getEventDataId(c))
                            } else {
                                if (c.shiftKey && b == "click") {} else {
                                    if (c.altKey && b == "click") {} else {
                                        this.userEvents[b].handler(d, c, this, a)
                                    }
                                }
                            }
                        }
                    } else {
                        if (c.ctrlKey && b == "click") {
                            if (c.shiftKey && b == "click") {
                                alert(this.prettyJSON(d))
                            } else {
                                if (c.shiftKey && b == "click") {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                } else {
                                    this.addRemoveToSelectedDataPoints(false, this.getEventDataId(c));
                                    this.draw()
                                }
                            }
                        } else {
                            if (c.shiftKey && b == "click" && this.graphType == "Network" && this.networkLayoutType == "radial") {
                                this.reRootRadialNetwork(this.getEventDataId(c))
                            } else {
                                if (c.shiftKey && b == "click") {} else {
                                    if (c.altKey && b == "click") {} else {
                                        this.userEvents[b](d, c, this, a)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.formatCoords = function (j, k) {
        var f = [];
        if (this.graphType != "Network") {
            for (var e = 0; e < k.length; e++) {
                if (e % 2) {
                    f.push(sprintf("%.0f", (k[e] + this.translateY) * this.scaleY))
                } else {
                    if (this.layoutValid && j == "circle" && e == 2) {
                        f.push(sprintf("%.0f", k[e] * ((this.scaleX + this.scaleY) / 2)))
                    } else {
                        f.push(sprintf("%.0f", (k[e] + this.translateX) * this.scaleX))
                    }
                }
            }
        } else {
            for (var e = 0; e < k.length; e++) {
                f.push(sprintf("%.0f", parseInt(k[e])))
            }
        }
        if (j == "rect") {
            var b = Math.min(f[0], f[2]);
            var d = Math.min(f[1], f[3]);
            var a = Math.max(f[0], f[2]);
            var g = Math.max(f[1], f[3]);
            f = [b, d, a, g]
        }
        return f.join(",")
    };
    this.addArea = function (e, a, d) {
        if (!e || !a) {
            return
        }
        var b = e.shift();
        if (b && e) {
            switch (b) {
                case "rect":
                    e[0] -= this.outlineWidth;
                    e[1] -= this.outlineWidth;
                    e[2] += (this.outlineWidth * 2);
                    e[3] += (this.outlineWidth * 2);
                    break;
                case "circle":
                    e[2] += (this.outlineWidth * 2);
                    break;
                case "poly":
                    break
            }
            this.dataEvent.push([a, b, e, d])
        }
    };
    this.flash = function (b, p, m, f, k, a) {
        var j = document.createElement("div");
        j.id = this.target + "canvasXpressFlash" + new Date().getTime();
        j.style.left = (b - (m / 2)) + "px";
        j.style.top = (p - (f / 2)) + "px";
        j.style.width = m + "px";
        j.style.height = f + "px";
        j.style.opacity = 0.6;
        j.style.filter = "alpha(opacity = 60)";
        j.style.position = "absolute";
        j.style.zIndex = 100000;
        j.style.display = "block";
        j.style.backgroundColor = k ? k : this.resizerBackgroundColor;
        this.canvas.parentNode.appendChild(j);
        if (!a) {
            a = 3
        }
        var g = this;
        var e = 1;
        var o = function () {
            this.update = function () {
                if (e % 2) {
                    j.style.display = "none"
                } else {
                    j.style.display = "block"
                }
                if (e >= (a * 2)) {
                    g.canvas.parentNode.removeChild(j);
                    clearInterval(c)
                }
                e++
            };
            var c = setInterval(this.update, 300)
        };
        o.call()
    };
    this.initializeCanvasEvents = function () {
        if (!this.disableEvents) {
            this.addRemoveCanvasListeners("addEvtListener")
        }
    };
    this.initializeCanvasEvents()
};
CanvasXpress.prototype.initCleanupEvents = function () {
    this.destroy = function (a) {
        if (a) {
            if (CanvasXpress.references.length == 1 && CanvasXpress.references[0].target == a) {
                return this.destroy()
            } else {
                this.removeReference(a)
            }
        } else {
            while (CanvasXpress.references.length > 0) {
                a = CanvasXpress.references[0];
                this.removeReference(a.target)
            }
            CanvasXpress.cacheImages = {};
            CanvasXpress.cacheText = {};
            CanvasXpress.stack = {};
            CanvasXpress.current = false
        }
    };
    this.monitorReference = function () {
        var b = [];
        for (var a = 0; a < CanvasXpress.references.length; a++) {
            var d = document.getElementById(CanvasXpress.references[a].target);
            if (!d) {
                b.push(CanvasXpress.references[a].target)
            }
        }
        for (var a = 0; a < b.length; a++) {
            this.destroy(b[a])
        }
    };
    this.removeReference = function (e, b) {
        var d = CanvasXpress.references;
        CanvasXpress.references = [];
        for (var c = 0; c < d.length; c++) {
            if (d[c].target != e) {
                CanvasXpress.references.push(d[c])
            } else {
                var f = d[c];
                f.resetTooltipDivs();
                f.cleanEvtListeners(b);
                f.removeTarget("container-" + f.target)
            }
        }
    };
    this.cleanEvtListeners = function (b) {
        this.addRemoveLinkListeners("removeEvtListener");
        this.addRemoveViewportListeners("removeEvtListener");
        this.addRemoveToolbarListeners("removeEvtListener");
        this.addRemoveItemListeners("removeEvtListener");
        this.addRemoveConfiguratorListeners("removeEvtListener");
        this.addRemoveDataTableListeners("removeEvtListener");
        this.removeGenericDataFilterListenersOrReset();
        this.addRemoveDataFilterListeners("removeEvtListener");
        this.addRemoveCanvasListeners("removeEvtListener");
        this.addRemoveAxesResizerListeners("removeEvtListener");
        this.addRemoveNavigationTopListeners("removeEvtListener");
        this.addRemoveNavigationLeftRightListeners("removeEvtListener");
        this.removeEvtListener(document, "mousemove", this.mousemoveDoc, false);
        this.removeEvtListener(document, "touchmove", this.mousemoveDoc, false);
        this.removeEvtListener(document, "mouseup", this.mouseupDoc, false);
        this.removeEvtListener(document, "touchend", this.mouseupDoc, false);
        this.removeEvtListener(document, "keydown", this.keydownDoc, false);
        this.removeEvtListener(document, "keyup", this.keyupDoc, false);
        this.removeEvtListener(window, "resize", this.resizeWindow, false)
    };
    this.initializeCleanupEvents = function () {
        if (this.destroyCanvasXpressZombies) {
            var b = this;
            var a = function () {
                this.monitor = function () {
                    if (CanvasXpress.references.length < 1) {
                        clearInterval(c)
                    }
                    b.monitorReference()
                };
                var c = setInterval(this.monitor, b.monitorCanvasXpressZombiesTime)
            };
            a.call()
        }
    };
    this.initializeCleanupEvents()
};
CanvasXpress.prototype.initEvents = function () {
    this.relativeCoordinates = function (a) {
        var b = {
            x: 0,
            y: 0
        };
        while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
            b.x += a.offsetLeft;
            b.y += a.offsetTop;
            a = a.offsetParent
        }
        return b
    };
    this.absoluteCoordinates = function (a) {
        var b = {
            x: 0,
            y: 0
        };
        while (a && !isNaN(a.offsetLeft) && !isNaN(a.offsetTop)) {
            b.x += a.offsetLeft - a.scrollLeft;
            b.y += a.offsetTop - a.scrollTop;
            a = a.offsetParent
        }
        return b
    };
    this.adjustedCoordinates = function (h, f) {
        if (!f) {
            f = document.getElementById(this.target)
        }
        if (this.isIE) {
            if (!window.event) {
                return
            }
        }
        if (f) {
            var j = {};
            var g = f.parentNode.getClientRects();
            var b = h && h.changedTouches ? h.changedTouches[0] : false;
            if (g && g[0]) {
                var d = g[0].left;
                var f = g[0].top;
                var a = h && h.clientX ? h.clientX : b ? b.clientX : h && h[0] ? h[0] : d;
                var i = h && h.clientY ? h.clientY : b ? b.clientY : h && h[1] ? h[1] : f;
                j.x = document.body.scrollLeft > Math.abs(d) + a && a > document.body.scrollLeft - d ? Math.abs(d) + a : a - d;
                j.y = document.body.scrollTop > Math.abs(f) + i && i > document.body.scrollTop - f ? Math.abs(f) + i : (i - f)
            } else {
                j.x = 0;
                j.y = 0
            }
            return j
        }
    };
    this.isObjectInsideArea = function (b, g, d, l, c, j) {
        var k, h;
        switch (b) {
            case "rect":
                k = (g[0] + g[2]) / 2;
                h = (g[1] + g[3]) / 2;
                break;
            case "circle":
                k = g[0];
                h = g[1];
                break;
            case "poly":
                var e = [];
                var a = [];
                for (var f = 0; f < g.length; f++) {
                    if (f % 2) {
                        a.push(g[f])
                    } else {
                        e.push(g[f])
                    }
                }
                e.sort(function (m, i) {
                    return (m - i)
                });
                a.sort(function (m, i) {
                    return (m - i)
                });
                k = (e[0] + e[e.length - 1]) / 2;
                h = (a[0] + a[a.length - 1]) / 2;
                break
        }
        return this.isPointInsideArea("rect", k, h, [d, l, c, j])
    };
    this.isPointInsideArea = function (n, m, l, k) {
        switch (n) {
            case "rect":
                if (k[0] > k[2]) {
                    k[4] = k[0];
                    k[0] = k[2];
                    k[2] = k[4]
                }
                if (k[1] > k[3]) {
                    k[4] = k[1];
                    k[1] = k[3];
                    k[3] = k[4]
                }
                if (m >= k[0] && m <= k[2] && l >= k[1] && l <= k[3]) {
                    return true
                } else {
                    return false
                }
            case "circle":
                var f = k[2] / 2;
                if (m >= k[0] - f && m <= k[0] + f && l >= k[1] - f && l <= k[1] + f) {
                    return true
                } else {
                    return false
                }
            case "poly":
                var d = [];
                var a = [];
                var g = false;
                for (var e = 0; e < k.length; e++) {
                    if (e % 2) {
                        a.push(k[e])
                    } else {
                        d.push(k[e])
                    }
                }
                if (a[0] < a[1]) {
                    a = a.reverse();
                    d = d.reverse()
                }
                for (var e = 0, b = d.length - 1; e < d.length; b = e++) {
                    if (((a[e] <= l && l < a[b]) || (a[b] <= l && l < a[e])) && (m < (d[b] - d[e]) * (l - a[e]) / (a[b] - a[e]) + d[e])) {
                        g = !g
                    }
                }
                return g
        }
    };
    this.isEvent = function (o, h, j) {
        var u = this.adjustedCoordinates(o);
        if (u) {
            var d = o.target || o.srcElement;
            if (d && d.id && d.id.match(this.target)) {
                var t = u.x;
                var q = u.y;
                var r = this.dataEvent;
                var b = [];
                for (var k = r.length - 1; k >= 0; k--) {
                    var g = r[k][0];
                    var v = r[k][1];
                    var p = r[k][2];
                    var l = r[k][3];
                    if (this.isPointInsideArea(v, t, q, p)) {
                        if (l) {
                            l = g[0] + l
                        }
                        if (j) {
                            if (l) {
                                b.push(l)
                            } else {
                                b.push(g[0])
                            }
                        } else {
                            return h ? [g, l] : l ? [l] : g
                        }
                    }
                }
                if (b.length > 0) {
                    return b
                }
            }
        }
        return false
    };
    this.getBoundsXY = function (e) {
        var d = this.layoutComb ? this.layoutParams[e] : this;
        var a = this.graphType == "Network" ? 0 : this.marginLeft + d.offsetX;
        var b = this.graphType == "Network" ? 0 : this.marginTop + d.offsetY;
        return [a + d.left, a + d.left + d.x, b + d.top, b + d.top + d.y, a, a + d.left + d.x + d.right, b, b + d.top + d.y + d.bottom]
    };
    this.extractDataObject = function (h, b) {
        var k = this;
        var E = this.layoutComb && this.layoutValidN > -1 ? this.layoutParams[this.layoutValidN].graphType : this.graphType;
        var K = [];
        var I = [];
        var H = [];
        var w = function (d) {
            var n = {};
            for (var j in k.data.x) {
                n[j] = [];
                for (var g = 0; g < d.length; g++) {
                    n[j].push(k.data.x[j][d[g]])
                }
            }
            return n
        };
        var v = function (d) {
            var n = {};
            for (var j in k.data.z) {
                n[j] = [];
                for (var g = 0; g < d.length; g++) {
                    n[j].push(k.data.z[j][d[g]])
                }
            }
            return n
        };
        var F = function (d) {
            var j = [];
            for (var g = 0; g < d.length; g++) {
                j.push(k.data.y.vars[d[g]])
            }
            return j
        };
        var l = function (j, p) {
            var d = p ? k.data.w.smps : k.data.y.smps;
            var s = [];
            for (var n = 0; n < j.length; n++) {
                s.push(d[j[n]])
            }
            return s
        };
        var f = function (d) {
            var j = [];
            for (var g = 0; g < d.length; g++) {
                j.push(k.data.w.grps[d[g]])
            }
            return j
        };
        var e = function (g, d, t) {
            var s = [];
            if (!t) {
                t = "data"
            }
            if (d) {
                for (var p = 0; p < g.length; p++) {
                    s[p] = [];
                    for (var n = 0; n < d.length; n++) {
                        s[p].push(k.data.y[t][g[p]][d[n]])
                    }
                }
            } else {
                for (var p = 0; p < g.length; p++) {
                    s.push(k.data.y[t][g[p]])
                }
            }
            return s
        };
        switch (E) {
            case "Area":
            case "AreaLine":
            case "Bar":
            case "Line":
            case "BarLine":
            case "Boxplot":
            case "Dotplot":
            case "Heatmap":
            case "Pie":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Scatter3D":
            case "Candlestick":
            case "Circular":
                if (!h || h.length == 0 || h[0] == null) {
                    return
                } else {
                    if (isNaN(h[0])) {
                        if (h[0] && h[0].match(/Dendrogram/)) {
                            var y = {
                                t: {}
                            };
                            var x = h[0].split("-");
                            y.t.d = parseInt(x[1]);
                            y.t.o = parseInt(x[2]);
                            y.t.t = x[3];
                            y.objectType = "Dendrogram";
                            return y
                        } else {
                            if (h[0] && h[0].match(/Var/)) {
                                var x = h[0].split("-");
                                var D = parseInt(x[1]);
                                var J = [D];
                                J = J.concat(this.smpIndices);
                                var y = this.extractDataObject(J);
                                y.display = this.data.y.vars[D];
                                y.objectType = "Var";
                                return y
                            } else {
                                if (h[0] && h[0].match(/Smp/)) {
                                    var x = h[0].split("-");
                                    var D = parseInt(x[1]);
                                    var y = this.extractDataObject([D], this.varIndices);
                                    y.display = this.isGroupedData ? this.data.w.smps[D] : this.data.y.smps[D];
                                    y.objectType = "Smp";
                                    return y
                                } else {
                                    return
                                }
                            }
                        }
                    } else {
                        if (b) {
                            K = b;
                            I = h
                        } else {
                            K = [h[0]];
                            I = [];
                            for (var D = 1; D < h.length; D++) {
                                I.push(h[D])
                            }
                        }
                        if (E.match(/Scatter/)) {
                            if (this.colorBy && this.getSampleIndices(this.colorBy) > -1) {
                                I.push(this.getSampleIndices(this.colorBy))
                            }
                            if (this.shapeBy && this.getSampleIndices(this.shapeBy) > -1) {
                                I.push(this.getSampleIndices(this.shapeBy))
                            }
                            if (this.sizeBy && this.getSampleIndices(this.sizeBy) > -1) {
                                I.push(this.getSampleIndices(this.sizeBy))
                            }
                        }
                    }
                }
                if (E.match(/Area/)) {
                    return {
                        x: this.data.x,
                        y: {
                            vars: F(K),
                            smps: this.data.y.smps,
                            data: e(K)
                        },
                        z: v(K)
                    }
                } else {
                    if (this.isGroupedData) {
                        var y = {
                            x: {},
                            w: {},
                            z: v(K)
                        };
                        if (E == "Boxplot" && I[1] != null) {
                            y.y = {
                                data: this.data.y.data[K[0]][I[1]],
                                vars: this.data.y.vars[I[1]],
                                smps: this.data.y.smps[I[1]]
                            }
                        }
                        for (var x in this.data.w) {
                            if (x == "smps") {
                                y.w[x] = l(I, true)
                            } else {
                                if (x == "grps") {
                                    y.w[x] = f(I)
                                } else {
                                    if (x == "vars") {
                                        y.w[x] = F(K)
                                    } else {
                                        if (this.data.w[x].length > K[0] && this.data.w[x][K[0]].length > I[0]) {
                                            y.w[x] = [];
                                            y.w[x].push(this.data.w[x][K[0]][I[0]])
                                        }
                                    }
                                }
                            }
                        }
                        for (var x in this.data.x) {
                            var m = [];
                            for (var D = 0; D < y.w.grps[0].length; D++) {
                                m.push(this.data.x[x][y.w.grps[0][D]])
                            }
                            y.x[x] = m
                        }
                    } else {
                        var y = {
                            x: w(I),
                            y: {
                                vars: F(K),
                                smps: l(I)
                            },
                            z: v(K)
                        };
                        if (E == "Candlestick") {
                            for (var x in this.data.y) {
                                if (x && x != "vars" && x != "smps" && x != "desc") {
                                    y.y[x] = [];
                                    for (var D = 0; D < K.length; D++) {
                                        y.y[x][D] = [];
                                        for (var C = 0; C < I.length; C++) {
                                            y.y[x][D].push(this.data.y[x][K[D]][I[C]])
                                        }
                                    }
                                }
                            }
                        } else {
                            y.y.data = e(K, I);
                            if (this.isMultidimensionalHeatmap) {
                                var A = ["outline", "shape", "size"];
                                for (var D = 0; D < A.length; D++) {
                                    var B = A[D] + "ByData";
                                    if (this.data.y[this[B]]) {
                                        y.y[this[B]] = e(K, I, this[B])
                                    }
                                }
                            }
                        }
                    }
                }
                return y;
            case "Correlation":
                if (!h || (isNaN(h[0]) && !h[0].match(/^\d/))) {
                    return
                } else {
                    var G = this.isGroupedData ? this.data.w.cor : this.data.y.cor
                }
                if (this.correlationAxis == "samples") {
                    var y = {
                        x: {},
                        y: {}
                    };
                    for (var x in this.data.x) {
                        var m = [];
                        for (var D = 0; D < h.length; D++) {
                            m.push(this.data.x[x][h[D]])
                        }
                        y.x[x] = m
                    }
                    y.y.smps = [this.data.y.smps[h[0]], this.data.y.smps[h[1]]]
                } else {
                    var y = {
                        y: {},
                        z: {}
                    };
                    for (var x in this.data.y) {
                        var c = [];
                        for (var D = 0; D < h.length; D++) {
                            c.push(this.data.y[x][h[D]])
                        }
                        y.z[x] = c
                    }
                    y.y.vars = [this.data.y.vars[h[0]], this.data.y.vars[h[1]]]
                }
                y.y.data = G[h[0]][h[1]];
                return y;
            case "Venn":
                var y = {
                    venn: {
                        data: {}
                    }
                };
                y.venn.data[this.vennCompartments[h[0]]] = this.data.venn.data[this.vennCompartments[h[0]]];
                return y;
            case "Network":
                var y = {};
                if (!h || h.length == 0) {
                    return
                }
                if (isNaN(h[0])) {
                    h[0] = h[0].toString();
                    if (h[0].match(/legend/)) {
                        if (h[0].match(/Nodes/)) {
                            y = {
                                nodeLegend: this.data.legend.nodes
                            }
                        } else {
                            if (h[0].match(/Edges/)) {
                                y = {
                                    edgeLegend: this.data.legend.edges
                                }
                            } else {
                                if (h[0].match(/Decorations/)) {
                                    y = {
                                        decorationLegend: this.data.legend.decorations
                                    }
                                } else {
                                    var q = parseInt(h[0].replace("-1-legend-Text", ""));
                                    y = {
                                        textLegend: this.data.legend.text[q]
                                    }
                                }
                            }
                        }
                    }
                } else {
                    for (var D = 0; D < h.length; D++) {
                        if (h[D] >= this.data.nodes.length) {
                            if (!y.edges) {
                                y.edges = []
                            }
                            y.edges.push(this.data.edges[h[D] - this.data.nodes.length])
                        } else {
                            if (!y.nodes) {
                                y.nodes = []
                            }
                            y.nodes.push(this.data.nodes[h[D]])
                        }
                    }
                }
                return y;
            case "Genome":
                var E;
                var y = [];
                y[0] = {
                    data: []
                };
                var q = 0;
                var r = isNaN(h[0]) && h[0].match(":") ? h[0].match(/:(\d+)/)[1] : false;
                for (var D = 0; D < this.data.tracks.length; D++) {
                    var z = this.data.tracks[D].data.length;
                    q += z;
                    if (isNaN(h[0])) {
                        if (h[0] == "track-" + D) {
                            return {
                                name: this.data.tracks[D].name
                            }
                        } else {
                            if (h[0] == "track-" + D + ":" + r) {
                                var u = parseInt(r) - (q - z);
                                for (var x in this.data.tracks[D]) {
                                    if (x == "data") {
                                        y[0][x].push(this.data.tracks[D][x][u])
                                    } else {
                                        y[0][x] = this.data.tracks[D][x]
                                    }
                                }
                                return y
                            }
                        }
                        continue
                    }
                    if (h[h.length - 1] < q) {
                        for (var C = 0; C < h.length; C++) {
                            var u = h[C] - (q - z);
                            for (var x in this.data.tracks[D]) {
                                if (x == "data") {
                                    y[0][x].push(this.data.tracks[D][x][u])
                                } else {
                                    y[0][x] = this.data.tracks[D][x]
                                }
                            }
                        }
                        return y
                    }
                }
        }
    };
    this.getSummaryDataObject = function (b) {
        if (b) {
            switch (this.graphType) {
                case "Bar":
                case "Line":
                case "Area":
                case "AreaLine":
                case "BarLine":
                case "Boxplot":
                case "Dotplot":
                case "Heatmap":
                case "Stacked":
                case "StackedLine":
                case "StackedPercent":
                case "StackedPercentLine":
                case "Scatter2D":
                case "ScatterBubble2D":
                case "Scatter3D":
                case "Circular":
                    var i = "";
                    if (b.display) {
                        return "<b>" + b.display + "</b><br>"
                    } else {
                        if (this.isGroupedData && b.w) {
                            i = "<b>" + b.w.vars[0] + "</b><br>";
                            if (this.summaryType == "mean") {
                                for (var d = 0; d < b.w.smps.length; d++) {
                                    i += "<b>" + b.w.smps[d] + "</b>: " + b.w.mean[d] + "<br>"
                                }
                            } else {
                                if (this.summaryType == "median" || this.summaryType == "iqr") {
                                    for (var d = 0; d < b.w.smps.length; d++) {
                                        i += "<b>" + b.w.smps[d] + "</b>: " + b.w.median[d] + "<br>"
                                    }
                                } else {
                                    if (this.summaryType == "sum") {
                                        for (var d = 0; d < b.w.smps.length; d++) {
                                            i += "<b>" + b.w.smps[d] + "</b>: " + b.w.sum[d] + "<br>"
                                        }
                                    }
                                }
                            }
                        } else {
                            if (b.y) {
                                i = "<b>" + b.y.vars[0] + "</b><br>";
                                for (var d = 0; d < b.y.smps.length; d++) {
                                    if (this.isMultidimensionalHeatmap) {
                                        var l = [b.y.data[0][d]];
                                        var g = ["outline", "shape", "size"];
                                        for (var c = 0; c < g.length; c++) {
                                            var m = g[c] + "ByData";
                                            if (b.y[this[m]] && b.y[this[m]][0][d]) {
                                                l.push(b.y[this[m]][0][d])
                                            }
                                        }
                                        i += "<b>" + b.y.smps[d] + "</b>: " + l.join(", ") + "<br>"
                                    } else {
                                        i += "<b>" + b.y.smps[d] + "</b>: " + b.y.data[0][d] + "<br>"
                                    }
                                }
                            } else {
                                if (b.t) {
                                    i = "<b>" + b.t.t + "</b><br>Depth: " + b.t.d + "<br>"
                                }
                            }
                        }
                    }
                    return i;
                case "Pie":
                    var n = "<b>" + b.y.smps[0] + "</b><br>";
                    for (var d = 0; d < b.y.vars.length; d++) {
                        var a = sprintf("%." + this.pieSegmentPrecision + "f", (b.y.data[d] / this.varPie.tot) * 100);
                        n += "<b>" + b.y.vars[d] + "</b>: " + b.y.data[d] + " (" + a + "%)<br>"
                    }
                    return n;
                case "Candlestick":
                    return dateFormat(b.y.smps[0], this.timeFormat) + ", " + b.y.close[0];
                case "Correlation":
                    var n;
                    if (this.correlationAxis == "samples") {
                        n = b.y.smps[0] + " vs " + b.y.smps[1]
                    } else {
                        n = b.y.vars[0] + " vs " + b.y.vars[1]
                    }
                    return n;
                case "Venn":
                    for (var e in b.venn.data) {
                        return e + " = " + b.venn.data[e]
                    }
                case "Network":
                    var n;
                    if (b && b.nodes) {
                        if (b.nodes[0]) {
                            n = b.nodes[0].hideTooltip ? "" : b.nodes[0].tooltip || b.nodes[0].name || b.nodes[0].label || b.nodes[0].id
                        }
                    } else {
                        if (b && b.edges) {
                            var h = this.nodes[b.edges[0].id1];
                            var f = this.nodes[b.edges[0].id2];
                            n = (h.label || h.id) + " - " + (f.label || f.id);
                            n = b.edges[0].hideTooltip ? "" : b.edges[0].tooltip || b.edges[0].name || b.edges[0].label || n
                        }
                    }
                    return n;
                case "Genome":
                    return b.name || b[0].data[0].id
            }
        } else {
            return ""
        }
    };
    this.setUserEvents = function () {
        this.userEvents = {};
        if (this.disableEvents) {
            return
        }
        var b = this;
        if (this.events && this.events.enddragnode) {
            this.userEvents.enddragnode = this.events.enddragnode
        }
        if (this.events && this.events.stackchange) {
            this.userEvents.stackchange = this.events.stackchange
        }
        if (this.events && this.events.enddraw) {
            this.userEvents.enddraw = this.events.enddraw
        }
        if (this.events && this.events.mouseout) {
            this.userEvents.mouseout = this.events.mouseout
        } else {
            this.userEvents.mouseout = function (h, g, f, d) {
                f.resetInfoSpan(g)
            }
        }
        if (this.events && this.events.contextmenu) {
            this.userEvents.contextmenu = this.events.contextmenu
        } else {
            this.userEvents.contextmenu = function (h, g, f, d) {
                if (f.graphType == "Network") {
                    if (h && h.nodes && h.nodes.length == 1) {
                        if (f.selectNode && !f.selectNode[h.nodes[0].id]) {
                            f.addRemoveToSelectedDataPoints(false, d)
                        }
                    } else {
                        if (h && h.edges && h.edges.length == 1) {}
                    }
                }
                
            }
        }
        if (this.events && this.events.click) {
            this.userEvents.click = this.events.click
        } else {
            this.userEvents.click = function (h, g, f, d) {
                if (h && h.t) {
                    f.modifyDendrogram(h)
                } else {
                    if (h.nodes && h.nodes.length == 1 && h.nodes[0].links) {
                        f.showLinkDiv(g, h.nodes[0].links, h.nodes[0].label != null ? h.nodes[0].label : h.nodes[0].name ? h.nodes[0].name : h.nodes[0].id)
                    } else {
                        if (h.edges && h.edges.length == 1 && h.edges[0].links) {
                            f.showLinkDiv(g, h.edges[0].links, h.edges[0].label != null ? h.edges[0].label : h.edges[0].name ? h.edges[0].name : h.edges[0].id1 + "-" + h.edges[0].id2)
                        } else {
                            f.updateDataTable(h)
                        }
                    }
                }
                return false
            }
        }
        if (this.events && this.events.dblclick) {
            this.userEvents.dblclick = this.events.dblclick
        } else {
            this.userEvents.dblclick = function (f, d) {
                if (f) {
                    alert(b.prettyJSON(f))
                }
                return false
            }
        }
        var c = ["mouseover", "mousemove"];
        for (var a = 0; a < c.length; a++) {
            if (this.events && this.events[c[a]]) {
                this.userEvents[c[a]] = this.events[c[a]]
            } else {
                this.userEvents[c[a]] = function (g, d) {
                    var f = b.getSummaryDataObject(g);
                    if (f && f != "") {
                        b.showInfoSpan(d, f)
                    }
                }
            }
        }
    };
    this.resetFlags = function (a) {
        this.resetOn = true;
        this.animationOn = false;
        this.draggingOn = false;
        this.movingOn = false;
        this.panningOn = false;
        this.changingColorOn = false;
        this.keyOn = false;
        this.xMouseDown = false;
        this.yMouseDown = false;
        this.touches = false;
        this.toucheEvent = false;
        this.moveNode = false;
        this.moveNodeIndex = false;
        this.moveNodeLab = false;
        this.moveNodeDec = false;
        this.moveLegend = false;
        this.moveNodeX = false;
        this.moveNodeY = false;
        this.moveNodeW = false;
        this.moveNodeH = false;
        this.moveGenome = false;
        this.moveVar = false;
        this.moveSmp = false;
        if (a) {
            this.stopEvent(a)
        }
        document.defaultAction = true;
        document.body.style.cursor = "default"
    };
    this.mousemoveDoc = function (a) {
        return function (f) {
            
			if (!f) {
                f = window.event
            }
            var b = f.target || f.srcElement;
			
			if (a.target == "canvas" && !CanvasXpress.resizing) {
                CanvasXpress.current = a.target
            }
            if ((CanvasXpress.current && CanvasXpress.current == a.target) || CanvasXpress.resizing) {
                if (!this.toolbarPermanent) {
                    a.isToolbar(f)
                }
                if (a.isVersion(f)) {
                    var g = document.getElementById(a.target);
                    g.style.cursor = "help";
                    a.showInfoSpan([f.clientX, f.clientY + 50], "CanvasXpress (" + a.version + ")")
                } else {
                    if (a.filteringNumericOn) {
                        a.preventSelection();
                        a.updateNumericFilter(f)
                    } else {
                        if (a.draggingTargetOn) {
                            a.preventSelection();
                            a.updateMousemove(f)
                        } else {
                            if (a.resizingDaxtaTableOn) {
                                a.preventSelection();
                                a.updateDataTableResizerDiv(f)
                            } else {
                                if (a.axesResizingOn) {
                                    a.preventSelection();
                                    a.mousemoveAxesResize(f)
                                } else {
                                    if (a.resizingSuggestionsDivOn) {
                                        a.preventSelection();
                                        a.updateSuggestionsDivResizer(f)
                                    } else {
                                        if (a.resizingDataTableColumnOn) {
                                            a.preventSelection();
                                            a.mousemoveDataTableHeader(f)
                                        } else {
                                            if (a.changingColorOn) {
                                                a.preventSelection();
                                                a.updateColorValue(f)
                                            } else {
                                                if (!a.configuringOn) {
                                                    if (a.draggingOn) {
                                                        a.preventSelection();
                                                        a.cancelEvent(f);
                                                        a.updateDrag(f);
                                                        a.lastCanvasEvent = "drag"
                                                    } else {
                                                        if (a.resizingCanvasOn && a.resizeCanvasCursorShow) {
                                                            a.preventSelection();
                                                            a.cancelEvent(f);
                                                            a.updateCanvasResizer(f);
                                                            a.lastCanvasEvent = "resize"
                                                        } else {
                                                            if (a.mobileApp) {} else {
                                                                a.cancelEvent(f);
                                                                a.updateCanvasResizerCursor(f)
                                                            }
                                                        }
                                                    }
                                                    var d = a.graphType == "Genome" ? a.isEvent(f, false, true) : a.isEvent(f);
                                                    if (d) {
                                                        a.handleMouseEvents("mousemove", f, d)
                                                    } else {
                                                        a.resetInfoSpan(f, true)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false
        }
    }(this);
    this.registerMousemove = function (a) {
        return function (c) {
            if (!c) {
                c = window.event
            }
            var b = c.target || c.srcElement;
            if ((c.button == 1 && window.event != null || c.button == 0) && b.className == "draggable") {
                if (a.activeTarget) {
                    a.activeTarget.style.zIndex = 10000
                }
                a.draggableTarget = b.parentNode && b.parentNode.className == "draggable-container" ? b.parentNode : b;
                a.activeTarget = a.draggableTarget;
                a.activeTarget.style.zIndex = 10001;
                a.xMouseDown = c.clientX;
                a.yMouseDown = c.clientY;
                a.draggableXoffset = parseInt(a.draggableTarget.style.left) || 0;
                a.draggableYoffset = parseInt(a.draggableTarget.style.top) || 0;
                a.draggingTargetOn = true
            }
        }
    }(this);
    this.updateMousemove = function (b) {
        if (!b) {
            b = window.event
        }
        if (this.draggableTarget && this.draggableTarget.style) {
            var a = this.draggableXoffset + b.clientX - this.xMouseDown;
            var c = this.draggableYoffset + b.clientY - this.yMouseDown;
            this.draggableTarget.style.left = a + "px";
            this.draggableTarget.style.top = c + "px";
            this.draggableLastX = a;
            this.draggableLastY = c;
            if (this.draggableTarget.id == this.target + "canvasXpressDataTable" && this.dataTableLastState == "docked") {
                this.moveDataTableDiv("release")
            }
        }
    };
    this.endMousemove = function (a) {
        if (this.draggableTarget != null) {
            this.moveDataTableDiv();
            document.onselectstart = null;
            this.xMouseDown = null;
            this.yMouseDown = null;
            this.draggableXoffset = null;
            this.draggableYoffset = null;
            this.draggableTarget.ondragstart = null;
            this.draggableTarget = false;
            this.draggingTargetOn = false
        }
    };
    this.mouseupDoc = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            if (CanvasXpress.current && CanvasXpress.current == a.target) {
                if (a.draggingTargetOn) {
                    a.endMousemove(b)
                } else {
                    if (a.resizingDataTableOn) {
                        a.endDataTableResizerDiv(b)
                    } else {
                        if (a.resizingSuggestionsDivOn) {
                            a.endSuggestionsDivResizer(b)
                        } else {
                            if (a.resizingDataTableColumnOn) {
                                a.endDataTableColumnResize(b)
                            } else {
                                if (a.changingColorOn) {
                                    a.endColorChange(b)
                                } else {
                                    if (!a.configuringOn) {
                                        a.stopEvent(b);
                                        a.endDrag(b);
                                        a.endCanvasResizer(b);
                                        a.endAxesResizer(b);
                                        a.endNumericFilter(b);
                                        a.endStringFilter(b);
                                        a.resizeViewport(b);
                                        a.resizeDataFilter(b);
                                        a.resetFlags(b)
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }(this);
    this.touchendDoc = function (a) {
        return function (g) {
            if (CanvasXpress.current && CanvasXpress.current == a.target) {
                if (!a.touchEvent || !a.mobileApp || !a.touches) {
                    return a.mouseupDoc(g)
                }
                var f = a.layoutComb ? a.layoutParams[a.layoutValidN].graphType : a.graphType;
                var d = a;
                var b = function () {
                    clearTimeout(b);
                    if (d.touches.length > 1) {
                        var k = d.touches[0];
                        var j = d.touches[1];
                        var r = Math.abs(j[0] - k[0]);
                        var q = Math.abs(j[1] - k[1]);
                        var n = Math.atan2(j[1] - k[1], j[0] - k[0]) * 180 / Math.PI;
                        if (r < 20 && q < 20) {
                            d.touchEvent = "dbltap"
                        } else {
                            d.touchEvent = "pinch"
                        }
                    } else {
                        if (d.touchEvent != "drag") {
                            if (d.touchEvent == "dbltap" || d.touchEvent == "pinch") {
                                return false
                            }
                            d.touchEvent = "tap"
                        }
                    }
                    if (d.touchEvent == "pinch" && d.touchesEnd.length > 1) {
                        if (d.graphType.match(/Network|Genome|Heatmap|Bar|Line|Dotplot|Boxplot|Area|Stacked|Scatter3D|Circular/)) {
                            var o = d.euclidianDistance([d.touches[0][0], d.touches[1][0]], [d.touches[0][1], d.touches[1][1]]);
                            var e = d.euclidianDistance([d.touchesEnd[0][0], d.touchesEnd[1][0]], [d.touchesEnd[0][1], d.touchesEnd[1][1]]);
                            var p = (d.touchesEnd[0][0] + d.touchesEnd[1][0]) / 2;
                            var m = (d.touchesEnd[0][1] + d.touchesEnd[1][1]) / 2;
                            var l = d.zoomStep;
                            d.zoomStep *= 3;
                            d.resetFlags(g);
                            d.handleWheelEvent(g, e - o, {
                                x: p,
                                y: m
                            });
                            d.zoomStep = l
                        }
                        d.touchesEnd = false;
                        return false
                    } else {
                        if (d.touchEvent == "dbltap") {
                            d.stopEvent(g);
                            d.addConfigurator(g, false, 3, 3);
                            d.resetFlags(g);
                            return false
                        } else {
                            if (d.touchEvent == "tap") {
                                var h = d.getEventDataId(g);
                                if (h) {
                                    d.handleMouseEvents("click", g, h)
                                } else {
                                    d.resetSelectedObjects()
                                }
                                d.resetFlags(g);
                                return false
                            }
                        }
                    }
                    d.stopEvent(g);
                    d.endDrag(g);
                    d.endCanvasResizer(g);
                    d.endAxesResizer(g);
                    d.resetFlags(g)
                };
                var c = a.adjustedCoordinates(g);
                if (c) {
                    if (!a.touchesEnd) {
                        a.touchesEnd = []
                    }
                    a.touchesEnd.push([c.x, c.y, new Date().getTime()]);
                    setTimeout(b, 250)
                }
            }
        }
    }(this);
    this.keydownDoc = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
			//alert("#"+CanvasXpress.current + "$  $" + a.target + "hello");
			if (CanvasXpress.current && CanvasXpress.current == a.target) {
                a.registerKey(b)
            }
        }
    }(this);
    this.keyupDoc = function (a) {
        return function (c) {
            if (!c) {
                c = window.event
            }
            var b = c.target || c.srcElement;
            if (CanvasXpress.current && CanvasXpress.current == a.target) {
                a.keyOn = false;
                if (a.configuringOn) {
                    a.selectConfig(c)
                } else {
                    if (b.id.match(/canvasXpressDataFilterInput/)) {
                        a.updateStringSelectFilter(b.id)
                    } else {
                        if (a.remoteService) {
                            a.selectDataSet(c)
                        }
                    }
                }
            }
        }
    }(this);
    this.resizeWindow = function (a) {
        return function (b) {
            if (!b) {
                b = window.event
            }
            if (a.resizeImage) {
                a.resizeImage(true)
            }
            return false
        }
    }(this);
    this.initDocEvents = function () {
		
        this.addEvtListener(document, "mousemove", this.mousemoveDoc, false);
        this.addEvtListener(document, "touchmove", this.mousemoveDoc, false);
        this.addEvtListener(document, "mouseup", this.mouseupDoc, false);
        this.addEvtListener(document, "touchend", this.touchendDoc, false);
        this.addEvtListener(document, "keydown", this.keydownDoc, false);
        this.addEvtListener(document, "keyup", this.keyupDoc, false);
        this.addEvtListener(window, "resize", this.resizeWindow, false)
    };
    this.initializeEvents = function () {
        this.setUserEvents();
        this.initLinkEvents();
        this.initViewport();
        this.initConfigurator();
        this.initToolbar();
        this.initDataFilter();
        this.initDataTable();
        this.initDraggingEvents();
        this.initCanvasResizerEvents();
        this.initAxisResizerEvents();
        this.initInfoEvents();
		this.initKeyEvents();
		this.initSelectEvents();
        this.initDendrogramEvents();
        this.initCanvasEvents();
        this.initAcknowlegments();
        this.initCodeInfo();
        this.initDocEvents();
        this.initCleanupEvents()
    };
    this.initializeEvents()
};
CanvasXpress.prototype.initAnimation = function () {
    this.saveSnapshot = function () {
        var a = this.cloneVisualData(this.data);
        if (a) {
            this.snapshots.push(a)
        }
    };
    this.playSnapshot = function (b, d, c) {
        if (this.snapshots.length < 1) {
            return
        }
        this.stopSnapshotPlay();
        var a = this;
        this.snapshotPlay = {
            idx: 0,
            time: b,
            task: setTimeout(function () {
                a.nextSnapshot(c)
            }, 0),
            callback: d,
            oldData: this.data
        };
        this.snapshotPaused = false
    };
    this.nextSnapshot = function (c) {
        if (this.snapshotPlay.idx >= this.snapshots.length) {
            if (this.snapshotPlay.callback) {
                this.snapshotPlay.callback.call(this, c)
            } else {
                this.snapshotPlay.idx = 0
            }
        }
        if (this.snapshotPlay) {
            var b = this.snapshotPlay.time || this.snapshots[this.snapshotPlay.idx].time || 50;
            this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
            var a = this;
            this.snapshotPlay.task = setTimeout(function () {
                a.nextSnapshot(c)
            }, b);
            this.snapshotPaused = false
        }
    };
    this.stopSnapshotPlay = function (a) {

    };
    this.clearSnapshot = function () {
        this.stopSnapshotPlay(true);
        this.snapshots = [];
        this.snapshotPaused = false
    };
    this.duplicateSnapshot = function () {
        if (this.snapshots.length < 1) {
            return
        }
        var a = (this.snapshotPlay ? this.snapshotPlay.idx : this.snapshots.length) - 1;
        var b = this.cloneVisualData(this.snapshots[a]);
        if (this.snapshotPlay) {
            this.snapshots.splice(a + 1, 0, b);
            this.snapshotPlay.idx++
        } else {
            this.snapshots.push(b)
        }
    };
    this.makeSnapshotPlay = function () {
        if (!this.snapshotPlay) {
            this.snapshotPlay = {
                idx: this.snapshots.length,
                oldData: this.data
            }
        } else {
            this.pauseSnapshot()
        }
    };
    this.moveSnapshot = function (c) {
        if (this.snapshots.length < 1) {
            return
        }
        this.makeSnapshotPlay();
        var b = this.snapshotPlay.idx - 1,
            a = b + c;
        if (a >= 0 && a <= this.snapshots.length) {
            this.snapshots.splice(a, 0, (this.snapshots.splice(b, 1))[0])
        }
        this.snapshotPlay.idx = a + 1
    };
    this.prevSnapshotOnce = function () {
        if (this.snapshots.length < 2) {
            return
        }
        this.makeSnapshotPlay();
        this.snapshotPlay.idx -= 2;
        if (this.snapshotPlay.idx < 0) {
            this.snapshotPlay.idx = 0
        }
        this.loadData(this.snapshots[this.snapshotPlay.idx++], true);
        this.snapshotPaused = true
    };
    this.nextSnapshotOnce = function () {
        if (!this.snapshotPlay) {
            return
        }
        if (this.snapshotPlay.idx < this.snapshots.length) {
            this.loadData(this.snapshots[this.snapshotPlay.idx++], true)
        }
        this.snapshotPaused = true
    };
    this.hasNextSnapshot = function () {
        return this.snapshots.length > 1 && this.snapshotPlay && this.snapshotPaused && this.snapshotPlay.idx < this.snapshots.length
    };
    this.hasPrevSnapshot = function () {
        return this.snapshots.length > 1 && (!this.snapshotPlay || (this.snapshotPlay.idx > 1 && this.snapshotPaused))
    };
    this.updateSnapshot = function () {
        if (this.snapshotPlay) {
            this.snapshots[this.snapshotPlay.idx - 1] = this.cloneVisualData(this.data)
        }
    };
    this.pauseSnapshot = function () {
        if (!this.snapshotPlay) {
            return
        }
        if (this.snapshotPlay.task) {
            clearTimeout(this.snapshotPlay.task)
        }
        this.snapshotPaused = true
    };
    this.setSnapshotTime = function (a) {
        if (a > 0) {
            this.snapshots[this.snapshotPlay.idx - 1].time = a
        }
    };
    this.getSnapshotTime = function () {
        return this.snapshots[this.snapshotPlay.idx - 1].time || 50
    };
    this.assembleObj = function (b, k, m) {
        var e = [];
        if (!k[m]) {
            return b[m]
        }
        if (!k[m].indices) {
            k[m].indices = {}
        }
        for (var h = 0; h < b[m].length; h++) {
            var f = b[m][h],
                a = f.id || f.id1 + "-" + f.id2;
            if (!k[m].deleted[a]) {
                var l = k[m].changed[a];
                if (l) {
                    for (var g in l) {
                        f[g] = l[g]
                    }
                }
                var p = k[m].indices[a] != null ? k[m].indices[a] : m == "nodes" ? b.nodeIndices[a] : b.edgeIndices[a];
                e[p] = f;
                k[m].indices[a] = p
            }
        }
        for (var a in k[m].added) {
            e[k[m].indices[a]] = k[m].added[a]
        }
        return e
    };
    this.assembleData = function (b, c) {
        var a = {};
        a.nodes = this.assembleObj(b, c, "nodes");
        a.nodeIndices = c.nodes && c.nodes.indices ? c.nodes.indices : b.nodeIndices;
        a.edges = this.assembleObj(b, c, "edges");
        a.legend = c.legend || b.legend;
        return a
    };
    this.loadData = function (d, e) {
        this.data = d;
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Circular":
                break;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
                return false;
                break;
            case "Network":
                if (this.data.type == "changedData") {
                    this.data = this.assembleData(this.cloneObject(this.snapshotsBase), this.cloneObject(this.data))
                }
                this.edges = this.data.edges;
                var b = {};
                for (var c = 0; c < this.data.nodes.length; c++) {
                    var a = this.data.nodes[c];
                    b[a.id] = a
                }
                this.nodes = b;
                break
        }
        if (e) {
            this.draw(false, false, true)
        }
    };
    this.changedNodeData = function (c, g) {
        var i = {
            deleted: {},
            changed: {},
            added: {}
        };
        for (var b in c.nodeIndices) {
            var j = g.nodeIndices[b];
            if (j == null) {
                i.deleted[b] = 1
            } else {
                var h = c.nodes[c.nodeIndices[b]],
                    e = g.nodes[j],
                    k = {
                        id: b
                    }, f = false;
                for (var a in e) {
                    if (!this.isSameObject(e[a], h[a])) {
                        k[a] = e[a];
                        f = true
                    }
                }
                if (f) {
                    i.changed[b] = k
                }
            }
        }
        for (var b in g.nodeIndices) {
            if (c.nodeIndices[b] == null) {
                i.added[b] = g.nodes[g.nodeIndices[b]]
            }
        }
        i.indices = this.changedIndices(c.nodeIndices, g.nodeIndices);
        return i
    };
    this.getEdgeIndices = function (f) {
        var b = {};
        if (f.edges.length) {
            for (var a = 0; a < f.edges.length; a++) {
                var c = f.edges[a];
                b[c.id1 + "-" + c.id2] = a
            }
        }
        return b
    };
    this.changedEdgeData = function (f, g) {
        var c = {
            deleted: {},
            changed: {},
            added: {}
        };
        if (!f.edgeIndices) {
            f.edgeIndices = this.getEdgeIndices(f)
        }
        var e = this.getEdgeIndices(g);
        for (var h in f.edgeIndices) {
            var a = e[h];
            if (a == null) {
                c.deleted[h] = 1
            } else {
                var b = g.edges[a];
                if (!this.isSameObject(f.edges[f.edgeIndices[h]], b)) {
                    c.changed[h] = b
                }
            }
        }
        for (var h in e) {
            if (f.edgeIndices[h] == null) {
                c.added[h] = g.edges[e[h]]
            }
        }
        c.indices = this.changedIndices(f.edgeIndices, e);
        return c
    };
    this.changedIndices = function (b, c) {
        var a = {};
        for (var e in c) {
            if (b[e] == null || b[e] != c[e]) {
                a[e] = c[e]
            }
        }
        return a
    };
    this.getSnapshotChanged = function (b) {
        var a = this.snapshotsBase;
        return {
            type: "changedData",
            nodes: this.changedNodeData(a, b),
            edges: this.changedEdgeData(a, b),
            legend: this.isSameObject(a.legend, b.legend) ? null : b.legend
        }
    };
    this.cloneVisualData = function (f) {
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
            case "Circular":
                return this.cloneObject(f);
                break;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
                return false;
                break;
            case "Network":
                if (this.snapshotCopyChangeOnly) {
                    if (this.snapshots.length) {
                        return f.type == "changedData" ? this.cloneObject(f) : this.getSnapshotChanged(f)
                    } else {
                        this.snapshotsBase = this.cloneObject(f);
                        return {
                            type: "changedData"
                        }
                    }
                }
                if (!this.snapshotNoCopyData) {
                    return this.cloneObject(f)
                }
                var c = {
                    nodes: [],
                    edges: []
                };
                if (f.nodes && f.nodes.length) {
                    for (var b = 0; b < f.nodes.length; b++) {
                        var g = {};
                        var e = f.nodes[b];
                        var h = ["outline", "width", "height", "pattern", "rotate", "color", "shape", "size", "x", "y", "id", "hideLabel", "hideChildren", "hideParent", "label", "labelX", "labelY", "labelSize", "name", "hide", "anchor", "parentNode", "imagePath"];
                        for (var a = 0; a < h.length; a++) {
                            g[h[a]] = e[h[a]]
                        }
                        c.nodes.push(g)
                    }
                }
                if (f.edges && f.edges.length) {
                    for (var b = 0; b < f.edges.length; b++) {
                        var g = {};
                        var e = f.edges[b];
                        var h = ["color", "width", "type", "id1", "id2", "anchor"];
                        for (var a = 0; a < h.length; a++) {
                            g[h[a]] = e[h[a]]
                        }
                        c.edges.push(g)
                    }
                }
                return c;
                break
        }
    };
    this.isValidAnimation = function () {
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
                return true;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
            case "Network":
            case "Circular":
                return false
        }
    };
    this.createAnimation = function (e) {
        switch (this.graphType) {
            case "Bar":
            case "Line":
            case "BarLine":
            case "Dotplot":
            case "Scatter2D":
            case "ScatterBubble2D":
                this.isAnimation = true;
                var f = this.cloneVisualData(this.data);
                if (e.match(/grow|spring|random/) && this.data.y.data) {
                    var d = this.animationCycles;
                    for (var c = 0; c < d; c++) {
                        for (var b = 0; b < this.data.y.data.length; b++) {
                            for (var a = 0; a < this.data.y.data[b].length; a++) {
                                if (!isNaN(this.data.y.data[b][a])) {
                                    var g = this.data.y.data[b][a];
                                    if (e == "grow") {
                                        this.data.y.data[b][a] = g / d * c
                                    } else {
                                        if (e == "spring") {
                                            this.data.y.data[b][a] = g / (d - 1.5) * (c + 1)
                                        } else {
                                            this.data.y.data[b][a] = g / d * Math.floor(Math.random() * c)
                                        }
                                    }
                                }
                            }
                        }
                        this.saveSnapshot();
                        this.data = this.cloneVisualData(f)
                    }
                }
                this.data = f;
                this.saveSnapshot();
                this.playSnapshot(this.animationTime, this.stopAnimation);
                break;
            case "Scatter3D":
            case "Area":
            case "AreaLine":
            case "Boxplot":
            case "Heatmap":
            case "Stacked":
            case "StackedLine":
            case "StackedPercent":
            case "StackedPercentLine":
            case "Candlestick":
            case "Correlation":
            case "Venn":
            case "Pie":
            case "Genome":
            case "Network":
            case "Circular":
                return;
                break
        }
    };
    this.stopAnimation = function () {
        this.stopSnapshotPlay();
        this.snapshots = [];
        this.isAnimation = false
    };
    this.setSnapshotsData = function (a) {
        this.snapshots = a.ss || a;
        this.snapshotsBase = a.base
    };
    this.getSnapshotsData = function () {
        return {
            base: this.snapshotsBase,
            ss: this.snapshots
        }
    };
    this.createDemoNetworkAnimation = function (h) {
        var p = [],
            e = {}, q = [];
        for (var u = 0; u < h; u++) {
            var n = u + 1;
            p.push({
                size: 0.5,
                x: Math.floor(Math.random() * h * 5),
                y: Math.floor(Math.random() * h * 5),
                outline: "rgb(255,255,255)",
                color: "rgb(255,0,0)",
                id: n,
                label: n,
                hideLabel: true,
                labelSize: 0.7,
                name: "Node " + n,
                pattern: "closed",
                shape: "star"
            });
            e[n] = u
        }
        var d = {
            nodes: p,
            nodeIndices: e,
            edges: [],
            edgeIndices: {}
        };
        q.push({
            type: "changedData"
        });
        var s = 10;
        var b = 5;
        var o = 255 / b;
        var a = 0.5 / b;
        var k = 5;
        for (var t = 0; t < s; t++) {
            var m = Math.floor(Math.random() * p.length);
            for (var u = 0; u < b; u++) {
                var g = Math.floor(255 - (u + 1) * o);
                var l = Math.floor((u + 1) * o),
                    v = [g, l, l];
                var f = {};
                f[p[m].id] = {
                    size: 0.5 + a * (u + 1),
                    color: "rgb(" + v.join(",") + ")"
                };
                q.push({
                    type: "changedData",
                    nodes: {
                        deleted: {},
                        added: {},
                        changed: f
                    },
                    time: 5
                })
            }
        }
        this.setSnapshotsData({
            base: d,
            ss: q
        })
    };
    this.createDemoNetworkAnimation1 = function () {
        var b = [];
        var l = {};
        var o = [];
        var n = 10;
        var m = 200;
        var a = "ball";
        var f = {
            width: n,
            x: 100,
            y: 0,
            color: "rgb(0,255,0)",
            id: a,
            label: a,
            hideLabel: true,
            labelSize: 0.7,
            name: a,
            pattern: "closed",
            shape: "sphere"
        };
        a = "plank";
        var g = {
            width: 200,
            height: 5,
            x: 100,
            y: m,
            color: "rgb(255,255,0)",
            id: a,
            label: a,
            hideLabel: true,
            labelSize: 0.7,
            name: a,
            pattern: "closed",
            shape: "rectangle"
        };
        a = "ref";
        var d = {
            width: 10,
            x: 80,
            y: 0,
            color: "rgb(0,0,255)",
            id: a,
            label: a,
            hideLabel: true,
            labelSize: 0.7,
            name: a,
            pattern: "closed",
            shape: "sphere"
        };
        var c = {
            nodes: [f, g, d],
            nodeIndices: {
                ball: 0,
                plank: 1,
                ref: 2
            },
            edges: [],
            edgeIndices: {}
        };
        o.push({
            type: "changedData"
        });
        for (var k = 1, h = 0; h < m - n / 2; h += n / 2, k += 0.1) {
            var e = k * k;
            o.push({
                type: "changedData",
                nodes: {
                    deleted: {},
                    added: {},
                    changed: {
                        ball: {
                            y: h,
                            time: 25 * n > h ? 50 - h * 2 / n : 5
                        }
                    }
                },
                time: 100 / e
            })
        }
        this.setSnapshotsData({
            base: c,
            ss: o
        })
    };
    this.fade = function (e, a, f, d) {
        if (e) {
            if (!a) {
                a = 1000
            }
            if (e.fadeState == null) {
                if (e.style.opacity == null || e.style.opacity == "" || e.style.opacity == "1") {
                    e.fadeState = 2
                } else {
                    e.fadeState = -2
                }
            }
            if (e.fadeState == 1 || e.fadeState == -1) {
                e.fadeState = e.fadeState == 1 ? -1 : 1;
                e.fadeleft = a - e.fadeleft
            } else {
                var b = this;
                e.fadeState = e.fadeState == 2 ? -1 : 1;
                e.fadeleft = a;
                setTimeout(function () {
                    b.animateFade(new Date().getTime(), e, f, d)
                }, 33)
            }
        }
    };
    this.animateFade = function (a, h, j, d) {
        var b = this;
        var g = new Date().getTime();
        var f = g - a;
        if (h.fadeleft <= f) {
            h.style.opacity = h.fadeState == 1 ? "1" : "0";
            h.style.filter = "alpha(opacity = " + (h.fadeState == 1 ? "100" : "0") + ")";
            h.fadeState = h.fadeState == 1 ? 2 : -2;
            if (j != null) {
                j()
            }
            if (d) {
                setTimeout(function () {
                    b.resetFade(h);
                    for (var c = 0; c < d.length; c++) {
                        delete(h.style[d[c]])
                    }
                }, 500)
            }
            return
        }
        h.fadeleft -= f;
        var i = h.fadeleft / 1000;
        if (h.fadeState == 1) {
            i = 1 - i
        }
        h.style.opacity = i;
        h.style.filter = "alpha(opacity = " + (i * 100) + ")";
        setTimeout(function () {
            b.animateFade(g, h, j)
        }, 33)
    };
    this.resetFade = function (a) {
        if (a) {
            a.style.opacity = 1;
            a.style.filter = "alpha(opacity = 100)";
            delete(a.fadeState);
            delete(a.fadeleft)
        }
    };
    this.resizeMove = function (d, b, m, k, e, q, l) {
        if (d) {
            if (!q) {
                q = 500
            }
            var p = parseInt(d.style.left) || 0;
            var i = parseInt(d.style.top) || 0;
            var g = parseInt(d.style.width) || 0;
            var a = parseInt(d.style.height) || 0;
            var j = 1;
            if (q > 0) {
                j = q / 40
            }
            var n = b - p;
            if (n != 0) {
                n /= j
            }
            var h = m - i;
            if (h != 0) {
                h /= j
            }
            var f = k - g;
            if (f != 0) {
                f /= j
            }
            var r = e - a;
            if (r != 0) {
                r /= j
            }
            this.updateResizeMove(d, p, b, n, i, m, h, g, k, f, a, e, r, l)
        }
    };
    this.updateResizeMove = function (d, n, b, m, i, l, h, g, j, f, a, e, q, k) {
        if (d) {
            var p = this;
            n = this.stepResizeMove(n, b, m);
            i = this.stepResizeMove(i, l, h);
            g = this.stepResizeMove(g, j, f);
            a = this.stepResizeMove(a, e, q);
            d.style.left = Math.round(n) + "px";
            d.style.top = Math.round(i) + "px";
            d.style.width = Math.round(g) + "px";
            d.style.height = Math.round(a) + "px";
            if (n == b && i == l && a == e && g == j) {
                if (k != null) {
                    k()
                }
                return
            }
            setTimeout(function () {
                p.updateResizeMove(d, n, b, m, i, l, h, g, j, f, a, e, q, k)
            }, 40)
        }
    };
    this.stepResizeMove = function (d, b, a) {
        if (a == 0 || d == b) {
            return b
        }
        d += a;
        if ((a > 0 && d >= b) || (a < 0 && d <= b)) {
            return b
        }
        return d
    };
    this.transitionAccordion = function (a, d, h, j) {
        var f = this;
        var b = new Date().getTime();
        var g = b - a;
        if (d <= g) {
            if (h) {
                h.style.height = this.dataFilterHeight + "px"
            }
            if (j) {
                j.style.height = "0px";
                j.style.display = "none"
            }
            if (h) {
                if (h.clientWidth - h.scrollWidth) {
                    this.resizeDataFilterForScroller(true)
                } else {
                    if (h.clientHeight < this.canvas.height && this.dataFilterScroller) {
                        this.resizeDataFilterForScroller()
                    }
                }
            }
            return
        }
        d -= g;
        var i = Math.round((d / 250) * this.dataFilterHeight);
        if (h) {
            if (h.style.display != "block") {
                h.style.display = "block"
            }
            h.style.height = (this.dataFilterHeight - i) + "px"
        }
        if (j) {
            j.style.height = i + "px"
        }
        setTimeout(function () {
            f.transitionAccordion(b, d, h, j)
        }, 33)
    }
};
CanvasXpress.prototype.initExample = function () {
    this.exampleRawData = {
        x: {
            Tissue: ["Kidney", "Liver", "Kidney", "Liver", "Kidney", "Liver", "Kidney", "Liver"],
            Donor: ["D1", "D1", "D1", "D1", "D2", "D2", "D2", "D2"],
            Time: ["1h", "1h", "2h", "2h", "1h", "1h", "2h", "2h"]
        },
        z: {
            Symbol: ["abc", "def", "ghi", "jkl", "mno", "pqr"],
            Cat: ["A", "A", "B", "C", "D", "C"],
            Class: ["A", "A", "A", "A", "A", "B"]
        },
        y: {
            vars: ["Gene1", "Gene2", "Gene3", "Gene4", "Gene5", "Gene6"],
            smps: ["X", "Smp2", "Smp3", "Smp4", "Smp5", "Smp6", "Smp7", "Smp8"],
            desc: ["Intensity", "Normalized Intensity"],
            data: [
                [10, 12, 3, 4, 100, 73, 42, 64],
                [12, 4, 60, 5, 24, 14, 32, 13],
                [7, 12, 20, 13, 49, 52, 42, 92],
                [21, 10, 30, 8, 65, 166, 47, 58],
                [15, 14, 100, 5, 34, 30, 82, 51],
                [100, 82, 73, 4, 3, 4, 5, 2]
            ]
        },
        a: {
            xAxis: ["Gene1", "Gene2", "Gene3"],
            xAxis2: ["Gene4", "Gene5", "Gene6"]
        },
        t: {
            vars: "((Gene6:0.2,Gene3:0.3):0.2,((Gene1:0.25,(Gene4:0.15,Gene2:0.3):0.2):0.3,Gene5:0.7):0.1)",
            smps: "((Smp2:0.8,(Smp4:0.7,((X:0.6,(Smp6:0.2,Smp5:0.1):0.2):0.15,(Smp8:0.15,Smp3:0.05):0.1):0.15):0.2):0.05,Smp7:0.9)"
        },
        d: {
            nlfit: [{
                param: [1, 100, 50, 1, 1.23e-7],
                label: "Fit Example",
                type: "reg"
            }]
        },
        l: {
            vars: [
                ["Gene1", "Gene2", "Gene3", "Gene4", "Gene5"],
                ["Gene6"]
            ],
            weight: [0.7, 0.3],
            type: ["Bar", "Line"],
            desc: ["Intensity", "Score"]
        },
        venn: {
            data: {
                A: 340,
                B: 562,
                C: 620,
                D: 592,
                AB: 639,
                AC: 456,
                AD: 257,
                BC: 915,
                BD: 354,
                CD: 143,
                ABC: 552,
                ABD: 578,
                ACD: 298,
                BCD: 613,
                ABCD: 148
            },
            legend: {
                A: "List 1",
                B: "List 2",
                C: "List 3",
                D: "List 4"
            }
        },
        nodes: [{
            id: "Gene1",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1
        }, {
            id: "Gene2",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1.8
        }, {
            id: "Gene3",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1.4
        }, {
            id: "Gene4",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1.2
        }, {
            id: "Gene5",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1.3
        }, {
            id: "Gene6",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1
        }, {
            id: "Gene7",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1
        }, {
            id: "Gene8",
            color: "rgb(255,0,0)",
            shape: "square",
            size: 1
        }, {
            id: "SNP1",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1
        }, {
            id: "SNP2",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1
        }, {
            id: "SNP3",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1
        }, {
            id: "SNP4",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1.5
        }, {
            id: "SNP5",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1
        }, {
            id: "SNP6",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1
        }, {
            id: "SNP7",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1
        }, {
            id: "SNP8",
            color: "rgb(0,255,0)",
            shape: "sphere",
            size: 1.2
        }, {
            id: "PH1",
            color: "rgb(0,255,255,0.5)",
            shape: "triangle",
            size: 1,
            hideChildren: false
        }, {
            id: "PH2",
            color: "rgb(0,255,255,0.6)",
            shape: "triangle",
            size: 1,
            parentNode: "PH1"
        }, {
            id: "PH3",
            color: "rgb(0,255,255,0.7)",
            shape: "triangle",
            size: 1,
            parentNode: "PH1"
        }, {
            id: "PH4",
            color: "rgb(0,255,255,0.8)",
            shape: "triangle",
            size: 1,
            parentNode: "PH3"
        }],
        edges: [{
            id1: "Gene1",
            id2: "Gene2",
            color: "rgb(51,102,255)",
            width: "1",
            type: "line"
        }, {
            id1: "Gene2",
            id2: "Gene3",
            color: "rgb(51,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "Gene1",
            id2: "Gene4",
            color: "rgb(51,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "Gene3",
            id2: "Gene5",
            color: "rgb(51,102,255)",
            width: "1",
            type: "dashedArrowHeadLine"
        }, {
            id1: "Gene6",
            id2: "Gene5",
            color: "rgb(51,102,255)",
            width: "1",
            type: "arrowHeadSquareTailLine"
        }, {
            id1: "Gene7",
            id2: "Gene5",
            color: "rgb(153,153,255)",
            width: "1",
            type: "dottedArrowHeadLine"
        }, {
            id1: "Gene8",
            id2: "Gene7",
            color: "rgb(51,102,255)",
            width: "1",
            type: "line"
        }, {
            id1: "Gene4",
            id2: "Gene7",
            color: "rgb(51,102,255)",
            width: "1",
            type: "squareHeadArrowTailLine"
        }, {
            id1: "Gene1",
            id2: "SNP2",
            color: "rgb(153,102,255)",
            width: "1",
            type: "bezierLine"
        }, {
            id1: "SNP1",
            id2: "SNP4",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "SNP5",
            id2: "Gene5",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "SNP1",
            id2: "PH2",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "SNP1",
            id2: "Gene2",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "PH4",
            id2: "SNP7",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "PH2",
            id2: "Gene5",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "PH1",
            id2: "Gene7",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "PH3",
            id2: "Gene2",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "SNP6",
            id2: "Gene2",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "SNP3",
            id2: "Gene4",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "SNP4",
            id2: "Gene5",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }, {
            id1: "SNP5",
            id2: "Gene7",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "SNP7",
            id2: "Gene5",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "SNP8",
            id2: "Gene6",
            color: "rgb(153,102,255)",
            width: "1",
            type: "arrowHeadLine"
        }, {
            id1: "SNP8",
            id2: "Gene2",
            color: "rgb(51,102,152)",
            width: "1",
            type: "line"
        }],
        legend: {
            nodes: [],
            edges: []
        },
        tracks: [{
            name: "Affy Probes",
            type: "box",
            connect: true,
            fill: "rgb(255,255,51)",
            outline: "rgb(0,0,0)",
            data: [{
                id: "123456_at",
                dir: "right",
                data: [
                    [10, 20],
                    [30, 40],
                    [50, 60],
                    [70, 80],
                    [90, 100]
                ]
            }, {
                id: "234567_at",
                dir: "left",
                data: [
                    [135, 145],
                    [155, 165],
                    [175, 185],
                    [195, 205],
                    [215, 225]
                ]
            }, {
                id: "345678_at",
                dir: "right",
                data: [
                    [300, 310],
                    [320, 330],
                    [340, 350],
                    [360, 370],
                    [380, 390]
                ]
            }]
        }, {
            name: "Sanger Sequencing",
            subtype: "DNA",
            type: "sequence",
            data: [{
                id: "Reference Sequence",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                sequence: "TACGTACGTACGTACGTACGTACGTACGT",
                translate: [-1, 2]
            }, {
                id: "R1-0000-1234",
                fill: "rgb(255,255,51)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 1,
                gaps: [
                    [4, 2],
                    [8, 1]
                ],
                sequence: "TACGCGTAGTACGT",
                trace: {
                    A: [15, 27, 47, 72, 93, 101, 93, 72, 47, 27, 15, 54, 120, 224, 350, 459, 502, 459, 350, 224, 120, 54, 3, 4, 6, 12, 24, 43, 67, 86, 94, 86, 67, 43, 24, 12, 6, 4, 3, 13, 26, 45, 69, 89, 97, 89, 69, 45, 26, 13, 13, 26, 46, 70, 92, 100, 92, 70, 46, 26, 13, 5, 12, 26, 48, 75, 99, 108, 99, 75, 48, 26, 12, 5, 2, 4, 10, 22, 41, 64, 83, 91, 83, 64, 41, 22, 10, 4, 2, 22, 55, 122, 226, 353, 462, 505, 462, 353, 226, 122, 55, 22, 4, 11, 24, 45, 70, 92, 100, 92, 70, 45, 24, 11, 4, 2, 3, 6, 13, 28, 50, 78, 102, 111, 102, 78, 50, 28, 13, 6, 3, 2, 6, 11, 26, 62, 135, 249, 388, 506, 553, 506, 388, 249, 135, 62, 26, 11, 6, 6, 8, 14, 26, 45, 68, 87, 95, 87, 68, 45, 26, 14, 8, 6, 11, 23, 43, 67, 88, 96, 88, 67, 43, 23, 11, 5, 6, 8, 15, 28, 48, 73, 94, 102, 94, 73, 48, 28, 15, 8, 6, 5],
                    C: [10, 16, 26, 39, 50, 54, 50, 39, 26, 16, 10, 7, 14, 26, 40, 51, 56, 51, 40, 26, 14, 7, 4, 8, 20, 50, 109, 203, 317, 414, 453, 414, 317, 203, 109, 50, 20, 8, 4, 9, 16, 26, 39, 51, 55, 51, 39, 26, 16, 9, 56, 123, 229, 357, 467, 511, 467, 357, 229, 123, 56, 2, 6, 12, 22, 35, 45, 49, 45, 35, 22, 12, 6, 2, 1, 3, 6, 13, 25, 39, 50, 55, 50, 39, 25, 13, 6, 3, 1, 5, 8, 15, 26, 39, 50, 55, 50, 39, 26, 15, 8, 5, 2, 5, 11, 21, 32, 42, 46, 42, 32, 21, 11, 5, 2, 2, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 2, 5, 5, 6, 9, 16, 25, 37, 47, 51, 47, 37, 25, 16, 9, 6, 5, 5, 10, 24, 56, 121, 223, 347, 453, 495, 453, 347, 223, 121, 56, 24, 10, 6, 13, 24, 37, 48, 52, 48, 37, 24, 13, 6, 5, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 5],
                    G: [7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 4, 7, 13, 19, 25, 27, 25, 19, 13, 7, 4, 3, 3, 3, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 3, 3, 3, 56, 122, 226, 353, 461, 504, 461, 353, 226, 122, 56, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 22, 58, 130, 245, 383, 502, 549, 502, 383, 245, 130, 58, 22, 1, 1, 3, 7, 12, 18, 24, 26, 24, 18, 12, 7, 3, 1, 1, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 19, 51, 114, 213, 334, 437, 478, 437, 334, 213, 114, 51, 19, 2, 2, 3, 4, 8, 14, 21, 26, 29, 26, 21, 14, 8, 4, 3, 2, 2, 5, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 5, 5, 5, 7, 10, 15, 20, 25, 27, 25, 20, 15, 10, 7, 5, 5, 53, 119, 223, 349, 457, 500, 457, 349, 223, 119, 53, 5, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 5],
                    T: [62, 135, 249, 388, 507, 554, 507, 388, 249, 135, 62, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 3, 3, 3, 4, 5, 7, 9, 12, 12, 12, 9, 7, 5, 4, 3, 3, 3, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 7, 22, 58, 130, 244, 383, 501, 548, 501, 383, 244, 130, 58, 22, 7, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 3, 8, 21, 54, 119, 222, 347, 454, 497, 454, 347, 222, 119, 54, 21, 8, 3, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 6, 11, 25, 61, 131, 242, 377, 492, 538, 492, 377, 242, 131, 61, 25, 11, 6],
                    peak: [5, 16, 30, 44, 55, 67, 81, 95, 108, 123, 140, 156, 169, 183]
                }
            }, {
                id: "R1-0000-2345",
                fill: "rgb(255,255,102)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 6,
                gaps: [
                    [3, 1],
                    [10, 1]
                ],
                sequence: "ACGACGTACGACG",
                trace: {
                    A: [49, 110, 206, 323, 424, 463, 424, 323, 206, 110, 49, 3, 5, 12, 24, 45, 69, 90, 98, 90, 69, 45, 24, 12, 5, 3, 5, 7, 14, 28, 49, 75, 97, 105, 97, 75, 49, 28, 14, 7, 5, 5, 10, 25, 61, 132, 245, 382, 499, 545, 499, 382, 245, 132, 61, 25, 10, 5, 7, 13, 27, 48, 74, 96, 105, 96, 74, 48, 27, 13, 7, 4, 6, 13, 25, 46, 70, 91, 100, 91, 70, 46, 25, 13, 6, 4, 4, 7, 14, 27, 49, 76, 99, 108, 99, 76, 49, 27, 14, 7, 4, 3, 8, 22, 57, 125, 234, 366, 479, 524, 479, 366, 234, 125, 57, 22, 8, 3, 5, 8, 15, 30, 52, 80, 104, 113, 104, 80, 52, 30, 15, 8, 5, 7, 13, 25, 44, 66, 86, 94, 86, 66, 44, 25, 13, 7, 23, 58, 127, 236, 368, 482, 527, 482, 368, 236, 127, 58, 23, 3, 4, 6, 13, 26, 47, 73, 95, 104, 95, 73, 47, 26, 13, 6, 4, 3, 5, 6, 9, 16, 30, 52, 79, 102, 111, 102, 79, 52, 30, 16, 9, 6, 5],
                    C: [5, 12, 21, 33, 43, 47, 43, 33, 21, 12, 5, 7, 21, 53, 117, 218, 341, 447, 488, 447, 341, 218, 117, 53, 21, 7, 4, 5, 9, 15, 26, 38, 49, 53, 49, 38, 26, 15, 9, 5, 4, 4, 4, 6, 9, 16, 27, 40, 51, 56, 51, 40, 27, 16, 9, 6, 4, 4, 20, 50, 109, 203, 317, 415, 453, 415, 317, 203, 109, 50, 20, 3, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 3, 3, 4, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 3, 2, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 2, 9, 23, 55, 118, 219, 342, 447, 489, 447, 342, 219, 118, 55, 23, 9, 5, 9, 16, 26, 39, 50, 54, 50, 39, 26, 16, 9, 5, 4, 8, 14, 25, 37, 48, 52, 48, 37, 25, 14, 8, 4, 4, 9, 22, 55, 120, 224, 349, 457, 500, 457, 349, 224, 120, 55, 22, 9, 4, 5, 5, 7, 10, 17, 27, 40, 51, 56, 51, 40, 27, 17, 10, 7, 5, 5],
                    G: [3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 10, 24, 59, 129, 239, 373, 487, 533, 487, 373, 239, 129, 59, 24, 10, 4, 4, 4, 6, 9, 14, 20, 25, 27, 25, 20, 14, 9, 6, 4, 4, 4, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 9, 23, 59, 129, 239, 374, 489, 534, 489, 374, 239, 129, 59, 23, 9, 3, 3, 5, 8, 13, 18, 23, 25, 23, 18, 13, 8, 5, 3, 3, 2, 2, 2, 4, 7, 12, 17, 22, 24, 22, 17, 12, 7, 4, 2, 2, 2, 4, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 4, 22, 52, 113, 209, 325, 425, 465, 425, 325, 209, 113, 52, 22, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 3, 5, 8, 14, 20, 26, 28, 26, 20, 14, 8, 5, 3, 3, 3, 6, 11, 26, 62, 133, 246, 383, 501, 547, 501, 383, 246, 133, 62, 26, 11, 6],
                    T: [2, 3, 5, 7, 10, 10, 10, 7, 5, 3, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 4, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 8, 21, 52, 115, 213, 333, 436, 476, 436, 333, 213, 115, 52, 21, 8, 2, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 2, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 4, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 4, 3, 4, 5, 7, 9, 11, 12, 11, 9, 7, 5, 4, 3, 3, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 3, 5, 5, 5, 6, 7, 9, 11, 14, 14, 14, 11, 9, 7, 6, 5, 5, 5],
                    peak: [5, 18, 33, 49, 64, 78, 93, 109, 125, 139, 152, 167, 184]
                }
            }, {
                id: "R1-0000-3456",
                fill: "rgb(255,51,255)",
                outline: "rgb(0,0,0)",
                dir: "left",
                offsetLeft: "23",
                gaps: [
                    [7, 2]
                ],
                sequence: "GTACGTATAC",
                trace: {
                    A: [4, 10, 22, 41, 64, 84, 92, 84, 64, 41, 22, 10, 4, 5, 8, 15, 29, 51, 79, 102, 111, 102, 79, 51, 29, 15, 8, 5, 11, 24, 58, 124, 228, 356, 465, 508, 465, 356, 228, 124, 58, 24, 11, 13, 25, 45, 69, 89, 97, 89, 69, 45, 25, 13, 1, 2, 4, 11, 24, 44, 69, 90, 99, 90, 69, 44, 24, 11, 4, 2, 1, 3, 6, 13, 26, 48, 75, 98, 107, 98, 75, 48, 26, 13, 6, 3, 11, 24, 58, 124, 228, 355, 464, 507, 464, 355, 228, 124, 58, 24, 11, 4, 7, 13, 27, 49, 75, 98, 107, 98, 75, 49, 27, 13, 7, 4, 7, 19, 50, 110, 206, 322, 421, 460, 421, 322, 206, 110, 50, 19, 7, 5, 8, 15, 28, 50, 76, 99, 108, 99, 76, 50, 28, 15, 8, 5],
                    C: [2, 6, 13, 23, 36, 47, 51, 47, 36, 23, 13, 6, 2, 4, 5, 8, 14, 24, 35, 45, 49, 45, 35, 24, 14, 8, 5, 4, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 59, 130, 242, 377, 494, 540, 494, 377, 242, 130, 59, 1, 1, 2, 6, 12, 22, 34, 44, 48, 44, 34, 22, 12, 6, 2, 1, 1, 2, 3, 6, 13, 22, 34, 44, 48, 44, 34, 22, 13, 6, 3, 2, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 2, 3, 7, 13, 23, 35, 46, 50, 46, 35, 23, 13, 7, 3, 2, 10, 24, 57, 125, 231, 360, 470, 514, 470, 360, 231, 125, 57, 24, 10],
                    G: [21, 54, 122, 228, 357, 467, 511, 467, 357, 228, 122, 54, 21, 4, 4, 6, 9, 14, 21, 26, 28, 26, 21, 14, 9, 6, 4, 4, 5, 6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 5, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 2, 7, 21, 56, 126, 236, 370, 485, 531, 485, 370, 236, 126, 56, 21, 7, 2, 2, 2, 4, 7, 13, 19, 24, 26, 24, 19, 13, 7, 4, 2, 2, 5, 6, 7, 11, 17, 24, 30, 32, 30, 24, 17, 11, 7, 6, 5, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 2, 3, 4, 8, 14, 21, 26, 29, 26, 21, 14, 8, 4, 3, 2, 4, 4, 6, 10, 15, 21, 27, 29, 27, 21, 15, 10, 6, 4, 4],
                    T: [1, 1, 3, 5, 7, 9, 10, 9, 7, 5, 3, 1, 1, 10, 23, 57, 124, 230, 358, 468, 512, 468, 358, 230, 124, 57, 23, 10, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 8, 23, 59, 130, 243, 380, 498, 545, 498, 380, 243, 130, 59, 23, 8, 5, 5, 5, 7, 9, 11, 13, 14, 13, 11, 9, 7, 5, 5, 5, 8, 20, 50, 110, 205, 320, 418, 457, 418, 320, 205, 110, 50, 20, 8, 2, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2, 2, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4],
                    peak: [6, 20, 35, 48, 62, 78, 93, 108, 123, 138]
                }
            }, {
                id: "R1-0000-4567",
                fill: "rgb(255,102,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 15,
                gaps: [
                    [5, 1]
                ],
                sequence: "CGTACTACGTA",
                trace: {
                    A: [9, 16, 29, 51, 78, 100, 110, 100, 78, 51, 29, 16, 9, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 4, 5, 7, 13, 25, 44, 67, 86, 94, 86, 67, 44, 25, 13, 7, 5, 4, 4, 8, 21, 53, 115, 214, 335, 438, 479, 438, 335, 214, 115, 53, 21, 8, 4, 2, 3, 5, 11, 23, 42, 65, 85, 93, 85, 65, 42, 23, 11, 5, 3, 2, 8, 15, 29, 52, 80, 103, 113, 103, 80, 52, 29, 15, 8, 4, 9, 23, 57, 126, 233, 365, 477, 522, 477, 365, 233, 126, 57, 23, 9, 4, 2, 4, 10, 23, 42, 66, 87, 95, 87, 66, 42, 23, 10, 4, 2, 3, 5, 12, 25, 46, 71, 93, 101, 93, 71, 46, 25, 12, 5, 3, 4, 5, 8, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 8, 5, 4, 19, 49, 108, 202, 316, 413, 452, 413, 316, 202, 108, 49, 19],
                    C: [24, 56, 121, 223, 348, 454, 496, 454, 348, 223, 121, 56, 24, 8, 14, 24, 36, 46, 50, 46, 36, 24, 14, 8, 4, 4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 4, 3, 3, 4, 8, 14, 25, 38, 48, 53, 48, 38, 25, 14, 8, 4, 3, 3, 3, 8, 21, 54, 119, 222, 348, 455, 498, 455, 348, 222, 119, 54, 21, 8, 3, 5, 9, 15, 25, 38, 48, 52, 48, 38, 25, 15, 9, 5, 3, 3, 5, 8, 15, 26, 39, 51, 55, 51, 39, 26, 15, 8, 5, 3, 3, 6, 18, 48, 107, 201, 315, 412, 451, 412, 315, 201, 107, 48, 18, 6, 2, 3, 6, 12, 22, 33, 43, 47, 43, 33, 22, 12, 6, 3, 2, 4, 4, 6, 9, 16, 28, 42, 54, 58, 54, 42, 28, 16, 9, 6, 4, 4, 3, 7, 13, 24, 37, 47, 52, 47, 37, 24, 13, 7, 3],
                    G: [6, 7, 11, 16, 23, 29, 31, 29, 23, 16, 11, 7, 6, 56, 121, 223, 348, 455, 498, 455, 348, 223, 121, 56, 4, 4, 5, 6, 10, 16, 23, 28, 31, 28, 23, 16, 10, 6, 5, 4, 4, 3, 3, 4, 5, 9, 14, 21, 26, 29, 26, 21, 14, 9, 5, 4, 3, 3, 2, 2, 2, 4, 7, 12, 18, 24, 26, 24, 18, 12, 7, 4, 2, 2, 2, 4, 6, 9, 14, 19, 24, 26, 24, 19, 14, 9, 6, 4, 3, 3, 3, 5, 8, 13, 19, 24, 26, 24, 19, 13, 8, 5, 3, 3, 3, 1, 2, 3, 7, 12, 19, 24, 27, 24, 19, 12, 7, 3, 2, 1, 7, 20, 51, 113, 211, 330, 432, 473, 432, 330, 211, 113, 51, 20, 7, 4, 4, 4, 6, 9, 15, 21, 26, 29, 26, 21, 15, 9, 6, 4, 4, 4, 3, 4, 8, 13, 20, 26, 28, 26, 20, 13, 8, 4, 3],
                    T: [5, 6, 7, 9, 11, 13, 14, 13, 11, 9, 7, 6, 5, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 5, 10, 24, 60, 130, 241, 376, 492, 538, 492, 376, 241, 130, 60, 24, 10, 5, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 3, 2, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 2, 22, 53, 114, 211, 328, 429, 469, 429, 328, 211, 114, 53, 22, 3, 3, 3, 3, 5, 7, 9, 11, 12, 11, 9, 7, 5, 3, 3, 3, 3, 1, 1, 2, 3, 5, 7, 9, 10, 9, 7, 5, 3, 2, 1, 1, 2, 2, 2, 4, 6, 8, 10, 11, 10, 8, 6, 4, 2, 2, 2, 5, 10, 24, 58, 127, 235, 366, 479, 524, 479, 366, 235, 127, 58, 24, 10, 5, 2, 3, 4, 6, 8, 10, 11, 10, 8, 6, 4, 3, 2],
                    peak: [6, 18, 32, 49, 66, 81, 96, 112, 127, 143, 158]
                }
            }, {
                id: "R1-0000-5678",
                fill: "rgb(51,255,255)",
                outline: "rgb(0,0,0)",
                dir: "right",
                offset: 18,
                gaps: [
                    [7, 1]
                ],
                sequence: "ACGTACGACGT",
                trace: {
                    A: [10, 25, 60, 131, 244, 380, 497, 544, 497, 380, 244, 131, 60, 25, 10, 5, 6, 8, 15, 28, 48, 73, 95, 103, 95, 73, 48, 28, 15, 8, 6, 5, 4, 6, 13, 26, 47, 72, 94, 102, 94, 72, 47, 26, 13, 6, 4, 6, 8, 15, 28, 49, 74, 95, 104, 95, 74, 49, 28, 15, 8, 6, 2, 7, 22, 58, 129, 243, 380, 498, 545, 498, 380, 243, 129, 58, 22, 7, 2, 11, 23, 43, 66, 86, 94, 86, 66, 43, 23, 11, 5, 8, 15, 28, 50, 77, 100, 109, 100, 77, 50, 28, 15, 8, 5, 6, 11, 24, 58, 125, 232, 361, 471, 515, 471, 361, 232, 125, 58, 24, 11, 6, 12, 24, 43, 66, 85, 93, 85, 66, 43, 24, 12, 14, 28, 50, 76, 99, 108, 99, 76, 50, 28, 14, 5, 7, 14, 27, 47, 72, 93, 101, 93, 72, 47, 27, 14, 7, 5],
                    C: [4, 5, 8, 15, 24, 36, 46, 50, 46, 36, 24, 15, 8, 5, 4, 6, 11, 26, 62, 135, 249, 388, 506, 554, 506, 388, 249, 135, 62, 26, 11, 6, 3, 5, 8, 15, 25, 38, 49, 54, 49, 38, 25, 15, 8, 5, 3, 5, 6, 9, 15, 25, 36, 46, 50, 46, 36, 25, 15, 9, 6, 5, 1, 1, 3, 6, 13, 24, 37, 49, 53, 49, 37, 24, 13, 6, 3, 1, 1, 53, 117, 219, 342, 447, 489, 447, 342, 219, 117, 53, 4, 5, 8, 15, 25, 36, 47, 51, 47, 36, 25, 15, 8, 5, 4, 5, 5, 7, 10, 17, 28, 41, 53, 57, 53, 41, 28, 17, 10, 7, 5, 5, 57, 124, 231, 360, 471, 516, 471, 360, 231, 124, 57, 9, 16, 27, 40, 51, 55, 51, 40, 27, 16, 9, 4, 6, 9, 16, 27, 41, 52, 57, 52, 41, 27, 16, 9, 6, 4],
                    G: [4, 5, 6, 10, 16, 22, 28, 31, 28, 22, 16, 10, 6, 5, 4, 5, 5, 5, 7, 10, 15, 21, 26, 28, 26, 21, 15, 10, 7, 5, 5, 5, 8, 21, 53, 116, 216, 337, 440, 482, 440, 337, 216, 116, 53, 21, 8, 5, 6, 7, 11, 17, 23, 29, 32, 29, 23, 17, 11, 7, 6, 5, 1, 1, 1, 3, 6, 11, 17, 22, 24, 22, 17, 11, 6, 3, 1, 1, 1, 4, 8, 13, 20, 25, 27, 25, 20, 13, 8, 4, 9, 21, 52, 111, 206, 321, 420, 459, 420, 321, 206, 111, 52, 21, 9, 5, 5, 5, 7, 10, 16, 22, 27, 30, 27, 22, 16, 10, 7, 5, 5, 5, 5, 8, 14, 20, 25, 27, 25, 20, 14, 8, 5, 57, 124, 230, 358, 468, 512, 468, 358, 230, 124, 57, 4, 4, 6, 9, 14, 20, 25, 28, 25, 20, 14, 9, 6, 4, 4],
                    T: [4, 4, 5, 6, 8, 11, 14, 14, 14, 11, 8, 6, 5, 4, 4, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 3, 3, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 3, 3, 11, 24, 57, 122, 224, 349, 456, 498, 456, 349, 224, 122, 57, 24, 11, 1, 1, 1, 2, 3, 5, 8, 10, 11, 10, 8, 5, 3, 2, 1, 1, 1, 3, 4, 6, 8, 11, 11, 11, 8, 6, 4, 3, 4, 4, 5, 6, 8, 11, 13, 14, 13, 11, 8, 6, 5, 4, 4, 5, 5, 5, 6, 7, 9, 12, 14, 15, 14, 12, 9, 7, 6, 5, 5, 5, 4, 5, 7, 10, 12, 13, 12, 10, 7, 5, 4, 4, 6, 8, 10, 12, 13, 12, 10, 8, 6, 4, 10, 25, 60, 131, 242, 378, 494, 540, 494, 378, 242, 131, 60, 25, 10],
                    peak: [7, 23, 39, 54, 70, 84, 97, 113, 127, 138, 151]
                }
            }]
        }, {
            name: "Tissue Distribution",
            type: "bar",
            height: 20,
            fill: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
            outline: ["rgb(255,0,0)", "rgb(0,0,255)", "rgb(255,255,0)"],
            data: [{
                id: "123456_at",
                offset: 10,
                data: [25, 35, 46]
            }, {
                id: "234567_at",
                offset: 135,
                data: [80, 45, 10]
            }, {
                id: "345678_at",
                offset: 300,
                data: [65, 46, 29]
            }]
        }],
        market: [{
            symbol: "BMY",
            data: [
                [20100824, 26.26, 26.37, 25.95, 26.02, 11625900, 26.02],
                [20100823, 26.48, 26.76, 26.38, 26.48, 12146600, 26.48],
                [20100820, 26.31, 26.54, 26.08, 26.44, 18140100, 26.44],
                [20100819, 26.2, 26.29, 25.81, 26.06, 8218000, 26.06],
                [20100818, 26.53, 26.57, 26.23, 26.28, 12235800, 26.28],
                [20100817, 26.4, 26.79, 26.26, 26.59, 12325700, 26.59],
                [20100816, 26.24, 26.34, 26.04, 26.28, 10377700, 26.28],
                [20100813, 26.24, 26.46, 26.1, 26.32, 5760100, 26.32],
                [20100812, 26.01, 26.39, 26, 26.33, 7350500, 26.33],
                [20100811, 26.32, 26.5, 26.15, 26.25, 8808100, 26.25],
                [20100810, 26.32, 26.78, 26.3, 26.66, 7009500, 26.66],
                [20100809, 26.37, 26.54, 26.3, 26.51, 6825300, 26.51],
                [20100806, 26.29, 26.45, 26.05, 26.37, 8774900, 26.37],
                [20100805, 25.83, 26.38, 25.8, 26.38, 12264600, 26.38],
                [20100804, 25.7, 26.13, 25.61, 26.03, 10233700, 26.03],
                [20100803, 25.65, 25.85, 25.58, 25.68, 6842900, 25.68],
                [20100802, 25.33, 25.61, 25.29, 25.53, 9770900, 25.53],
                [20100730, 24.98, 25.13, 24.78, 24.92, 11435700, 24.92],
                [20100729, 25.37, 25.5, 24.85, 25.08, 9463800, 25.08],
                [20100728, 25.25, 25.36, 25.02, 25.12, 8072400, 25.12],
                [20100727, 25.09, 25.35, 24.84, 25.32, 14152600, 25.32],
                [20100726, 24.57, 25.03, 24.57, 24.97, 8817400, 24.97],
                [20100723, 24.94, 24.95, 24.26, 24.65, 13043700, 24.65],
                [20100722, 24.96, 25.22, 24.75, 24.93, 10385300, 24.93],
                [20100721, 24.92, 25.11, 24.59, 24.75, 9830000, 24.75],
                [20100720, 24.65, 25.09, 24.46, 25.02, 10655500, 25.02],
                [20100719, 25.27, 25.27, 24.78, 24.84, 11804800, 24.84],
                [20100716, 25.44, 25.47, 25.1, 25.17, 13136300, 25.17]
            ]
        }]
    };
    this.exampleBasicData = {
        x: {
            Tissue: ["Kidney", "Liver", "Breast", "Brain"],
            Donor: ["D1", "D2", "D2", "D1"]
        },
        z: {
            Symbol: ["abc", "def", "ghi", "jkl", "mno", "pqr"],
            Desc: ["blah", "yeah", "maybe", "good", "bad", "awsome"]
        },
        y: {
            vars: ["Gene1", "Gene2", "Gene3", "Gene4", "Gene5", "Gene6"],
            smps: ["X", "Smp2", "Smp3", "Smp4"],
            desc: ["Intensity"],
            mean: [
                [1, 2, 3, 4],
                [2, 1, 3, 6],
                [3, 2, 1, 5],
                [4, 2, 1, 3],
                [4, 3, 2, 1],
                [9, 2, 7, 4]
            ],
            stdev: [
                [1, 3, 2, 1],
                [2, 3, 2, 1],
                [2, 2, 2, 1],
                [2, 3, 1, 1],
                [1, 1, 1, 1],
                [3, 1, 3, 1]
            ],
            n: [
                [4, 5, 5, 5],
                [4, 5, 5, 5],
                [6, 4, 4, 5],
                [6, 4, 5, 6],
                [5, 5, 5, 5],
                [6, 5, 5, 5]
            ]
        },
        a: {
            xAxis: ["Gene1", "Gene2", "Gene3"],
            xAxis2: ["Gene4", "Gene5", "Gene6"]
        }
    }
};
CanvasXpress.prototype.initData = function (data) {
    this.isValidPlotData = function (type) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (type == "cor" && level.cor) {
            return true
        } else {
            if (type == "venn" && this.data.venn) {
                return true
            } else {
                if (type == "network" && this.data.nodes) {
                    return true
                } else {
                    if (type == "genome" && this.data.tracks) {
                        return true
                    } else {
                        if (type == "sum" && level.sum && level.sum[0].length > 0) {
                            return true
                        } else {
                            if (type == "mean" && level.mean && level.mean[0].length > 0) {
                                return true
                            } else {
                                if (type == "median" && level.median && level.median[0].length > 0) {
                                    return true
                                } else {
                                    if (type == "iqr" && level.iqr1 && level.qtl1 && level.median && level.qtl3 && level.iqr3 && level.median[0].length > 0) {
                                        return true
                                    } else {
                                        if (type == "candle" && level.close && level.open && level.high && level.low && level.close[0].length > 0) {
                                            return true
                                        } else {
                                            if (type == "volume" && level.volume && level.volume[0].length > 0) {
                                                return true
                                            } else {
                                                if (type == "raw" && this.isRawData) {
                                                    return true
                                                } else {
                                                    return false
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setAllNodesVisible = function () {
        this.nodes = {};
        this.data.nodeIndices = {};
        for (var i = 0; i < this.data.nodes.length; i++) {
            var node = this.data.nodes[i];
            node.hide = false;
            this.nodes[node.id] = node;
            this.data.nodeIndices[node.id] = i
        }
        for (var i = 0; i < this.data.edges.length; i++) {
            this.data.edges[i].hide = false
        }
        this.filterData()
    };
    this.setNodeIndices = function () {
        this.nodes = {};
        this.data.nodeIndices = {};
        for (var i = 0; i < this.data.nodes.length; i++) {
            var node = this.data.nodes[i];
            this.nodes[node.id] = node;
            this.data.nodeIndices[node.id] = i
        }
    };
    this.setNodes = function () {
        if (this.data.nodeIndices) {
            this.nodes = {};
            for (var i = 0; i < this.data.nodes.length; i++) {
                var node = this.data.nodes[i];
                this.nodes[node.id] = node
            }
            this.data.nodes = [];
            for (var id in this.data.nodeIndices) {
                this.data.nodes[this.data.nodeIndices[id]] = this.nodes[id]
            }
        } else {
            this.setNodeIndices()
        }
    };
    this.hideUnhideNodes = function (nodeIds, hide) {
        hide = hide ? true : false;
        if (nodeIds) {
            if (this.isArray(nodeIds)) {
                for (var i = 0; i < nodeIds.length; i++) {
                    var nid = nodeIds[i];
                    var node = this.data.nodes[this.data.nodeIndices[nid]];
                    node.hide = hide;
                    if (this.nodes && this.nodes[nid]) {
                        this.nodes[nid].hide = hide
                    }
                }
            }
        } else {
            for (var i = 0; i < this.data.nodes.length; i++) {
                var node = this.data.nodes[i];
                node.hide = hide;
                node.hideChildren = hide;
                if (this.nodes && this.nodes[node.id]) {
                    this.nodes[node.id].hide = hide;
                    this.nodes[node.id].hideChildren = hide
                }
            }
        }
    };
    this.hideUnhideChildrenNodes = function (id, hide) {
        hide = hide ? true : false;
        if (this.nodeParentHood[id] && this.nodeParentHood[id].children) {
            for (var i = 0; i < this.nodeParentHood[id].children.length; i++) {
                var cid = this.nodeParentHood[id].children[i];
                this.data.nodes[this.data.nodeIndices[cid]].hiddenParent = hide;
                this.hideUnhideChildrenNodes(cid, hide)
            }
        }
    };
    this.resetNodeFilters = function (idx) {
        if (idx != null && this.filterNodeBy.length > 0) {
            this.filterNodeBy.splice(idx, 1);
            this.filterNodeByOp.splice(idx, 1);
            this.filterNodeByValue.splice(idx, 1);
            this.filterNodeByCase.splice(idx, 1)
        } else {
            this.filterNodeBy = [];
            this.filterNodeByOp = [];
            this.filterNodeByValue = [];
            this.filterNodeByCase = []
        }
    };
    this.resetEdgeFilters = function (idx) {
        if (idx != null && this.filterEdgeBy.length > 0) {
            this.filterEdgeBy.splice(idx, 1);
            this.filterEdgeByOp.splice(idx, 1);
            this.filterEdgeByValue.splice(idx, 1);
            this.filterEdgeByCase.splice(idx, 1)
        } else {
            this.filterEdgeBy = [];
            this.filterEdgeByOp = [];
            this.filterEdgeByValue = [];
            this.filterEdgeByCase = []
        }
    };
    this.setAllFeaturesVisible = function () {
        for (var i = 0; i < this.data.tracks.length; i++) {
            var track = this.data.tracks[i];
            track.hide = false;
            var features = track.data;
            for (var j = 0; j < features.length; j++) {
                features[j].hide = false
            }
        }
    };
    this.resetFeatureFilters = function (idx) {
        if (idx != null && this.filterFeatureBy.length > 0) {
            this.filterFeatureBy.splice(idx, 1);
            this.filterFeatureByOp.splice(idx, 1);
            this.filterFeatureByValue.splice(idx, 1);
            this.filterFeatureByCase.splice(idx, 1)
        } else {
            this.filterFeatureBy = [];
            this.filterFeatureByOp = [];
            this.filterFeatureByValue = [];
            this.filterFeatureByCase = []
        }
    };
    this.setSelectNodes = function (nodeIds) {
        this.selectNode = {};
        this.isSelectNodes = 0;
        for (var i = 0; i < nodeIds.length; i++) {
            this.selectNode[nodeIds[i]] = true;
            this.isSelectNodes++
        }
    };
    this.getAnnotations = function (isVar) {
        var ann = [];
        if (isVar) {
            if (this.data.z) {
                for (var annt in this.data.z) {
                    ann.push(annt)
                }
            }
        } else {
            if (this.data.x) {
                for (var annt in this.data.x) {
                    ann.push(annt)
                }
            }
        }
        return ann
    };
    this.getNetworkImages = function () {
        var images = [];
        if (this.graphType == "Network") {
            for (var i = 0; i < this.data.nodes.length; i++) {
                var node = this.data.nodes[i];
                if (node.imagePath) {
                    if (!node.imagePath.match(/^http:\/\//)) {
                        node.imagePath = this.imageDir + node.imagePath
                    }
                    images.push(node.imagePath)
                }
            }
        }
        return images
    };
    this.setAllVariablesVisible = function (indices) {
        if (this.data.y) {
            if (!this.data.y.vars && this.data.y.data) {
                this.data.y.vars = [];
                for (var i = 0; i < this.data.y.data.length; i++) {
                    this.data.y.vars.push("var" + (i + 1))
                }
            }
            this.varIndices = [];
            this.hiddenVars = [];
            if (indices) {
                for (var i = 0; i < indices.length; i++) {
                    this.varIndices.push(indices[i]);
                    this.hiddenVars.push(false)
                }
            } else {
                for (var i = 0; i < this.data.y.vars.length; i++) {
                    this.varIndices.push(i);
                    this.hiddenVars.push(false)
                }
            }
            this.filterData();
            var c = this.layoutComb ? this.layoutCurrent : 0;
            if (this.startingVarIndices) {
                if (this.startingVarIndices[c] && this.startingVarIndices[c].length == this.varIndices.length) {
                    this.varIndices = this.startingVarIndices[c]
                } else {
                    this.startingVarIndices[c] = []
                }
            }
        }
        if (this.data.y && this.data.a) {
            this.xAxisVarIndices = [];
            this.xAxis2VarIndices = [];
            if (this.data.a.xAxis) {
                this.xAxisVarIndices = this.getVariableIndices(this.data.a.xAxis)
            }
            if (this.data.a.xAxis2) {
                this.xAxis2VarIndices = this.getVariableIndices(this.data.a.xAxis2)
            }
        }
    };
    this.resetVariablesVisibleByAxis = function (axis) {
        if (this.data.a) {
            this.setVariablesVisibleByAxis(axis, this.getVariableIndices(this.data.a[axis]))
        }
    };
    this.setVariablesVisibleByAxis = function (axis, arr) {
        var index = axis + "VarIndices";
        this[index] = [];
        for (var i = 0; i < arr.length; i++) {
            this[index].push(arr[i])
        }
    };
    this.getVariablesVisibleByAxis = function (axis) {
        return this[axis + "VarIndices"]
    };
    this.getVariablesByAxis = function (axis) {
        if (this.data.a && this.data.a[axis]) {
            return this.data.a[axis]
        }
        return []
    };
    this.getVariablesByAnnotationLevel = function (annt, lev) {
        var v = [];
        if (annt && this.data.z[annt]) {
            if (lev) {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var ii = this.varIndices[i];
                    if (this.data.z[annt][ii] == lev && !this.hiddenVars[ii]) {
                        v.push(ii)
                    }
                }
            } else {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var ii = this.varIndices[i];
                    if (!this.data.z[annt][ii] && !this.hiddenVars[ii]) {
                        v.push(ii)
                    }
                }
            }
        }
        return v
    };
    this.setVariablesVisible = function (arr) {
        this.varIndices = [];
        for (var i = 0; i < arr.length; i++) {
            this.varIndices.push(arr[i])
        }
    };
    this.getVariableIndices = function (arr) {
        if (arr && this.data.y.vars) {
            var indices = [];
            if (this.isArray(arr)) {
                if (arr.length > 0) {
                    for (var i = 0; i < arr.length; i++) {
                        for (var j = 0; j < this.data.y.vars.length; j++) {
                            if (this.data.y.vars[j] == arr[i]) {
                                indices.push(j);
                                break
                            }
                        }
                    }
                    return indices
                }
            } else {
                for (var i = 0; i < this.data.y.vars.length; i++) {
                    if (this.data.y.vars[i] == arr) {
                        return i
                    }
                }
                return -1
            }
        }
    };
    this.hideUnhideVars = function (vars) {
        if (vars) {
            if (this.isArray(vars)) {
                for (var i = 0; i < vars.length; i++) {
                    for (var j = 0; j < this.data.y.vars.length; j++) {
                        if (this.data.y.vars[j] == vars[i]) {
                            if (this.hiddenVars[j]) {
                                this.hiddenVars[j] = false
                            } else {
                                this.hiddenVars[j] = true
                            }
                            break
                        }
                    }
                }
            } else {
                for (var i = 0; i < this.data.y.vars.length; i++) {
                    if (this.data.y.vars[i] == vars) {
                        if (this.hiddenVars[i]) {
                            this.hiddenVars[i] = false
                        } else {
                            this.hiddenVars[i] = true
                        }
                        break
                    }
                }
            }
            var arr = [];
            for (var i = 0; i < this.data.y.vars.length; i++) {
                if (!this.hiddenVars[i]) {
                    arr.push(i)
                }
            }
            this.setVariablesVisible(arr);
            var axes = ["xAxis", "xAxis2"];
            if (this.data.a) {
                for (var i = 0; i < axes.length; i++) {
                    var indices = this.getVariableIndices(this.data.a[axes[i]]);
                    if (indices.length > 0) {
                        var arr = [];
                        for (var j = 0; j < indices.length; j++) {
                            var jj = indices[j];
                            if (!this.hiddenVars[jj]) {
                                arr.push(jj)
                            }
                        }
                        this.setVariablesVisibleByAxis(axes[i], arr)
                    }
                }
            }
            this.draw()
        }
    };
    this.getVariables = function () {
        var variables = [];
        for (var i = 0; i < this.data.y.vars.length; i++) {
            var idx = -1;
            for (var j = 0; j < this.varIndices.length; j++) {
                if (this.varIndices[j] == i) {
                    idx = j;
                    break
                }
            }
            variables.push({
                name: this.data.y.vars[i],
                hidden: this.hiddenVars[i],
                index: idx
            })
        }
        return variables
    };
    this.resetVarFilters = function (idx) {
        if (idx != null && this.filterVarBy.length > 0) {
            this.filterVarBy.splice(idx, 1);
            this.filterVarByOp.splice(idx, 1);
            this.filterVarByValue.splice(idx, 1);
            this.filterVarByCase.splice(idx, 1);
            this.filteredVarIndices.splice(idx, 1)
        } else {
            this.filterVarBy = [];
            this.filterVarByOp = [];
            this.filterVarByValue = [];
            this.filterVarByCase = [];
            this.filteredVarIndices = []
        }
    };
    this.setAllSamplesVisible = function (indices) {
        if (this.data.y && this.data.y.smps) {
            if (!this.data.y.smps && this.data.y.data && this.data.y.vars) {
                this.data.y.smps = [];
                for (var i = 0; i < this.data.y.data.vars[0].length; i++) {
                    this.data.y.smps.push("smp" + (i + 1))
                }
            }
            this.smpIndices = [];
            this.hiddenSmps = [];
            if (indices) {
                for (var i = 0; i < indices.length; i++) {
                    this.smpIndices.push(indices[i]);
                    this.hiddenSmps.push(false)
                }
            } else {
                for (var i = 0; i < this.data.y.smps.length; i++) {
                    this.smpIndices.push(i);
                    this.hiddenSmps.push(false)
                }
            }
            this.filterData(true)
        }
        if (this.data.w && this.data.w.smps) {
            this.grpIndices = [];
            this.hiddenGrps = [];
            for (var i = 0; i < this.data.w.smps.length; i++) {
                this.grpIndices.push(i);
                this.hiddenGrps.push(false)
            }
        }
        var c = this.layoutComb ? this.layoutCurrent : 0;
        if (this.isGroupedData) {
            if (this.startingSmpIndices) {
                if (this.startingSmpIndices[c] && this.startingSmpIndices[c].length == this.grpIndices.length) {
                    this.grpIndices = this.startingSmpIndices[c]
                } else {
                    this.startingSmpIndices[c] = []
                }
            }
        } else {
            if (this.startingSmpIndices) {
                if (this.startingSmpIndices[c] && this.startingSmpIndices[c].length == this.smpIndices.length) {
                    this.smpIndices = this.startingSmpIndices[c]
                } else {
                    this.startingSmpIndices[c] = []
                }
            }
        }
    };
    this.getSamplesByAxis = function (axis) {
        if (this[axis]) {
            return this[axis]
        }
        return []
    };
    this.getSamplesByAnnotationLevel = function (annt, lev) {
        var s = [];
        if (annt && this.data.x[annt]) {
            if (lev) {
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var ii = this.smpIndices[i];
                    if (this.data.x[annt][ii] == lev && !this.hiddenSmps[ii]) {
                        s.push(ii)
                    }
                }
            } else {
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var ii = this.smpIndices[i];
                    if (!this.data.x[annt][ii] && !this.hiddenSmps[ii]) {
                        s.push(ii)
                    }
                }
            }
        }
        return s
    };
    this.setSamplesVisible = function (arr, status) {
        if (this.isGroupedData) {
            this.grpIndices = [];
            for (var i = 0; i < arr.length; i++) {
                this.grpIndices.push(arr[i])
            }
        } else {
            this.smpIndices = [];
            for (var i = 0; i < arr.length; i++) {
                this.smpIndices.push(arr[i])
            }
        }
        if (status) {
            var seen = this.getObjectArray(arr);
            var level = this.isGroupedData ? this.data.w : this.data.y;
            var hidden = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
            for (var i = 0; i < level.smps.length; i++) {
                if (seen.hasOwnProperty(i)) {
                    hidden[i] = false
                } else {
                    hidden[i] = true
                }
            }
        }
    };
    this.getSampleIndices = function (arr) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (arr && level.smps) {
            var indices = [];
            if (this.isArray(arr)) {
                if (arr.length > 0) {
                    for (var i = 0; i < arr.length; i++) {
                        for (var j = 0; j < level.smps.length; j++) {
                            if (level.smps[j] == arr[i]) {
                                indices.push(j);
                                break
                            }
                        }
                    }
                    return indices
                }
            } else {
                for (var i = 0; i < level.smps.length; i++) {
                    if (level.smps[i] == arr) {
                        return i
                    }
                }
                return -1
            }
        }
    };
    this.hideUnhideSmps = function (smps) {
        if (smps) {
            var level = this.isGroupedData ? this.data.w : this.data.y;
            var hidden = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
            var indices = [];
            if (this.isArray(smps)) {
                for (var i = 0; i < smps.length; i++) {
                    for (var j = 0; j < level.smps.length; j++) {
                        if (level.smps[j] == smps[i]) {
                            if (hidden[j]) {
                                hidden[j] = false
                            } else {
                                hidden[j] = true
                            }
                            break
                        }
                    }
                }
            } else {
                for (var i = 0; i < level.smps.length; i++) {
                    if (level.smps[i] == smps) {
                        if (hidden[i]) {
                            hidden[i] = false
                        } else {
                            hidden[i] = true
                        }
                        break
                    }
                }
            }
            var arr = [];
            for (var i = 0; i < level.smps.length; i++) {
                if (!hidden[i]) {
                    arr.push(i)
                }
            }
            this.setSamplesVisible(arr);
            this.draw()
        }
    };
    this.getSamples = function () {
        var samples = [];
        var smps = this.isGroupedData ? this.data.w.smps : this.data.y.smps;
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var hidden = this.isGroupedData ? this.hiddenGrps : this.hiddenSmps;
        var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
        for (var i = 0; i < smps.length; i++) {
            var idx = -1;
            for (var j = 0; j < indices.length; j++) {
                if (indices[j] == i) {
                    idx = j;
                    break
                }
            }
            samples.push({
                name: smps[i],
                hidden: hidden[i],
                index: idx
            })
        }
        return samples
    };
    this.resetSmpFilters = function (idx) {
        if (idx != null && this.filterSmpBy.length > 0) {
            this.filterSmpBy.splice(idx, 1);
            this.filterSmpByOp.splice(idx, 1);
            this.filterSmpByValue.splice(idx, 1);
            this.filterSmpByCase.splice(idx, 1);
            this.filteredSmpIndices.splice(idx, 1)
        } else {
            this.filterSmpBy = [];
            this.filterSmpByOp = [];
            this.filterSmpByValue = [];
            this.filterSmpByCase = [];
            this.filteredSmpIndices = []
        }
    };
    this.setIndices = function (vIndices, sIndices) {
        if (this.graphType == "Network") {
            this.setNodes()
        } else {
            if (this.graphType != "Genome" && this.graphType != "Venn") {
                this.setAllVariablesVisible(vIndices);
                this.setAllSamplesVisible(sIndices)
            }
        }
    };
    this.resetIndices = function () {
        if (this.isGroupedData) {
            this.setIndices()
        }
    };
    this.setMaxSmpStringAttr = function (str, font) {
        this.setMaxSmpStringAnnt(str, font);
        this.setMaxSmpStringLabel(str, font);
        this.setMaxSmpStringDesc(font);
        this.setMaxSmpStringName(font)
    };
    this.setMaxSmpStringAnnt = function (str, font) {
        if (!font) {
            font = this.smpLabelFont
        }
        var max = 0;
        this.maxSmpAnnt = 0;
        this.maxSmpAnntStr = "";
        if (this.data.x) {
            if (str && this.data.x[str]) {
                return str
            } else {
                for (var annt in this.data.x) {
                    var len = this.measureText(annt, font);
                    if (len > max) {
                        max = len;
                        this.maxSmpAnnt = annt.length;
                        this.maxSmpAnntStr = annt
                    }
                }
            }
        }
    };
    this.setMaxSmpStringLabel = function (str, font) {
        if (!font) {
            font = this.smpLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxSmpLabel = 0;
        this.maxSmpLabelStr = "";
        if (this.data.x) {
            if (str && this.data.x[str]) {
                var maxStr = "";
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var text = this.data.x[str][this.smpIndices[i]];
                    if (!seen.hasOwnProperty(text)) {
                        var len = this.measureText(text, font);
                        if (len > max) {
                            max = len;
                            maxStr = text
                        }
                        seen[text] = true
                    }
                }
                return maxStr
            } else {
                for (var annt in this.data.x) {
                    for (var i = 0; i < this.smpIndices.length; i++) {
                        var text = this.data.x[annt][this.smpIndices[i]];
                        if (text && !seen.hasOwnProperty(text)) {
                            var len = this.measureText(text, font);
                            if (len > max) {
                                max = len;
                                this.maxSmpLabel = this.data.x[annt][this.smpIndices[i]].length;
                                this.maxSmpLabelStr = this.data.x[annt][this.smpIndices[i]]
                            }
                            seen[text] = true
                        }
                    }
                }
            }
        }
    };
    this.setMaxSmpStringDesc = function (font) {
        if (!font) {
            font = this.smpLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxSmpLabelDesc = 0;
        this.maxSmpLabelDescStr = "";
        if (this.data.x && this.smpLabelDescription && this.data.x[this.smpLabelDescription]) {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var text = this.data.x[this.smpLabelDescription][this.smpIndices[i]];
                if (text && !seen.hasOwnProperty(text)) {
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxSmpLabelDesc = text.length;
                        this.maxSmpLabelDescStr = text
                    }
                }
            }
        }
    };
    this.setMaxSmpStringName = function (font) {
        if (!font) {
            font = this.smpLabelFont
        }
        if (this.data.y || this.data.w) {
            var level = this.isGroupedData ? this.data.w : this.data.y;
            var max = 0;
            this.maxSmpName = 0;
            this.maxSmpNameStr = "";
            if (this.isGroupedData) {
                for (var i = 0; i < level.smps.length; i++) {
                    var len = this.measureText(level.smps[i], font);
                    if (len > max) {
                        max = len;
                        this.maxSmpName = level.smps[i].length;
                        this.maxSmpNameStr = level.smps[i]
                    }
                }
            } else {
                for (var i = 0; i < this.smpIndices.length; i++) {
                    var text = level.smps[this.smpIndices[i]];
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxSmpName = text.length;
                        this.maxSmpNameStr = text
                    }
                }
            }
        }
    };
    this.getSmpAnnotations = function (annt, indices, str, num) {
        var seen = {};
        var arr = [];
        var nul = false;
        if (this.data.x.hasOwnProperty(annt)) {
            for (var i = 0; i < indices.length; i++) {
                var ii = indices[i];
                if (this.data.x[annt][ii] != null) {
                    seen[this.data.x[annt][ii]] = true;
                    arr.push(this.data.x[annt][ii])
                } else {
                    nul = true
                }
            }
            if (nul) {
                arr.push("")
            }
            if (num) {
                return str ? arr.join("+") : arr
            } else {
                arr = []
            }
            for (var i in seen) {
                arr.push(i)
            }
            if (nul) {
                arr.push("")
            }
            return str ? arr.join("+") : arr
        }
    };
    this.setMaxVarStringAttr = function (str, font) {
        this.setMaxVarStringAnnt(str, font);
        this.setMaxVarStringLabel(str, font);
        this.setMaxVarStringDesc(font);
        this.setMaxVarStringName(font)
    };
    this.setMaxVarStringAnnt = function (str, font) {
        if (!font) {
            font = this.varLabelFont
        }
        var max = 0;
        this.maxVarAnnt = 0;
        this.maxVarAnntStr = "";
        if (this.data.z) {
            if (str && this.data.z[str]) {
                return str
            } else {
                for (var annt in this.data.z) {
                    var len = this.measureText(annt, font);
                    if (len > max) {
                        max = len;
                        this.maxVarAnnt = annt.length;
                        this.maxVarAnntStr = annt
                    }
                }
            }
        }
    };
    this.setMaxVarStringLabel = function (str, font) {
        if (!font) {
            font = this.varLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxVarLabel = 0;
        this.maxVarLabelStr = "";
        if (this.data.z) {
            if (str && this.data.z[str]) {
                var maxStr = "";
                for (var i = 0; i < this.varIndices.length; i++) {
                    var text = this.data.z[str][this.varIndices[i]];
                    if (!seen.hasOwnProperty(text)) {
                        var len = this.measureText(text, font);
                        if (len > max) {
                            max = len;
                            maxStr = text
                        }
                        seen[text] = true
                    }
                }
                return maxStr
            } else {
                for (var annt in this.data.z) {
                    for (var i = 0; i < this.varIndices.length; i++) {
                        var text = this.data.z[annt][this.varIndices[i]];
                        if (text && !seen.hasOwnProperty(text)) {
                            var len = this.measureText(text, font);
                            if (len > max) {
                                max = len;
                                this.maxVarLabel = text.length;
                                this.maxVarLabelStr = text
                            }
                            seen[text] = true
                        }
                    }
                }
            }
        }
    };
    this.setMaxVarStringDesc = function (font) {
        if (!font) {
            font = this.varLabelFont
        }
        var max = 0;
        var seen = {};
        this.maxVarLabelDesc = 0;
        this.maxVarLabelDescStr = "";
        if (this.data.z && this.varLabelDescription && this.data.z[this.varLabelDescription]) {
            for (var i = 0; i < this.varIndices.length; i++) {
                var text = this.data.z[this.varLabelDescription][this.varIndices[i]];
                if (text && !seen.hasOwnProperty(text)) {
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxVarLabelDesc = text.length;
                        this.maxVarLabelDescStr = text
                    }
                    seen[text] = true
                }
            }
        }
    };
    this.setMaxVarStringName = function (font) {
        if (!font) {
            font = this.varLabelFont
        }
        if (this.data.y || this.data.w) {
            var level = this.graphType.match(/BarLine|StackedLine|StackedPercentLine/) ? this.data.y : this.isGroupedData ? this.data.w : this.data.y;
            var max = 0;
            this.maxVarName = 0;
            this.maxVarNameStr = "";
            if (level.vars) {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var text = level.vars[this.varIndices[i]];
                    var len = this.measureText(text, font);
                    if (len > max) {
                        max = len;
                        this.maxVarName = text.length;
                        this.maxVarNameStr = text
                    }
                }
            }
        }
    };
    this.getVarAnnotations = function (annt, indices, str, num) {
        var seen = {};
        var arr = [];
        var nul = false;
        if (this.data.z.hasOwnProperty(annt)) {
            for (var i = 0; i < indices.length; i++) {
                var ii = indices[i];
                if (this.data.z[annt][ii] != null) {
                    seen[this.data.z[annt][ii]] = true;
                    arr.push(this.data.z[annt][ii])
                } else {
                    nul = true
                }
            }
            if (nul) {
                arr.push("")
            }
            if (num) {
                return str ? arr.join("+") : arr
            } else {
                arr = []
            }
            for (var i in seen) {
                arr.push(i)
            }
            if (nul) {
                arr.push("")
            }
            return str ? arr.join("+") : arr
        }
    };
    this.filterData = function () {
        var or = {};
        var and = {};
        var edgs = {};
        var re = false;
        var evaluate = function (ts, op, vl, cs) {
            if (op.match(/[\>\<\=]/)) {
                return eval(parseFloat(ts) + " " + op + " " + parseFloat(vl))
            } else {
                if (op.match("null")) {
                    return op == "not null" && ts != null ? true : op == "null" && ts == null ? true : false
                } else {
                    var r = cs ? new RegExp(vl) : new RegExp(vl, "i");
                    return op == "like" ? r.test(ts) : r.test(ts) ? false : true
                }
            }
            return false
        };
        var addEdge = function (nd) {
            if (!edgs[nd]) {
                edgs[nd] = 0
            }
            edgs[nd]++
        };
        if (this.graphType == "Genome" && this.filterFeatureBy.length > 0) {
            for (var i = 0; i < this.filterFeatureBy.length; i++) {
                if (this.filterFeatureBy[i]) {
                    for (var j = 0; j < this.data.tracks.length; j++) {
                        var track = this.data.tracks[j];
                        var features = track.data;
                        for (var k = 0; k < features.length; k++) {
                            var feature = features[k];
                            if (!evaluate(feature[this.filterFeatureBy[i]], this.filterFeatureByOp[i], this.filterFeatureByValue[i], this.filterFeatureByCase[i])) {
                                feature.hide = this.filterType == "and" ? true : or[j + ":" + k] ? false : true;
                                and[j + ":" + k] = true
                            } else {
                                or[j + ":" + k] = true;
                                if (this.filterType == "or" && and[j + ":" + k]) {
                                    feature.hide = false
                                }
                            }
                        }
                    }
                }
            }
        } else {
            if (this.graphType == "Network" && (this.filterNodeBy.length > 0 || this.filterEdgeBy.length)) {
                for (var i = 0; i < this.filterNodeBy.length; i++) {
                    if (this.filterNodeBy[i]) {
                        for (var j = 0; j < this.data.nodes.length; j++) {
                            if (!evaluate(this.data.nodes[j][this.filterNodeBy[i]], this.filterNodeByOp[i], this.filterNodeByValue[i], this.filterNodeByCase[i])) {
                                this.data.nodes[j].hide = this.filterType == "and" ? true : or[this.data.nodes[j].id] ? false : true;
                                and[this.data.nodes[j].id] = true
                            } else {
                                or[this.data.nodes[j].id] = true;
                                if (this.filterType == "or" && and[this.data.nodes[j].id]) {
                                    this.data.nodes[j].hide = false
                                }
                            }
                        }
                    }
                }
                for (var i = 0; i < this.filterEdgeBy.length; i++) {
                    if (this.filterEdgeBy[i]) {
                        for (var j = 0; j < this.data.edges.length; j++) {
                            var n1 = this.data.nodes[this.data.nodeIndices[this.data.edges[j].id1]];
                            var n2 = this.data.nodes[this.data.nodeIndices[this.data.edges[j].id2]];
                            var id = n1.id + ":" + n2.id;
                            if (!evaluate(this.data.edges[j][this.filterEdgeBy[i]], this.filterEdgeByOp[i], this.filterEdgeByValue[i], this.filterEdgeByCase[i])) {
                                this.data.edges[j].hide = this.filterType == "and" ? true : or[id] ? false : true;
                                and[id] = true
                            } else {
                                or[id] = true;
                                if (this.filterType == "or" && and[id]) {
                                    this.data.edges[j].hide = false
                                }
                            }
                            if (!this.data.edges[j].hide) {
                                addEdge(n1.id);
                                addEdge(n2.id)
                            }
                        }
                    }
                }
                if (this.filterEdgeBy.length > 0) {
                    for (var i = 0; i < this.data.nodes.length; i++) {
                        var nd = this.data.nodes[i];
                        if (!edgs[nd.id]) {
                            nd.hide = true
                        } else {
                            nd.hide = false
                        }
                    }
                }
            } else {
                if (this.filterSmpBy.length > 0) {
                    for (var i = 0; i < this.filterSmpBy.length; i++) {
                        if (this.filterSmpBy[i]) {
                            re = true;
                            for (var j = 0; j < this.smpIndices.length; j++) {
                                var jj = this.smpIndices[j];
                                var tr = this.filterSmpBy[i] == "smps" ? this.data.y.smps[jj] : this.data.x[this.filterSmpBy[i]][jj];
                                if (!evaluate(tr, this.filterSmpByOp[i], this.filterSmpByValue[i], this.filterSmpByCase[i])) {
                                    this.hiddenSmps[jj] = this.filterType == "and" ? true : or[jj] ? false : true;
                                    and[jj] = true
                                } else {
                                    or[jj] = true;
                                    if (this.filterType == "or" && and[jj]) {
                                        this.hiddenSmps[jj] = false
                                    }
                                }
                            }
                        }
                    }
                    if (re) {
                        var arr = [];
                        for (var i = 0; i < this.smpIndices.length; i++) {
                            var ii = this.smpIndices[i];
                            if (!this.hiddenSmps[ii]) {
                                arr.push(ii)
                            }
                        }
                        this.smpIndices = arr
                    }
                }
                if (this.filterVarBy.length > 0) {
                    for (var i = 0; i < this.filterVarBy.length; i++) {
                        if (this.filterVarBy[i]) {
                            re = true;
                            for (var j = 0; j < this.varIndices.length; j++) {
                                var jj = this.varIndices[j];
                                var tr = this.filterVarBy[i] == "vars" ? this.data.y.vars[jj] : this.data.z[this.filterVarBy[i]][jj];
                                if (!evaluate(tr, this.filterVarByOp[i], this.filterVarByValue[i], this.filterVarByCase[i])) {
                                    this.hiddenVars[jj] = this.filterType == "and" ? true : or[jj] ? false : true;
                                    and[jj] = true
                                } else {
                                    or[jj] = true;
                                    if (this.filterType == "or" && and[jj]) {
                                        this.hiddenVars[jj] = false
                                    }
                                }
                            }
                        }
                    }
                    if (re) {
                        var arr = [];
                        for (var i = 0; i < this.varIndices.length; i++) {
                            var ii = this.varIndices[i];
                            if (!this.hiddenVars[ii]) {
                                arr.push(ii)
                            }
                        }
                        this.varIndices = arr
                    }
                }
            }
        }
    };
    this.setRangeData = function (type, forceRaw, justPositive, stacked, circular) {
        var level = this.isGroupedData && !forceRaw ? this.data.w : this.data.y;
        var min = Number.MAX_VALUE;
        var max = Number.MAX_VALUE * -1;
        if (this.setMin != null && this.setMax != null) {
            this.minData = this.setMin;
            this.maxData = this.setMax;
            return
        }
        if (this.isGroupedData && !type) {
            type = this.summaryType
        }
        if (type == "genome") {
            for (var i = 0; i < this.data.tracks.length; i++) {
                for (var j = 0; j < this.data.tracks[i].data.length; j++) {
                    if (this.data.tracks[i].type == "box") {
                        for (var k = 0; k < this.data.tracks[i].data[j].data.length; k++) {
                            vals = this.data.tracks[i].data[j].data[k];
                            max = Math.max(max, Math.max(vals[0], vals[1]));
                            min = Math.min(min, Math.min(vals[0], vals[1]))
                        }
                    } else {
                        if (this.data.tracks[i].type == "sequence") {
                            vals = this.data.tracks[i].data[j].offset;
                            max = Math.max(max, vals + this.data.tracks[i].data[j].sequence.length);
                            min = Math.min(min, vals)
                        } else {
                            if (this.data.tracks[i].type.match(/bar|heatmap|line|stacked/)) {
                                vals = this.data.tracks[i].data[j].offset;
                                max = this.data.tracks[i].autowidth ? Math.max(max, vals + this.data.tracks[i].data[j].data.length) : Math.max(max, vals);
                                min = Math.min(min, vals)
                            } else {
                                vals = this.data.tracks[i].data[j].offset;
                                max = Math.max(max, vals);
                                min = Math.min(min, vals)
                            }
                        }
                    }
                }
            }
        } else {
            if (type == "circular") {
                var idx = this.getVariableIndices(this.rAxis);
                if (idx >= 0) {
                    var rng = this.range(this.data.y.data[idx]);
                    min = rng[0];
                    max = rng[1]
                } else {
                    min = 0;
                    max = 1
                }
            } else {
                if (type == "km" && !forceRaw) {
                    min = 0;
                    max = 1
                } else {
                    if (type == "percentile" && !forceRaw) {
                        min = 0;
                        max = 100
                    } else {
                        if ((type == "mean" || type == "median" || type == "sum") && !forceRaw) {
                            if (stacked) {
                                var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                var data = this.isTransformedData ? level.trans : level[this.summaryType];
                                for (var i = 0; i < indices.length; i++) {
                                    var ii = indices[i];
                                    var tot = 0;
                                    for (var j = 0; j < this.varIndices.length; j++) {
                                        var jj = this.varIndices[j];
                                        var val = data[jj][ii];
                                        if (!isNaN(val) && val > 0) {
                                            tot += val
                                        }
                                    }
                                    max = Math.max(tot, max)
                                }
                                min = 0
                            } else {
                                for (var i = 0; i < this.varIndices.length; i++) {
                                    var ii = this.varIndices[i];
                                    var vals;
                                    if (this.isTransformedData) {
                                        vals = level.trans[ii]
                                    } else {
                                        if (this.summaryType == "mean") {
                                            vals = level.mean[ii]
                                        } else {
                                            if (this.summaryType == "median") {
                                                vals = level.median[ii]
                                            } else {
                                                if (this.summaryType == "sum") {
                                                    vals = level.sum[ii]
                                                }
                                            }
                                        }
                                    }
                                    for (var j = 0; j < vals.length; j++) {
                                        var std;
                                        var val = vals[j];
                                        if (level.stdev && !this.isTransformedData) {
                                            std = level.stdev[ii][j]
                                        } else {
                                            std = Number.NaN
                                        }
                                        if (!isNaN(val)) {
                                            if (!isNaN(std)) {
                                                if (justPositive) {
                                                    if (val > 0) {
                                                        min = Math.min(val, min);
                                                        max = Math.max(val + std, max)
                                                    }
                                                } else {
                                                    min = Math.min(val, min);
                                                    max = Math.max(val + std, max)
                                                }
                                            } else {
                                                if (justPositive) {
                                                    if (val > 0) {
                                                        min = Math.min(val, min);
                                                        max = Math.max(val, max)
                                                    }
                                                } else {
                                                    min = Math.min(val, min);
                                                    max = Math.max(val, max)
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (type == "iqr" && !forceRaw) {
                                if (this.isTransformedData) {
                                    alert("Transformation not allowed");
                                    this.isTransformedData = false
                                }
                                for (var i = 0; i < this.varIndices.length; i++) {
                                    var ii = this.varIndices[i];
                                    for (var j = 0; j < level.iqr1[ii].length; j++) {
                                        var iqr1 = level.iqr1[ii][j];
                                        var iqr3 = level.iqr3[ii][j];
                                        var out = level.out[ii][j];
                                        if (!isNaN(iqr1) && !isNaN(iqr3)) {
                                            if (justPositive) {
                                                if (iqr1 > 0 && iqr3 > 0) {
                                                    min = Math.min(iqr1, min);
                                                    max = Math.max(iqr3, max)
                                                }
                                            } else {
                                                min = Math.min(iqr1, min);
                                                max = Math.max(iqr3, max)
                                            }
                                        }
                                        if (out) {
                                            for (var k = 0; k < out.length; k++) {
                                                if (!isNaN(out[k])) {
                                                    if (justPositive) {
                                                        if (out[k] > 0) {
                                                            min = Math.min(out[k], min);
                                                            max = Math.max(out[k], max)
                                                        }
                                                    } else {
                                                        min = Math.min(out[k], min);
                                                        max = Math.max(out[k], max)
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (type == "candle") {
                                    if (this.isTransformedData) {
                                        alert("Transformation not allowed");
                                        this.isTransformedData = false
                                    }
                                    var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                    for (var i = 0; i < this.varIndices.length; i++) {
                                        var ii = this.varIndices[i];
                                        for (var j = 0; j < indices.length; j++) {
                                            var jj = indices[j];
                                            var high = level.high[ii][jj];
                                            var low = level.low[ii][jj];
                                            if (!isNaN(high) && !isNaN(low)) {
                                                min = Math.min(low, min);
                                                max = Math.max(high, max)
                                            }
                                        }
                                    }
                                } else {
                                    if (type == "volume") {
                                        var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                                        for (var i = 0; i < this.varIndices.length; i++) {
                                            var ii = this.varIndices[i];
                                            for (var j = 0; j < indices.length; j++) {
                                                var jj = indices[j];
                                                if (!isNaN(level.volume[ii][jj])) {
                                                    min = Math.min(level.volume[ii][jj], min);
                                                    max = Math.max(level.volume[ii][jj], max)
                                                }
                                            }
                                        }
                                    } else {
                                        if (type == "cor") {
                                            var indices = this.correlationAxis == "variables" ? this.varIndices : this.isGroupedData ? this.grpIndices : this.smpIndices;
                                            for (var i = 0; i < indices.length; i++) {
                                                for (var j = 0; j < indices.length; j++) {
                                                    var val = this.isTransformedData ? level.trans[i][j] : level.cor[i][j];
                                                    if (!isNaN(val)) {
                                                        if (justPositive) {
                                                            if (val > 0) {
                                                                min = Math.min(val, min);
                                                                max = Math.max(val, max)
                                                            }
                                                        } else {
                                                            min = Math.min(val, min);
                                                            max = Math.max(val, max)
                                                        }
                                                    }
                                                }
                                            }
                                        } else {
                                            var data = this.isTransformedData ? level.trans : level.data;
                                            if (stacked) {
                                                for (var i = 0; i < this.smpIndices.length; i++) {
                                                    var tot = 0;
                                                    for (var j = 0; j < this.varIndices.length; j++) {
                                                        var val = data[this.varIndices[j]][this.smpIndices[i]];
                                                        if (!isNaN(val) && val > 0) {
                                                            tot += val
                                                        }
                                                    }
                                                    max = Math.max(tot, max)
                                                }
                                                min = 0
                                            } else {
                                                for (var i = 0; i < this.varIndices.length; i++) {
                                                    for (var j = 0; j < this.smpIndices.length; j++) {
                                                        var val = data[this.varIndices[i]][this.smpIndices[j]];
                                                        if (!isNaN(val)) {
                                                            if (justPositive) {
                                                                if (val > 0) {
                                                                    min = Math.min(val, min);
                                                                    max = Math.max(val, max)
                                                                }
                                                            } else {
                                                                min = Math.min(val, min);
                                                                max = Math.max(val, max)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        this.minData = this.setMin != null ? this.setMin : min;
        this.maxData = this.setMax != null ? this.setMax : max
    };
    this.setRangeDataObject = function (data) {
        var min = Number.MAX_VALUE;
        var max = Number.MAX_VALUE * -1;
        for (var i = 0; i < this.varIndices.length; i++) {
            for (var j = 0; j < this.smpIndices.length; j++) {
                var val = data[this.varIndices[i]][this.smpIndices[j]];
                if (!isNaN(val)) {
                    min = Math.min(val, min);
                    max = Math.max(val, max)
                }
            }
        }
        return [min, max]
    };
    this.sortIndices = function (type, dir, byCat, bySmp, byVar) {
        var that = this;
        var indices = this.isGroupedData ? this.grpIndices : type == "vars" ? this.varIndices : this.smpIndices;
        this.tmpAsciiArray = [];
        this.tmpAsciiArray1 = [];
        this.tmpAsciiArray2 = [];
        this.tmpAsciiArrayAscii = false;
        this.tmpAsciiArrayAscii1 = false;
        this.tmpAsciiArrayAscii2 = false;
        if (byCat) {
            byCat = this.toArray(byCat)
        }
        if (bySmp) {
            bySmp = this.toArray(bySmp)
        }
        if (byVar) {
            byVar = this.toArray(byVar)
        }
        if (!dir) {
            dir = this.sortDir
        }
        if (byCat && type == "vars") {
            if (byCat.length == 1 && this.data.z && this.data.z[byCat[0]]) {
                this.tmpAsciiArray = this.data.z[byCat[0]];
                this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
            } else {
                if (byCat.length == 2 && this.data.z && this.data.z[byCat[0]] && this.data.z[byCat[1]]) {
                    this.tmpAsciiArray = this.data.z[byCat[0]];
                    this.tmpAsciiArray1 = this.data.z[byCat[1]];
                    this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                    this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
                } else {
                    if (byCat.length == 3 && this.data.z && this.data.z[byCat[0]] && this.data.z[byCat[1]] && this.data.z[byCat[2]]) {
                        this.tmpAsciiArray = this.data.z[byCat[0]];
                        this.tmpAsciiArray1 = this.data.z[byCat[1]];
                        this.tmpAsciiArray2 = this.data.z[byCat[2]];
                        this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                        this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
                        this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
                    }
                }
            }
            this.smpSort = -1;
            this.varSort = byCat
        } else {
            if (byCat && type == "smps") {
                if (byCat.length == 1 && this.data.x && this.data.x[byCat[0]]) {
                    this.tmpAsciiArray = this.data.x[byCat[0]];
                    this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray)
                } else {
                    if (byCat.length == 2 && this.data.x && this.data.x[byCat[0]] && this.data.x[byCat[1]]) {
                        this.tmpAsciiArray = this.data.x[byCat[0]];
                        this.tmpAsciiArray1 = this.data.x[byCat[1]];
                        this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                        this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1)
                    } else {
                        if (byCat.length == 3 && this.data.x && this.data.x[byCat[0]] && this.data.x[byCat[1]] && this.data.x[byCat[2]]) {
                            this.tmpAsciiArray = this.data.x[byCat[0]];
                            this.tmpAsciiArray1 = this.data.x[byCat[1]];
                            this.tmpAsciiArray2 = this.data.x[byCat[2]];
                            this.tmpAsciiArrayAscii = this.isAsciiArray(this.tmpAsciiArray);
                            this.tmpAsciiArrayAscii1 = this.isAsciiArray(this.tmpAsciiArray1);
                            this.tmpAsciiArrayAscii2 = this.isAsciiArray(this.tmpAsciiArray2)
                        }
                    }
                }
                this.varSort = -1;
                this.smpSort = byCat
            } else {
                if (bySmp) {
                    if (bySmp.length == 1) {
                        this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(bySmp[0] - 1);
                        this.tmpAsciiArrayAscii = false;
                        this.smpSort = [bySmp[0] - 1]
                    } else {
                        if (bySmp.length == 2) {
                            this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(bySmp[0] - 1);
                            this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(bySmp[1] - 1);
                            this.tmpAsciiArrayAscii = false;
                            this.tmpAsciiArrayAscii1 = false;
                            this.smpSort = [bySmp[0] - 1, bySmp[1] - 1]
                        } else {
                            if (bySmp.length == 3) {
                                this.tmpAsciiArray = this.getDataForSmpGrpAtIndex(bySmp[0] - 1);
                                this.tmpAsciiArray1 = this.getDataForSmpGrpAtIndex(bySmp[1] - 1);
                                this.tmpAsciiArray2 = this.getDataForSmpGrpAtIndex(bySmp[2] - 1);
                                this.tmpAsciiArrayAscii = false;
                                this.tmpAsciiArrayAscii1 = false;
                                this.tmpAsciiArrayAscii2 = false;
                                this.smpSort = [bySmp[0] - 1, bySmp[1] - 1, bySmp[2] - 1]
                            }
                        }
                    }
                } else {
                    if (byVar) {
                        if (byVar.length == 1) {
                            this.tmpAsciiArray = this.data.y.data[byVar[0] - 1];
                            this.tmpAsciiArrayAscii = false;
                            this.smpSort = [byVar[0] - 1]
                        } else {
                            if (byVar.length == 2) {
                                this.tmpAsciiArray = this.data.y.data[byVar[0] - 1];
                                this.tmpAsciiArray1 = this.data.y.data[byVar[1] - 1];
                                this.tmpAsciiArrayAscii = false;
                                this.tmpAsciiArrayAscii1 = false;
                                this.smpSort = [byVar[0] - 1, byVar[1] - 1]
                            } else {
                                if (bySmp.length == 3) {
                                    this.tmpAsciiArray = this.data.y.data[byVar[0] - 1];
                                    this.tmpAsciiArray1 = this.data.y.data[byVar[1] - 1];
                                    this.tmpAsciiArray2 = this.data.y.data[byVar[2] - 1];
                                    this.tmpAsciiArrayAscii = false;
                                    this.tmpAsciiArrayAscii1 = false;
                                    this.tmpAsciiArrayAscii2 = false;
                                    this.smpSort = [byVar[0] - 1, byVar[1] - 1, byVar[2] - 1]
                                }
                            }
                        }
                    } else {
                        this.tmpAsciiArray = this.isGroupedData ? this.data.w.smps : type == "vars" ? this.data.y.vars : this.data.y.smps;
                        this.tmpAsciiArrayAscii = true;
                        if (type == "vars") {
                            this.varSort = false
                        } else {
                            this.smpSort = false
                        }
                    }
                }
            }
        }
        if (this.tmpAsciiArrayAscii) {
            indices.sort(function (a, b) {
                return that.sortAsciibetically(a, b)
            })
        } else {
            indices.sort(function (a, b) {
                return that.sortNumerically(a, b)
            })
        }
        if (dir != "ascending") {
            indices.reverse()
        }
        this.tmpAsciiArray = [];
        this.tmpAsciiArray1 = [];
        this.tmpAsciiArray2 = [];
        this.tmpAsciiArrayAscii = false;
        this.tmpAsciiArrayAscii1 = false;
        this.tmpAsciiArrayAscii2 = false
    };
    this.isAsciiArray = function (arr) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] != null && isNaN(arr[i])) {
                return true
            }
        }
        return false
    };
    this.sortAsciibetically = function (a, b) {
        var that = this;
        if (this.tmpAsciiArray[a] == this.tmpAsciiArray[b] && this.tmpAsciiArray1.length > 0) {
            if (this.tmpAsciiArrayAscii1) {
                return that.sortAsciibetically1(a, b)
            } else {
                return that.sortNumerically1(a, b)
            }
        } else {
            return ((this.tmpAsciiArray[a] > this.tmpAsciiArray[b]) ? 1 : (this.tmpAsciiArray[a] < this.tmpAsciiArray[b]) ? -1 : 0)
        }
    };
    this.sortAsciibetically1 = function (a, b) {
        var that = this;
        if (this.tmpAsciiArray1[a] == this.tmpAsciiArray1[b] && this.tmpAsciiArray2.length > 0) {
            if (this.tmpAsciiArrayAscii2) {
                return that.sortAsciibetically2(a, b)
            } else {
                return that.sortNumerically2(a, b)
            }
        } else {
            return ((this.tmpAsciiArray1[a] > this.tmpAsciiArray1[b]) ? 1 : (this.tmpAsciiArray1[a] < this.tmpAsciiArray1[b]) ? -1 : 0)
        }
    };
    this.sortAsciibetically2 = function (a, b) {
        return ((this.tmpAsciiArray2[a] > this.tmpAsciiArray2[b]) ? 1 : (this.tmpAsciiArray2[a] < this.tmpAsciiArray2[b]) ? -1 : 0)
    };
    this.sortNumerically = function (a, b) {
        var that = this;
        if ((this.tmpAsciiArray[a] || 0) - (this.tmpAsciiArray[b] || 0) == 0 && this.tmpAsciiArray1.length > 0) {
            if (this.tmpAsciiArrayAscii1) {
                return that.sortAsciibetically1(a, b)
            } else {
                return that.sortNumerically1(a, b)
            }
        } else {
            return (this.tmpAsciiArray[a] || 0) - (this.tmpAsciiArray[b] || 0)
        }
    };
    this.sortNumerically1 = function (a, b) {
        var that = this;
        if ((this.tmpAsciiArray1[a] || 0) - (this.tmpAsciiArray1[b] || 0) == 0 && this.tmpAsciiArray2.length > 0) {
            if (this.tmpAsciiArrayAscii2) {
                return that.sortAsciibetically2(a, b)
            } else {
                return that.sortNumerically2(a, b)
            }
        } else {
            return (this.tmpAsciiArray1[a] || 0) - (this.tmpAsciiArray1[b] || 0)
        }
    };
    this.sortNumerically2 = function (a, b) {
        return (this.tmpAsciiArray2[a] || 0) - (this.tmpAsciiArray2[b] || 0)
    };
    this.radixSort = function (arr) {
        var rs = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        var cpy = new Int32Array(arr.length);
        var c4 = [].concat(rs);
        var c3 = [].concat(rs);
        var c2 = [].concat(rs);
        var c1 = [].concat(rs);
        var o4 = 0;
        var t4;
        var o3 = 0;
        var t3;
        var o2 = 0;
        var t2;
        var o1 = 0;
        var t1;
        var x;
        for (x = 0; x < arr.length; x++) {
            t4 = arr[x] & 255;
            t3 = (arr[x] >> 8) & 255;
            t2 = (arr[x] >> 16) & 255;
            t1 = (arr[x] >> 24) & 255 ^ 128;
            c4[t4]++;
            c3[t3]++;
            c2[t2]++;
            c1[t1]++
        }
        for (x = 0; x < 256; x++) {
            t4 = o4 + c4[x];
            t3 = o3 + c3[x];
            t2 = o2 + c2[x];
            t1 = o1 + c1[x];
            c4[x] = o4;
            c3[x] = o3;
            c2[x] = o2;
            c1[x] = o1;
            o4 = t4;
            o3 = t3;
            o2 = t2;
            o1 = t1
        }
        for (x = 0; x < arr.length; x++) {
            t4 = arr[x] & 255;
            cpy[c4[t4]] = arr[x];
            c4[t4]++
        }
        for (x = 0; x < arr.length; x++) {
            t3 = (cpy[x] >> 8) & 255;
            arr[c3[t3]] = cpy[x];
            c3[t3]++
        }
        for (x = 0; x < arr.length; x++) {
            t2 = (arr[x] >> 16) & 255;
            cpy[c2[t2]] = arr[x];
            c2[t2]++
        }
        for (x = 0; x < arr.length; x++) {
            t1 = (cpy[x] >> 24) & 255 ^ 128;
            arr[c1[t1]] = cpy[x];
            c1[t1]++
        }
        return arr
    };
    this.isNumeric2DArray = function (arr) {
        for (var i = 0; i < arr.length; i++) {
            for (var j = 0; j < arr[i].length; j++) {
                if (arr[i][j] && isNaN(arr[i][j])) {
                    return false
                }
            }
        }
        return true
    };
    this.isNumeric = function (arr, filterSmps, filterVars) {
        if (filterSmps) {
            for (var ii = 0; ii < this.smpIndices.length; ii++) {
                var i = this.smpIndices[ii];
                if (arr[i] && isNaN(arr[i])) {
                    return false
                }
            }
        } else {
            if (filterVars) {
                for (var ii = 0; ii < this.varIndices.length; ii++) {
                    var i = this.varIndices[ii];
                    if (arr[i] && isNaN(arr[i])) {
                        return false
                    }
                }
            } else {
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] && isNaN(arr[i])) {
                        return false
                    }
                }
            }
        }
        return true
    };
    this.precedence = {
        sin: 16,
        cos: 16,
        tan: 16,
        sec: 16,
        csc: 16,
        cot: 16,
        asin: 16,
        acos: 16,
        atan: 16,
        asec: 16,
        acsc: 16,
        acot: 16,
        sinh: 16,
        cosh: 16,
        tanh: 16,
        sech: 16,
        csch: 16,
        coth: 16,
        asinh: 16,
        acosh: 16,
        atanh: 16,
        asech: 16,
        acsch: 16,
        acoth: 16,
        exp: 16,
        ln: 16,
        log: 16,
        logb: 16,
        pow: 16,
        sq: 16,
        sqrt: 16,
        abs: 16,
        sgn: 16,
        chs: 16,
        floor: 16,
        ceil: 16,
        ip: 16,
        fp: 16,
        inv: 16,
        min: 16,
        max: 16,
        gamma: 16,
        fact: 16,
        comb: 16,
        perm: 16,
        rand: 16,
        gcd: 16,
        lcm: 16,
        prime: 16,
        and: 16,
        or: 16,
        xor: 16,
        x: 16,
        y: 16,
        pi: 16,
        e: 16,
        neg: 15,
        not: 15,
        "^": 14,
        "*": 13,
        "/": 13,
        mod: 13,
        div: 13,
        "+": 12,
        "-": 12,
        "<": 10,
        "<=": 10,
        "==": 10,
        "!=": 10,
        ">=": 10,
        ">": 10,
        "&&": 5,
        "||": 4,
        ",": 1
    };
    this.expects = {
        sin: 1,
        cos: 1,
        tan: 1,
        sec: 1,
        csc: 1,
        cot: 1,
        asin: 1,
        acos: 1,
        atan: 1,
        asec: 1,
        acsc: 1,
        acot: 1,
        sinh: 1,
        cosh: 1,
        tanh: 1,
        sech: 1,
        csch: 1,
        coth: 1,
        asinh: 1,
        acosh: 1,
        atanh: 1,
        asech: 1,
        acsch: 1,
        acoth: 1,
        exp: 1,
        ln: 1,
        log: 1,
        logb: 2,
        pow: 2,
        sq: 1,
        sqrt: 1,
        abs: 1,
        sgn: 1,
        chs: 1,
        floor: 1,
        ceil: 1,
        ip: 1,
        fp: 1,
        inv: 1,
        min: 2,
        max: 2,
        gamma: 1,
        fact: 1,
        comb: 2,
        perm: 2,
        gcd: 2,
        lcm: 2,
        prime: 1,
        and: 2,
        or: 2,
        xor: 2,
        neg: 1,
        not: 1,
        "^": 2,
        "*": 2,
        "/": 2,
        mod: 2,
        div: 2,
        "+": 2,
        "-": 2,
        "<": 2,
        "<=": 2,
        "==": 2,
        "!=": 2,
        ">=": 2,
        ">": 2,
        "&&": 2,
        "||": 2
    };
    this.alias = {
        "+": "add",
        "-": "sub",
        "*": "mul",
        "/": "div",
        "!": "fact",
        "x^y": "pow",
        "^": "pow",
        "10^": "pow10",
        div: "idiv",
        "<": "lt",
        "<=": "le",
        "==": "eq",
        "!=": "ne",
        ">=": "ge",
        ">": "gt",
        "%": "pc",
        "%ch": "pcch"
    };
    this.add = function (y, x) {
        return new Number(x) + new Number(y)
    };
    this.sub = function (y, x) {
        return x - y
    };
    this.mul = function (y, x) {
        return x * y
    };
    this.div = function (y, x) {
        return x / y
    };
    this.sin = function (x) {
        return Math.sin(x)
    };
    this.cos = function (x) {
        return Math.cos(x)
    };
    this.tan = function (x) {
        return Math.tan(x)
    };
    this.sec = function (x) {
        return 1 / Math.cos(x)
    };
    this.csc = function (x) {
        return 1 / Math.sin(x)
    };
    this.cot = function (x) {
        return 1 / Math.tan(x)
    };
    this.asin = function (x) {
        return Math.asin(x)
    };
    this.acos = function (x) {
        return Math.acos(x)
    };
    this.atan = function (x) {
        return Math.atan(x)
    };
    this.asec = function (x) {
        return Math.acos(1 / x)
    };
    this.acsc = function (x) {
        return Math.asin(1 / x)
    };
    this.acot = function (x) {
        return Math.atan(1 / x)
    };
    this.sinh = function (x) {
        return (Math.exp(x) - Math.exp(-x)) * 0.5
    };
    this.cosh = function (x) {
        return (Math.exp(x) + Math.exp(-x)) * 0.5
    };
    this.tanh = function (x) {
        return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x))
    };
    this.sech = function (x) {
        return 1 / cosh(x)
    };
    this.csch = function (x) {
        return 1 / sinh(x)
    };
    this.coth = function (x) {
        return 1 / tanh(x)
    };
    this.asinh = function (x) {
        return Math.log(x + Math.sqrt(x * x + 1))
    };
    this.acosh = function (x) {
        return Math.log(x + Math.sqrt(x * x - 1))
    };
    this.atanh = function (x) {
        return Math.log((1 + x) / (1 - x)) * 0.5
    };
    this.asech = function (x) {
        return acosh(1 / x)
    };
    this.acsch = function (x) {
        return asinh(1 / x)
    };
    this.acoth = function (x) {
        return atanh(1 / x)
    };
    this.exp = function (x) {
        return Math.exp(x)
    };
    this.ln = function (x) {
        return Math.log(x)
    };
    this.log = function (x) {
        return Math.log(x) / Math.LN10
    };
    this.logb = function (y, x) {
        return Math.log(x) / Math.log(y)
    };
    this.pow = function (y, x) {
        return Math.pow(x, y)
    };
    this.pow10 = function (x) {
        return Math.pow(10, x)
    };
    this.sq = function (x) {
        return x * x
    };
    this.sqrt = function (x) {
        return Math.sqrt(x)
    };
    this.abs = function (x) {
        return x >= 0 ? x : -x
    };
    this.sgn = function (x) {
        return x == 0 ? 0 : (x > 0 ? 1 : -1)
    };
    this.chs = function (x) {
        return -x
    };
    this.neg = function (x) {
        return -x
    };
    this.floor = function (x) {
        return Math.floor(x)
    };
    this.ceil = function (x) {
        return Math.ceil(x)
    };
    this.ip = function (x) {
        return parseInt(x)
    };
    this.fp = function (x) {
        return abs(x) - ip(abs(x))
    };
    this.inv = function (x) {
        return 1 / x
    };
    this.idiv = function (y, x) {
        return parseInt(x / y)
    };
    this.mod = function (y, x) {
        return x % y
    };
    this.and = function (y, x) {
        return x & y
    };
    this.or = function (y, x) {
        return x | y
    };
    this.xor = function (y, x) {
        return x ^ y
    };
    this.not = function (x) {
        return~x
    };
    this.lt = function (y, x) {
        return x < y ? 1 : 0
    };
    this.le = function (y, x) {
        return x <= y ? 1 : 0
    };
    this.eq = function (y, x) {
        return x == y ? 1 : 0
    };
    this.ne = function (y, x) {
        return x != y ? 1 : 0
    };
    this.ge = function (y, x) {
        return x >= y ? 1 : 0
    };
    this.gt = function (y, x) {
        return x > y ? 1 : 0
    };
    this.Min = function (y, x) {
        return Math.min(x, y)
    };
    this.Max = function (y, x) {
        return Math.max(x, y)
    };
    this.pc = function (y, x) {
        return x * y / 100
    };
    this.pcch = function (y, x) {
        return 100 * y / x
    };
    this.gammaConsts = new Array(76.18009172947146, - 86.50532032941678, 24.01409824083091, - 1.231739572450155, 0.001208650973866179, - 0.000005395239384953);
    this.gammaLn = function (x) {
        var n = new Number(x);
        var tmp = new Number(x + 5.5);
        var ser = new Number(1.000000000190015);
        tmp -= (x + 0.5) * Math.log(tmp);
        for (var i in this.gammaConsts) {
            ser += this.gammaConsts[i] / ++n
        }
        return Math.log(2.5066282746310007 * ser / x) - tmp
    };
    this.gamma = function (x) {
        return Math.exp(this.gammaLn(x))
    };
    this.fact = function (n) {
        var r = new Number(n);
        if (n <= 1) {
            return 1
        }
        if (n > 100 || (n % 1)) {
            return Math.exp(this.gammaLn(n + 1))
        }
        while (--n) {
            r *= n
        }
        return r
    };
    this.comb = function (y, x) {
        return Math.floor(0.5 + Math.exp(this.gammaLn(x + 1) - this.gammaLn(y + 1) - this.gammaLn(x - y + 1)))
    };
    this.perm = function (y, x) {
        return Math.floor(0.5 + Math.exp(this.gammaLn(x + 1) - this.gammaLn(x - y + 1)))
    };
    this.gcd = function (a, b) {
        if (a == 0) {
            return (b || 1)
        }
        return (b ? this.gcd(b, a % b) : a)
    };
    this.lcm = function (a, b) {
        return (a / this.gcd(a, b)) * b
    };
    this.prime = function (n) {
        var d = new Number(5);
        var dd = new Number(4);
        var w = parseInt(n / d);
        if (n == 2 || n == 3 || n == 5) {
            return 1
        }
        if (n < 5 || (n & 1) == 0 || (n % 3) == 0) {
            return 0
        }
        while (d * w < n && d < w) {
            w = parseInt(n / (d += (dd = 6 - dd)))
        }
        return (d * w == n ? 0 : 1)
    };
    this.degreesToArcLength = function (r, v) {
        return r * v
    };
    this.radiansToArcLength = function (r, rdn) {
        return (r * Math.PI * rdn) / 180
    };
    this.arcLengthToDegrees = function (r, l) {
        return (l * 180) / (r * Math.PI)
    };
    this.arcLengthToRadians = function (r, l) {
        return l / r
    };
    this.cleanArray = function (arr, filterSmps, filterVars) {
        var clean = [];
        if (filterSmps) {
            for (var ii = 0; ii < this.smpIndices.length; ii++) {
                var i = this.smpIndices[ii];
                if (!isNaN(arr[i])) {
                    clean.push(arr[i])
                }
            }
        } else {
            if (filterVars) {
                for (var ii = 0; ii < this.varIndices.length; ii++) {
                    var i = this.varIndices[ii];
                    if (!isNaN(arr[i])) {
                        clean.push(arr[i])
                    }
                }
            } else {
                for (var i = 0; i < arr.length; i++) {
                    if (!isNaN(arr[i])) {
                        clean.push(arr[i])
                    }
                }
            }
        }
        return clean
    };
    this.cleanArrays = function (arr1, arr2, filterSmps, filterVars) {
        var clean1 = [];
        var clean2 = [];
        if (filterSmps) {
            for (var ii = 0; ii < this.smpIndices.length; ii++) {
                var i = this.smpIndices[ii];
                if (!isNaN(arr1[i]) && !isNaN(arr2[i])) {
                    clean1.push(arr1[i]);
                    clean2.push(arr2[i])
                }
            }
        } else {
            if (filterVars) {
                for (var ii = 0; ii < this.varIndices.length; ii++) {
                    var i = this.varIndices[ii];
                    if (!isNaN(arr1[i]) && !isNaN(arr2[i])) {
                        clean1.push(arr1[i]);
                        clean2.push(arr2[i])
                    }
                }
            } else {
                for (var i = 0; i < arr1.length; i++) {
                    if (!isNaN(arr1[i]) && !isNaN(arr2[i])) {
                        clean1.push(arr1[i]);
                        clean2.push(arr2[i])
                    }
                }
            }
        }
        return [clean1, clean2]
    };
    this.sortArray = function (arr, srt) {
        var tmp = [];
        if (arr.length != srt.length) {
            return arr
        }
        for (var i = 0; i < arr.length; i++) {
            if (arr[srt[i]]) {
                tmp[i] = arr[srt[i]]
            } else {
                return arr
            }
        }
        return tmp
    };
    this.reverseArray = function (arr) {
        var tmp = [];
        var cnt = 0;
        for (var i = arr.length - 1; i >= 0; i--) {
            tmp[cnt] = arr[i];
            cnt++
        }
        return tmp
    };
    this.percentile = function (min, max, val) {
        var range = max - min;
        if (range == 0) {
            return 50
        }
        var prcnt = val - min;
        return prcnt * 100 / range
    };
    this.rank = function (arr) {
        var ranks = [];
        for (var i = 0; i < arr.length; i++) {
            ranks.push(i)
        }
        ranks.sort(function (a, b) {
            return arr[a] - arr[b]
        });
        return ranks
    };
    this.min = function (arr, filterSmps, filterVars) {
        if (this.isArray(arr)) {
            arr = this.cleanArray(arr, filterSmps, filterVars);
            var min = Number.MAX_VALUE;
            for (var i = 0; i < arr.length; i++) {
                min = Math.min(min, arr[i])
            }
            return min
        } else {
            return this.Min(arr, filterSmps)
        }
    };
    this.max = function (arr, filterSmps, filterVars) {
        if (this.isArray(arr)) {
            arr = this.cleanArray(arr, filterSmps, filterVars);
            var max = Number.MIN_VALUE;
            for (var i = 0; i < arr.length; i++) {
                max = Math.max(max, arr[i])
            }
            return max
        } else {
            return this.Max(arr, filterSmps)
        }
    };
    this.sum = function (arr, filterSmps, filterVars, justPositive) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
            if (justPositive) {
                if (arr[i] > 0) {
                    sum += arr[i]
                }
            } else {
                sum += arr[i]
            }
        }
        return sum
    };
    this.mean = function (arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var mean = 0;
        var n = 0;
        for (var i = 0; i < arr.length; i++) {
            if (!isNaN(arr[i])) {
                mean += arr[i];
                n++
            }
        }
        if (n > 0) {
            mean /= n
        }
        return mean
    };
    this.range = function (arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var min = Number.MAX_VALUE;
        var max = Number.MAX_VALUE * -1;
        for (var i = 0; i < arr.length; i++) {
            min = Math.min(arr[i], min);
            max = Math.max(arr[i], max)
        }
        return [min, max]
    };
    this.median = function (arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var vals = [];
        var median = [];
        var n = 0;
        vals[0] = Number.NaN;
        vals[1] = Number.NaN;
        for (var i = 0; i < arr.length; i++) {
            median.push(arr[i]);
            n++
        }
        if (n > 0) {
            vals[1] = n;
            median.sort(function (a, b) {
                return a - b
            });
            if (n % 2) {
                vals[0] = median[parseInt(n / 2)]
            } else {
                vals[0] = (median[parseInt((n - 1) / 2)] + median[n / 2]) / 2
            }
        }
        return vals
    };
    this.meanStandardDeviationN = function (arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var vals = [];
        var stdev = 0;
        var mean = 0;
        var n = 0;
        for (var i = 0; i < arr.length; i++) {
            mean += arr[i];
            stdev += arr[i] * arr[i];
            n++
        }
        if (n > 0) {
            mean /= n;
            stdev = Math.sqrt(stdev / n - mean * mean);
            vals.push(mean);
            vals.push(stdev);
            vals.push(n)
        } else {
            vals.push("");
            vals.push("");
            vals.push("")
        }
        return vals
    };
    this.quantiles = function (arr, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        var vals = [];
        var out = [];
        var n = arr.length;
        if (n > 2) {
            var qtl1i = Math.floor(n * 0.25);
            var qtl2i = Math.floor(n * 0.5);
            var qtl3i = Math.floor(n * 0.75);
            arr.sort(function (a, b) {
                return a - b
            });
            var qtl1;
            var qtl2;
            var qtl3;
            if (n % 2) {
                qtl2 = arr[qtl2i]
            } else {
                qtl2 = this.mean([arr[qtl2i - 1], arr[qtl2i]])
            }
            if ((n / 2) % 2) {
                qtl1 = arr[qtl1i];
                qtl3 = arr[qtl3i]
            } else {
                qtl1 = this.mean([arr[qtl1i - 1], arr[qtl1i]]);
                qtl3 = this.mean([arr[qtl3i - 1], arr[qtl3i]])
            }
            var iqr = (qtl3 - qtl1) * 1.5;
            var iqr1;
            var iqr3;
            for (var i = 0; i <= qtl1i; i++) {
                if (arr[i] < qtl1 - iqr) {
                    out.push(arr[i])
                } else {
                    iqr1 = arr[i];
                    break
                }
            }
            for (var i = n - 1; i >= qtl3i; i--) {
                if (arr[i] > qtl3 + iqr) {
                    out.push(arr[i])
                } else {
                    iqr3 = arr[i];
                    break
                }
            }
            vals.push(qtl1);
            vals.push(qtl2);
            vals.push(qtl3);
            vals.push(iqr1);
            vals.push(iqr3);
            vals.push(out);
            vals.push(n)
        } else {
            if (n > 1) {
                vals.push(arr[0]);
                vals.push(arr[1]);
                vals.push(arr[1]);
                vals.push(arr[0]);
                vals.push(arr[1]);
                vals.push(out);
                vals.push(n)
            } else {
                if (n > 0) {
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(arr[0]);
                    vals.push(out);
                    vals.push(n)
                } else {
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN);
                    vals.push(Number.NaN)
                }
            }
        }
        return vals
    };
    this.covariance = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var sxy = 0;
        var n = 0;
        var m1 = this.mean(arr1);
        var m2 = this.mean(arr2);
        for (var i = 0; i < arr1.length; i++) {
            sxy += arr1[i] * arr2[i];
            n++
        }
        if (n > 0) {
            sxy /= n;
            return sxy - (m1 * m2)
        }
        return sxy
    };
    this.correlation = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var n = 0;
        var sx = 0;
        var sy = 0;
        var sx2 = 0;
        var sy2 = 0;
        var cov = this.covariance(arr1, arr2);
        var cor = 0;
        for (var i = 0; i < arr1.length; i++) {
            sx += arr1[i];
            sy += arr2[i];
            sx2 += arr1[i] * arr1[i];
            sy2 += arr2[i] * arr2[i];
            n++
        }
        if (n > 0) {
            cor = (n * n) * cov / Math.sqrt(((n * sx2) - (sx * sx)) * ((n * sy2) - (sy * sy)))
        }
        return cor
    };
    this.regression = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var n = 0;
        var sx = 0;
        var sy = 0;
        var sxy = 0;
        var sx2 = 0;
        var sy2 = 0;
        var cov = this.covariance(arr1, arr2);
        var cor = 0;
        var slope = 0;
        var inter = 0;
        for (var i = 0; i < arr1.length; i++) {
            sx += arr1[i];
            sy += arr2[i];
            sxy += arr1[i] * arr2[i];
            sx2 += arr1[i] * arr1[i];
            sy2 += arr2[i] * arr2[i];
            n++
        }
        if (n > 2) {
            slope = (n * sxy - sx * sy) / (n * sx2 - sx * sx);
            inter = (sy - slope * sx) / n;
            cor = (n * n) * cov / Math.sqrt(((n * sx2) - (sx * sx)) * ((n * sy2) - (sy * sy)))
        }
        return [slope, inter, cor]
    };
    this.slope = function (x0, y0, x1, y1) {
        return y0 != y1 ? (x1 - x0) / (y1 - y0) : 0
    };
    this.intercept = function (x, y, s) {
        return y - (x * s)
    };
    this.slopeIntercept = function (x0, y0, x1, y1) {
        var s = this.slope(x0, y0, x1, y1);
        return [s, this.intercept(x0, y0, s)]
    };
    this.normalize = function (d) {
        for (var i = 0; i < d.length; i++) {
            var msd = this.meanStandardDeviationN(d[i]);
            for (var j = 0; j < d[i].length; j++) {
                d[i][j] = (d[i][j] - msd[0]) / msd[1]
            }
        }
        return d
    };
    this.euclidianDistance = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var d = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                d += Math.pow(arr1[i] - arr2[i], 2)
            }
            d = Math.sqrt(d)
        }
        return d
    };
    this.manhattanDistance = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var d = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                d += Math.abs(arr1[i] - arr2[i])
            }
        }
        return d
    };
    this.maxDistance = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var d = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                d = Math.max(d, Math.abs(arr1[i] - arr2[i]))
            }
        }
        return d
    };
    this.addVectors = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var arr = [];
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                arr.push(arr1[i] + arr2[i])
            }
        }
        return arr
    };
    this.compareVectors = function (arr1, arr2) {
        if (this.isArray(arr1) && this.isArray(arr2)) {
            if (arr1.length != arr2.length) {
                return false
            }
            for (var i = 0; i < arr1.length; i++) {
                if (this.isArray(arr1[i]) && this.isArray(arr2[i])) {
                    if (!this.compareArrays(arr1[i], arr2[i])) {
                        return false
                    }
                }
                if (arr1[i] !== arr2[i]) {
                    return false
                }
            }
            return true
        }
    };
    this.vectorDotProduct = function (arr1, arr2, filterSmps, filterVars) {
        var clean = this.cleanArrays(arr1, arr2, filterSmps, filterVars);
        arr1 = clean[0];
        arr2 = clean[1];
        var s = 0;
        if (arr1.length == arr2.length) {
            for (var i = 0; i < arr1.length; i++) {
                s += arr1[i] * arr2[i]
            }
        }
        return s
    };
    this.multiplyVectorByValue = function (arr, val, filterSmps, filterVars) {
        arr = this.cleanArray(arr, filterSmps, filterVars);
        for (var i = 0; i < arr.length; i++) {
            arr[i] *= val
        }
        return arr
    };
    this.getCentroid = function (c1s, c1c, c2s, c2c) {
        var c = [];
        if (c1c.length == c2c.length) {
            var s = c1s + c2s;
            for (var i = 0; i < c1c.length; i++) {
                c.push((c1s * c1c[i] + c2s * c2c[i]) / s)
            }
        }
        return c
    };
    this.createNode = function (id, l, r, d, c, m) {
        var n = {
            id: id,
            left: l,
            right: r,
            dist: d,
            centroid: c
        };
        if (m) {
            n.mid = m
        }
        if (l == null && r == null) {
            n.size = 1;
            n.depth = 0
        } else {
            n.size = l.size + r.size;
            n.depth = 1 + Math.max(l.depth, r.depth)
        }
        return n
    };
    this.createRandomVectors = function (k, vectors) {
        var n = vectors.length;
        if (k > n) {
            return null
        }
        var sv = [];
        var si = [];
        var ti = {};
        var t = 0;
        var s = 0;
        var v, sel;
        while (s < k) {
            if (t == n) {
                return null
            }
            var ri = Math.floor(Math.random() * n);
            if (ri in ti) {
                continue
            }
            ti[ri] = 1;
            t++;
            v = vectors[ri];
            sel = true;
            for (var i = 0; i < s; i++) {
                if (this.compareVectors(v, sv[i])) {
                    sel = false;
                    break
                }
            }
            if (sel) {
                sv[s] = v;
                si[s] = ri;
                s++
            }
        }
        return {
            vectors: sv,
            indices: si
        }
    };
    this.imputeDatum = function (idx) {
        var vals = [];
        if (this.clusterAxis == "samples") {
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                vals.push(this.data.y.data[ii][idx])
            }
        } else {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var ii = this.smpIndices[i];
                vals.push(this.data.y.data[idx][ii])
            }
        }
        return this[this.imputeMethod](vals)
    };
    this.getIdsForClustering = function () {
        var d = [];
        if (this.clusterAxis == "samples") {
            for (var i = 0; i < this.smpIndices.length; i++) {
                var ii = this.smpIndices[i];
                d[i] = this.useSmpVarIndexOnClustering ? ii : this.data.y.smps[ii]
            }
        } else {
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                d[i] = this.useSmpVarIndexOnClustering ? ii : this.data.y.vars[ii]
            }
        }
        return d
    };
    this.getDataForClustering = function () {
        var d = [];
        var m = [];
        if (this.clusterAxis == "samples") {
            for (var i = 0; i < this.smpIndices.length; i++) {
                d[i] = []
            }
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                for (var j = 0; j < this.smpIndices.length; j++) {
                    var jj = this.smpIndices[j];
                    var val = this.data.y.data[ii][jj];
                    if (isNaN(val)) {
                        if (!m[j]) {
                            m[j] = this.imputeDatum(jj)
                        }
                        val = m[j]
                    }
                    d[j][i] = val
                }
            }
        } else {
            for (var i = 0; i < this.varIndices.length; i++) {
                d[i] = []
            }
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                for (var j = 0; j < this.smpIndices.length; j++) {
                    var jj = this.smpIndices[j];
                    var val = this.data.y.data[ii][jj];
                    if (isNaN(val)) {
                        if (!m[i]) {
                            m[i] = this.imputeDatum(ii)
                        }
                        val = m[i]
                    }
                    d[i][j] = val
                }
            }
        }
        if (this.centerData) {
            d = this.normalize(d)
        }
        return d
    };
    this.cluster = function () {
        this.useSmpVarIndexOnClustering = true;
        var tree;
        var d = this.getDataForClustering();
        var l = this.getIdsForClustering();
        var dis = [];
        var minD = [];
        var cSize = [];
        var cls = [];
        for (var i = 0; i < d.length; i++) {
            dis[i] = []
        }
        for (var i = 0; i < d.length; i++) {
            dis[i][i] = Number.POSITIVE_INFINITY;
            for (var j = i + 1; j < d.length; j++) {
                dis[i][j] = this[this.distance + "Distance"](d[i], d[j]);
                dis[j][i] = dis[i][j]
            }
        }
        for (var i = 0; i < d.length; i++) {
            minD[i] = 0;
            for (var j = 0; j < d.length; j++) {
                if (dis[i][minD[i]] > dis[i][j]) {
                    minD[i] = j
                }
            }
        }
        for (var i = 0; i < d.length; i++) {
            cls[i] = [];
            cls[i][0] = this.createNode(l[i], null, null, 0, d[i]);
            cSize[i] = 1
        }
        for (var p = 0; p < d.length - 1; p++) {
            var c1 = 0;
            for (var i = 0; i < d.length; i++) {
                if (dis[i][minD[i]] < dis[c1][minD[c1]]) {
                    c1 = i
                }
            }
            var c2 = minD[c1];
            var c1c = cls[c1][0];
            var c2c = cls[c2][0];
            var newCntd = this.getCentroid(c1c.size, c1c.centroid, c2c.size, c2c.centroid);
            var newCls = this.createNode(-1, c1c, c2c, dis[c1][c2], newCntd);
            cls[c1].splice(0, 0, newCls);
            cSize[c1] += cSize[c2];
            for (var j = 0; j < d.length; j++) {
                if (this.linkage == "single") {
                    if (dis[c1][j] > dis[c2][j]) {
                        dis[j][c1] = dis[c1][j] = dis[c2][j]
                    }
                } else {
                    if (this.linkage == "complete") {
                        if (dis[c1][j] < dis[c2][j]) {
                            dis[j][c1] = dis[c1][j] = dis[c2][j]
                        }
                    } else {
                        if (this.linkage == "average") {
                            dis[j][c1] = dis[c1][j] = (cSize[c1] * dis[c1][j] + cSize[c2] * dis[c2][j]) / (cSize[c1] + cSize[j])
                        }
                    }
                }
            }
            dis[c1][c1] = Number.POSITIVE_INFINITY;
            for (var i = 0; i < d.length; i++) {
                dis[i][c2] = dis[c2][i] = Number.POSITIVE_INFINITY
            }
            for (var j = 0; j < d.length; j++) {
                if (minD[j] == c2) {
                    minD[j] = c1
                }
                if (dis[c1][j] < dis[c1][minD[c1]]) {
                    minD[c1] = j
                }
            }
            tree = newCls
        }
        return this.writeNewick(tree)
    };
    this.isLeafNode = function (node) {
        if (node.left == null && node.right == null) {
            return true
        } else {
            return false
        }
    };
    this.writeNewick = function (tree, dist) {
        var str = "";
        var str1 = "";
        if (this.isLeafNode(tree)) {
            str = tree.id
        } else {
            var m;
            var l = this.writeNewick(tree.left, dist);
            var r = this.writeNewick(tree.right, dist);
            if (tree.mid) {
                for (var i = 0; i < tree.mid.length; i++) {
                    if (dist && tree.mid[i].dist) {
                        str1 += "," + tree.mid[i].id + ":" + tree.mid[i].dist
                    } else {
                        str1 += "," + tree.mid[i].id
                    }
                    str1 += tree.mid[i].id
                }
            }
            str = "(" + l + str1 + "," + r + ")"
        }
        if (dist && tree.dist) {
            str += ":" + tree.dist
        }
        return str
    };
    this.kmeans = function () {
        var obj;
        var d = this.getDataForClustering();
        var l = this.getIdsForClustering();
        var assig = [];
        var cSize = [];
        var rep = true;
        var iter = 0;
        var cntd = null;
        var t = this.createRandomVectors(this.kmeansClusters, d);
        if (t == null) {
            return null
        } else {
            cntd = t.vectors
        }
        while (rep) {
            for (var i = 0; i < this.kmeansClusters; i++) {
                cSize[i] = 0
            }
            for (var i = 0; i < d.length; i++) {
                var v = d[i];
                var min = Number.MAX_VALUE;
                var best;
                for (var j = 0; j < this.kmeansClusters; j++) {
                    var dis = this.euclidianDistance(cntd[j], v);
                    if (dis < min) {
                        min = dis;
                        best = j
                    }
                }
                cSize[best]++;
                assig[i] = best
            }
            var newCntd = [];
            for (var i = 0; i < this.kmeansClusters; i++) {
                newCntd[i] = null
            }
            for (var i = 0; i < d.length; i++) {
                if (newCntd[assig[i]] == null) {
                    newCntd[assig[i]] = d[i]
                } else {
                    newCntd[assig[i]] = this.addVectors(newCntd[assig[i]], d[i])
                }
            }
            for (var i = 0; i < this.kmeansClusters; i++) {
                newCntd[i] = this.multiplyVectorByValue(newCntd[i], 1 / cSize[i])
            }
            rep = false;
            for (var i = 0; i < this.kmeansClusters; i++) {
                if (!this.compareVectors(newCntd[i], cntd[i])) {
                    rep = true;
                    break
                }
            }
            cntd = newCntd;
            iter++;
            if (iter > this.maxIterations) {
                rep = false
            }
        }
        for (var i = 0; i < assig.length; i++) {
            assig[i] = "K-" + (assig[i] + 1)
        }
        return assig
    };
    this.transpose = function (data, soft) {
        if (data) {
            var d = [];
            for (var i = 0; i < data.length; i++) {
                for (var j = 0; j < data[i].length; j++) {
                    if (!d[j]) {
                        d[j] = []
                    }
                    d[j][i] = data[i][j]
                }
            }
            return d
        } else {
            this.ungroupSamples();
            this.transform("reset");
            if (this.data.l) {
                delete(this.data.l)
            }
            if (this.data.d) {
                delete(this.data.d)
            }
            if (this.data.a) {
                delete(this.data.a)
            }
            if (this.data.t) {
                var v = this.data.t.vars;
                var s = this.data.t.smps;
                if (v) {
                    this.data.t.smps = v
                }
                if (s) {
                    this.data.t.vars = s
                }
            }
            var x = this.data.x;
            var z = this.data.z;
            if (x) {
                this.data.z = x
            }
            if (z) {
                this.data.x = z
            }
            var s = this.data.y.smps;
            this.data.y.smps = this.data.y.vars;
            this.data.y.vars = s;
            var d = this.data.y.data;
            this.data.y.data = [];
            for (var i = 0; i < this.data.y.vars.length; i++) {
                this.data.y.data[i] = [];
                for (var j = 0; j < this.data.y.smps.length; j++) {
                    this.data.y.data[i][j] = d[j][i]
                }
            }
            if (!soft) {
                this.initializeData(this.data);
                this.resetObject();
                this.draw()
            }
        }
    };
    this.checkObject = function () {
        var level = this.data.y;
        if (this.isGroupedData) {
            this.data.w = {};
            level = this.data.w
        }
        var keys = ["vars", "smps", "desc", "data", "mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "trans", "cor", "sum", "grps", "close", "open", "high", "low", "volume"];
        for (var i = 0; i < keys.length; i++) {
            if (!level[keys[i]]) {
                level[keys[i]] = []
            }
        }
    };
    this.resetObject = function (check) {
        var keys = ["mean", "median", "stdev", "n", "qtl1", "qtl3", "iqr1", "iqr3", "out", "cor", "sum", "grps", "close", "open", "high", "low", "volume"];
        if (this.isGroupedData) {
            if (!this.isTransformedData) {
                keys.push("trans")
            }
            for (var i = 0; i < keys.length; i++) {
                delete(this.data.y[keys[i]])
            }
            delete(this.data.w)
        } else {
            if (!this.isTransformedData) {
                keys.push("trans")
            }
            if (this.isRawData) {
                for (var i = 0; i < keys.length; i++) {
                    delete(this.data.y[keys[i]])
                }
            } else {
                delete(this.data.y.data)
            }
        }
        if (check) {
            this.checkObject()
        }
    };
    this.getDataAtPos = function (i, j, att, transform, min, max) {
        var val = Number.NaN;
        var level = this.isGroupedData ? this.data.w : this.data.y;
		
        if (this.isGroupedData || !this.isRawData) {
            if (this.isTransformedData) {
                val = level.trans[i][j]
            } else {
                att = att ? att : this.summaryType;
                if (level.hasOwnProperty(att)) {
                    val = level[att][i][j]
                } else {
                    val = 0
                }
            }
        } else {
			if (att) {
                if (level[att] && level[att][i]) {
                    val = level[att][i][j]
                }
            } else {
				if (this.isTransformedData) {
                    val = level.trans[i][j]
                } else {
					val = level.data[i][j]
                }
            }
        }
		
        if (transform) {
            if (!isNaN(val)) {
                if (transform == "log2") {
                    val = Math.log(val) / Math.LN2
                } else {
                    if (transform == "log10") {
                        val = Math.log(val) / Math.LN10
                    } else {
                        if (transform == "exp2") {
                            val = Math.pow(2, val)
                        } else {
                            if (transform == "exp10") {
                                val = Math.pow(2, val)
                            } else {
                                if (transform == "percentile") {
                                    val = this.percentile(min, max, val)
                                }
                            }
                        }
                    }
                }
            }
        }
        return val
    };
    this.getDataForSmpGrpAtIndex = function (idx, indices) {
        var arr = [];
        if (!indices) {
            indices = this.varIndices
        }
        if (this.isGroupedData || !this.isRawData) {
            var level = this.isGroupedData ? this.data.w : this.data.y;
            if (this.isTransformedData) {
                arr.push(level.trans[ii][idx])
            } else {
                var att = this.summaryType;
                if (level.hasOwnProperty(att)) {
                    for (var i = 0; i < indices.length; i++) {
                        var ii = indices[i];
                        arr.push(level[att][ii][idx])
                    }
                }
            }
        } else {
            if (this.isTransformedData) {
                for (var i = 0; i < indices.length; i++) {
                    var ii = indices[i];
                    arr.push(this.data.y.trans[ii][idx])
                }
            } else {
                for (var i = 0; i < indices.length; i++) {
                    var ii = indices[i];
                    arr.push(this.data.y.data[ii][idx])
                }
            }
        }
        return arr
    };
    this.getMetaDataForVariableAtIndex = function (idx) {
        var obj = {};
        if (this.data.z) {
            for (var ant in this.data.z) {
                obj[ant] = this.data.z[ant][idx]
            }
        }
        obj[name] = this.data.y.vars[idx];
        return obj
    };
    this.getMetaDataForSampleAtIndex = function (idx) {
        if (this.isGroupedData) {
            return this.getMetaDataForGrpAtIndex(idx)
        } else {
            return this.getMetaDataForSmpAtIndex(idx)
        }
    };
    this.getMetaDataForSmpAtIndex = function (idx) {
        var obj = {};
        if (this.data.x) {
            for (var ant in this.data.x) {
                obj[ant] = this.data.x[ant][idx]
            }
        }
        obj[name] = this.data.y.vars[idx];
        return obj
    };
    this.getMetaDataForGrpAtIndex = function (idx) {
        var obj = [];
        for (var i = 0; i < this.data.w.grps[idx].length; i++) {
            var ii = this.data.w.grps[idx][i];
            obj.push(this.getMetaDataForSmpAtIndex[ii])
        }
        return obj
    };
    this.summarize = function (type, arrs) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var filterSmp = this.isGroupedData ? false : true;
        if (!this.isGroupedData) {
            this.checkObject()
        }
        if (type == "cor") {
            this.isBoxPlotCalc = false;
            if (this.correlationAxis == "samples") {
                var indices = this.isGroupedData ? this.grpIndices : this.smpIndices;
                for (var i = 0; i < indices.length; i++) {
                    var ii = indices[i];
                    var arr1 = this.getDataForSmpGrpAtIndex(ii);
                    if (!level.cor[ii]) {
                        level.cor[ii] = []
                    }
                    for (var j = i; j < indices.length; j++) {
                        var jj = indices[j];
                        if (!level.cor[jj]) {
                            level.cor[jj] = []
                        }
                        var arr2 = this.getDataForSmpGrpAtIndex(jj);
                        if (i == j) {
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = 1
                            }
                            level.cor[ii][jj] = 1
                        } else {
                            level.cor[ii][jj] = this.correlation(arr1, arr2);
                            level.cor[jj][ii] = level.cor[ii][jj];
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = level.cor[ii][jj];
                                level.trans[jj][ii] = level.cor[jj][ii]
                            }
                        }
                    }
                }
            } else {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var ii = this.varIndices[i];
                    if (!level.cor[ii]) {
                        level.cor[ii] = []
                    }
                    for (var j = i; j < this.varIndices.length; j++) {
                        var jj = this.varIndices[j];
                        if (!level.cor[jj]) {
                            level.cor[jj] = []
                        }
                        if (i == j) {
                            level.cor[ii][jj] = 1;
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = 1
                            }
                        } else {
                            level.cor[ii][jj] = this.correlation(level.data[ii], level.data[jj], filterSmp);
                            level.cor[jj][ii] = level.cor[ii][jj];
                            if (this.isTransformedData) {
                                level.trans[ii][jj] = level.cor[ii][jj];
                                level.trans[jj][ii] = level.cor[jj][ii]
                            }
                        }
                    }
                }
            }
        } else {
            this.isBoxPlotCalc = type == "iqr" ? true : false;
            for (var i = 0; i < this.varIndices.length; i++) {
                var arr;
                var ii = this.varIndices[i];
                if (!level.mean[ii]) {
                    level.trans[ii] = [];
                    level.mean[ii] = [];
                    level.median[ii] = [];
                    level.stdev[ii] = [];
                    level.qtl1[ii] = [];
                    level.qtl3[ii] = [];
                    level.iqr1[ii] = [];
                    level.iqr3[ii] = [];
                    level.out[ii] = [];
                    level.n[ii] = [];
                    level.sum[ii] = []
                }
                if (this.isGroupedData) {
                    arr = arrs[ii]
                } else {
                    level.grps = [];
                    arr = [];
                    for (var j = 0; j < this.smpIndices.length; j++) {
                        var jj = this.smpIndices[j];
                        level.grps[j] = [];
                        level.grps[j].push(jj);
                        arr[j] = [level.data[ii][jj]]
                    }
                }
                if (type == "iqr") {
                    this.summaryType = "iqr";
                    for (var j = 0; j < arr.length; j++) {
                        var vals = this.quantiles(arr[j], filterSmp);
                        if (this.isTransformedData) {
                            level.trans[ii][j] = vals[1]
                        }
                        level.median[ii][j] = vals[1];
                        level.qtl1[ii][j] = vals[0];
                        level.qtl3[ii][j] = vals[2];
                        level.iqr1[ii][j] = vals[3];
                        level.iqr3[ii][j] = vals[4];
                        level.out[ii][j] = vals[5];
                        level.n[ii][j] = vals[6]
                    }
                } else {
                    if (type == "median") {
                        this.summaryType = "median";
                        for (var j = 0; j < arr.length; j++) {
                            var vals = this.median(arr[j], filterSmp);
                            if (this.isTransformedData) {
                                level.trans[ii][j] = vals[1]
                            }
                            level.median[ii][j] = vals[0];
                            level.n[ii][j] = vals[1]
                        }
                    } else {
                        if (type == "mean") {
                            this.summaryType = "mean";
                            for (var j = 0; j < arr.length; j++) {
                                var vals = this.meanStandardDeviationN(arr[j], filterSmp);
                                if (this.isTransformedData) {
                                    level.trans[ii][j] = vals[1]
                                }
                                level.mean[ii][j] = vals[0];
                                level.stdev[ii][j] = vals[1];
                                level.n[ii][j] = vals[2]
                            }
                        } else {
                            if (type == "sum") {
                                this.summaryType = "sum";
                                for (var j = 0; j < arr.length; j++) {
                                    var sum = this.sum(arr[j], filterSmp);
                                    if (this.isTransformedData) {
                                        level.trans[ii][j] = sum
                                    }
                                    level.sum[ii][j] = sum;
                                    level.n[ii][j] = arr[j].length
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.copySummarizedData = function () {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var exp;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            level.data[ii] = [];
            level.trans[ii] = [];
            if (this.summaryType == "mean") {
                for (var j = 0; j < level.mean[ii].length; j++) {
                    level.data[ii][j] = level.mean[ii][j]
                }
            } else {
                if (this.summaryType == "median" || this.summaryType == "iqr") {
                    for (var j = 0; j < level.median[ii].length; j++) {
                        level.data[ii][j] = level.median[ii][j]
                    }
                } else {
                    if (this.summaryType == "candle") {
                        for (var j = 0; j < level.close[ii].length; j++) {
                            level.data[ii][j] = level.close[ii][j]
                        }
                    } else {
                        if (this.summaryType == "volume") {
                            for (var j = 0; j < level.volume[ii].length; j++) {
                                level.data[ii][j] = level.volume[ii][j]
                            }
                        } else {
                            if (this.summaryType == "sum") {
                                for (var j = 0; j < level.volume[ii].length; j++) {
                                    level.data[ii][j] = level.sum[ii][j]
                                }
                            }
                        }
                    }
                }
            }
            if (!exp) {
                exp = ii
            }
        }
        return exp
    };
    this.transformValue = function (type, val, inv) {
        switch (type) {
            case "log2":
                return inv ? Math.pow(2, val) : Math.log(val) / Math.LN2;
            case "log10":
                return inv ? Math.pow(10, val) : Math.log(val) / Math.LN10;
            case "exp2":
                return inv ? Math.log(val) / Math.LN2 : Math.pow(2, val);
            case "exp10":
                return inv ? Math.log(val) / Math.LN10 : Math.pow(10, val);
            default:
                return val
        }
    };
    this.transform = function (type, axis, idx) {
        var exp = 0;
        if (!this.isGroupedData) {
            this.checkObject()
        }
        if (!this.isRawData || this.isGroupedData) {
            exp = this.copySummarizedData()
        }
        this.transformType = type;
        if (type == "reset" || type == "undo") {
            this.transformReset();
            this.transformType = false;
            this.isTransformedData = false
        } else {
            if (type == "save") {
                this.transformSave();
                this.transformType = false;
                this.isTransformedData = false
            } else {
                if (type == "log2" || type == "log10" || type == "exp2" || type == "exp10") {
                    this.transformLogExp(type);
                    this.isTransformedData = true
                } else {
                    if (type == "ratio" || type == "ratio2" || type == "ratio10") {
                        this.transformRatio(type, idx);
                        this.isTransformedData = true
                    } else {
                        this.transformRelative(type, axis, exp);
                        this.isTransformedData = true
                    }
                }
            }
        }
        this.draw()
    };
    this.transformReset = function () {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            for (var j = 0; j < level.data[ii].length; j++) {
                if (level.trans[ii] && !isNaN(level.data[ii][j])) {
                    level.trans[ii][j] = level.data[ii][j]
                }
            }
        }
    };
    this.transformSave = function () {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            for (var j = 0; j < level.data[ii].length; j++) {
                if (!isNaN(level.data[ii][j])) {
                    level.data[ii][j] = level.trans[ii][j]
                }
            }
        }
    };
    this.transformLogExp = function (type) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        if (type == "log") {
            type = this.transformBase == 2 ? "type2" : "type10"
        } else {
            if (type == "exp") {
                type = this.transformBase == 2 ? "exp2" : "exp10"
            }
        }
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            if (!level.trans[ii]) {
                level.trans[ii] = []
            }
            for (var j = 0; j < level.data[ii].length; j++) {
                if (!isNaN(level.data[ii][j])) {
                    if (type == "log2") {
                        this.isLogData = true;
                        this.transformBase = 2;
                        level.trans[ii][j] = Math.log(level.data[ii][j]) / Math.LN2
                    } else {
                        if (type == "log10") {
                            this.isLogData = true;
                            this.transformBase = 10;
                            level.trans[ii][j] = Math.log(level.data[ii][j]) / Math.LN10
                        } else {
                            if (type == "exp2") {
                                this.isLogData = false;
                                this.transformBase = 2;
                                level.trans[ii][j] = Math.pow(2, level.data[ii][j])
                            } else {
                                if (type == "exp10") {
                                    this.isLogData = false;
                                    this.transformBase = 10;
                                    level.trans[ii][j] = Math.pow(10, level.data[ii][j])
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.transformRatio = function (type, idx) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        idx = idx ? idx : this.ratioReference ? this.ratioReference : 0;
        for (var i = 0; i < this.varIndices.length; i++) {
            var ii = this.varIndices[i];
            if (!level.trans[ii]) {
                level.trans[ii] = []
            }
            for (var j = 0; j < level.data[ii].length; j++) {
                if (!isNaN(level.data[ii][j]) && !isNaN(level.data[ii][idx])) {
                    if (this.isLogData) {
                        if (type == "ratio") {
                            type = this.transformBase == 2 ? "ratio2" : "ratio10"
                        }
                        var val;
                        if (level.data[ii][j] >= level.data[ii][idx]) {
                            val = level.data[ii][j] - level.data[ii][idx];
                            if (type == "ratio2") {
                                level.trans[ii][j] = Math.pow(2, val)
                            } else {
                                if (type == "ratio10") {
                                    level.trans[ii][j] = Math.pow(10, val)
                                }
                            }
                        } else {
                            val = level.data[ii][idx] / level.data[ii][i];
                            if (type == "ratio2") {
                                level.trans[ii][j] = Math.pow(2, val) * -1
                            } else {
                                level.trans[ii][j] = Math.pow(10, val) * -1
                            }
                        }
                    } else {
                        if (level.data[ii][j] >= level.data[ii][idx]) {
                            level.trans[ii][j] = level.data[ii][j] / level.data[ii][idx]
                        } else {
                            level.trans[ii][j] = level.data[ii][idx] / level.data[ii][j] * -1
                        }
                    }
                }
            }
        }
    };
    this.transformRelative = function (type, axis, exp) {
        var level = this.isGroupedData ? this.data.w : this.data.y;
        var filterSmp = this.isGroupedData ? false : true;
        axis = axis ? axis : this.zscoreAxis ? this.zscoreAxis : "samples";
        if (axis == "samples") {
            for (var i = 0; i < level.data[exp].length; i++) {
                var arr = [];
                for (var j = 0; j < this.varIndices.length; j++) {
                    var jj = this.varIndices[j];
                    arr.push(level.data[jj][i])
                }
                if (type == "percentile") {
                    var vals = this.range(arr, filterSmp)
                } else {
                    if (type == "zscore") {
                        var vals = this.meanStandardDeviationN(arr, filterSmp)
                    }
                }
                for (var j = 0; j < this.varIndices.length; j++) {
                    var jj = this.varIndices[j];
                    if (!level.trans[jj]) {
                        level.trans[jj] = []
                    }
                    if (!isNaN(level.data[jj][i])) {
                        if (type == "percentile") {
                            level.trans[jj][i] = this.percentile(vals[0], vals[1], level.data[jj][i])
                        } else {
                            if (type == "zscore") {
                                level.trans[jj][i] = (level.data[jj][i] - vals[0]) / vals[1]
                            }
                        }
                    }
                }
            }
        } else {
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                level.trans[ii] = [];
                var arr = level.data[ii];
                if (type == "percentile") {
                    var vals = this.range(arr, filterSmp)
                } else {
                    if (type == "zscore") {
                        var vals = this.meanStandardDeviationN(arr, filterSmp)
                    }
                }
                for (var j = 0; j < arr.length; j++) {
                    if (!isNaN(level.data[ii][j])) {
                        if (type == "percentile") {
                            level.trans[ii][j] = this.percentile(vals[0], vals[1], level.data[ii][j])
                        } else {
                            if (type == "zscore") {
                                level.trans[ii][j] = (level.data[ii][j] - vals[0]) / vals[1]
                            }
                        }
                    }
                }
            }
        }
    };
    this.sortSamples = function (d, c, v) {
        this.sortIndices("smps", d, c, false, v);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortSamplesByCategory = function (c) {
        this.sortIndices("smps", false, c);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortSamplesByVariable = function (v) {
        var i = parseInt(this.getVariableIndices(v));
        this.sortIndices("smps", false, false, false, i + 1);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortVariables = function (d, c, s) {
        this.sortIndices("vars", d, c, s);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortVariablesByCategory = function (c) {
        this.sortIndices("vars", false, c);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.sortVariablesBySample = function (v) {
        var i = parseInt(this.getSampleIndices(v));
        this.sortIndices("vars", false, false, i + 1);
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.getGroupingFactors = function (asArray) {
        if (asArray) {
            return this.groupingFactors
        } else {
            return this.getObjectArray(this.groupingFactors)
        }
    };
    this.modifyGroupingFactors = function (grps, check) {
        this.modifyObjectArray(grps, check, "groupingFactors")
    };
    this.segregateSamplesVariables = function (smps, vars, snme, vnme, nd) {
        delete(this.data.l);
        this.deleteSubGraphAttributes();
        this.data.l = {};
        this.data.l.smps = smps;
        this.data.l.vars = vars;
        this.data.l.weight = [];
        this.data.l.type = [];
        this.data.l.name = [];
        this.data.l.desc = [];
        var ws = 1 / smps.length;
        var wv = 1 / vars.length;
        var desc = this.data.y.desc[0] ? this.data.y.desc[0] : "";
        for (var i = 0; i < vars.length; i++) {
            for (var j = 0; j < smps.length; j++) {
                this.data.l.weight.push([wv, ws]);
                this.data.l.type.push(this.graphType);
                this.data.l.name.push([vnme[i], snme[j]]);
                this.data.l.desc.push(desc)
            }
        }
        this.layoutComb = true;
        this.layout = smps.length + "X" + vars.length;
        this.isValidLayout();
        if (!nd) {
            this.draw()
        }
    };
    this.desegregateSamples = function (nd) {
        this.segregateSamplesBy = false;
        this.showAnimation = this.showAnimationTemp;
        this.resetLayout();
        if (this.segregateVariablesBy) {
            this.segregateVariables(this.segregateVariablesBy, nd)
        } else {
            this.isValidLayout()
        }
        if (!nd) {
            this.draw()
        }
    };
    this.segregateSamples = function (annt, nd) {
        if (this.data.x && this.data.x[annt]) {
            delete(this.layoutParams);
            var l = {};
            var n = 0;
            var names = [];
            var smps = [];
            for (var i = 0; i < this.data.x[annt].length; i++) {
                var s = this.data.x[annt][i];
                if (!l.hasOwnProperty(s)) {
                    l[s] = [];
                    n++
                }
                l[s].push(this.data.y.smps[i])
            }
            var w = 1 / n;
            if (this.segregateVariablesBy) {
                vars = this.data.l.vars;
                for (var s in l) {
                    names.push(s);
                    smps.push(l[s])
                }
                this.segregateSamplesBy = annt;
                this.segregateSamplesVariables(smps, this.data.l.vars, names, this.data.l.name, nd)
            } else {
                delete(this.data.l);
                this.deleteSubGraphAttributes();
                this.data.l = {};
                this.data.l.smps = [];
                this.data.l.weight = [];
                this.data.l.type = [];
                this.data.l.name = [];
                this.data.l.desc = [];
                for (var s in l) {
                    this.data.l.smps.push(l[s]);
                    this.data.l.weight.push(w);
                    this.data.l.type.push(this.graphType);
                    this.data.l.name.push(s);
                    this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "")
                }
                this.segregateSamplesBy = annt;
                this.layoutComb = true;
                this.showAnimationTemp = this.showAnimation;
                this.showAnimation = false;
                this.layout = "1X" + this.data.l.smps.length;
                this.isValidLayout()
            }
            if (!nd) {
                this.draw()
            }
        }
    };
    this.desegregateVariables = function (nd) {
        this.segregateVariablesBy = false;
        this.showAnimation = this.showAnimationTemp;
        this.resetLayout();
        if (this.segregateSamplesBy) {
            this.segregateSamples(this.segregateSamplesBy, nd)
        } else {
            this.isValidLayout()
        }
        if (!nd) {
            this.draw()
        }
    };
    this.segregateVariables = function (cat, nd) {
        if (this.data.z && this.data.z[cat]) {
            delete(this.layoutParams);
            var l = {};
            var n = 0;
            var vars = [];
            var names = [];
            for (var i = 0; i < this.data.z[cat].length; i++) {
                var g = this.data.z[cat][i];
                if (!l.hasOwnProperty(g)) {
                    l[g] = [];
                    n++
                }
                l[g].push(this.data.y.vars[i])
            }
            var w = 1 / n;
            if (this.segregateSamplesBy) {
                for (var g in l) {
                    names.push(g);
                    vars.push(l[g])
                }
                this.segregateVariablesBy = cat;
                this.segregateSamplesVariables(this.data.l.smps, vars, this.data.l.name, names, nd)
            } else {
                delete(this.data.l);
                this.deleteSubGraphAttributes();
                this.data.l = {};
                this.data.l.vars = [];
                this.data.l.weight = [];
                this.data.l.type = [];
                this.data.l.name = [];
                this.data.l.desc = [];
                for (var g in l) {
                    this.data.l.vars.push(l[g]);
                    this.data.l.weight.push(w);
                    this.data.l.type.push(this.graphType);
                    this.data.l.name.push(g);
                    this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "")
                }
                this.segregateVariablesBy = cat;
                this.layoutComb = true;
                this.showAnimationTemp = this.showAnimation;
                this.showAnimation = false;
                this.layout = "1X" + this.data.l.vars.length;
                this.isValidLayout()
            }
            if (!nd) {
                this.draw()
            }
        }
    };
    this.deleteSubGraphAttributes = function () {
        if (this.layoutRows && this.layoutCols) {
            var c = 0;
            for (var i = 0; i < this.layoutRows; i++) {
                for (var j = 0; j < this.layoutCols; j++) {
                    delete(this["subGraphWeight" + c]);
                    delete(this["subGraphType" + c]);
                    delete(this["subGraphSummaryType" + c]);
                    delete(this["subGraphTransformType" + c]);
                    c++
                }
            }
        }
    };
    this.unsetAllVsAll = function () {
        if (this.graphType.match(/Scatter/)) {
            if (this.xAxisTemp && this.xAxisTemp.length > 0) {
                this.xAxis = this.xAxisTemp;
                this.xAxisTmp = []
            }
            if (this.yAxisTemp && this.yAxisTemp.length > 0) {
                this.yAxis = this.yAxisTemp;
                this.yAxisTmp = []
            }
            if (this.zAxisTemp && this.zAxisTemp.length > 0) {
                this.zAxis = this.zAxisTemp;
                this.zAxisTmp = []
            }
            if (!this.xAxis || !this.yAxis) {
                this.xAxis = [];
                this.yAxis = [];
                this.xAxisIndices = [];
                this.yAxisIndices = [];
                this.xAxis = [this.data.y.smps[0]];
                for (var i = 1; i < this.data.y.smps.length; i++) {
                    this.yAxis.push(this.data.y.smps[i])
                }
                this.xAxisIndices = this.getSampleIndices(this.xAxis);
                this.yAxisIndices = this.getSampleIndices(this.yAxis);
                this.initAxes(true)
            }
            this.allVsAll = false;
            if (this.showAnimationTemp) {
                this.showAnimation = this.showAnimationTemp
            }
            this.resetLayout();
            this.isValidLayout()
        }
    };
    this.setAllVsAll = function () {
        if (this.graphType.match(/Scatter/)) {
            var n = this.data.y.data[0].length;
            var w = 1 / n;
            this.xAxisTemp = this.xAxisTemp || this.xAxis;
            this.xAxis = [];
            this.yAxisTemp = this.yAxisTemp || this.yAxis;
            this.yAxis = [];
            this.zAxisTemp = this.zAxisTemp || this.zAxis;
            this.zAxis = [];
            this.data.l = {};
            this.data.l.smps = [];
            this.data.l.weight = [];
            this.data.l.type = [];
            this.data.l.desc = [];
            for (var i = 0; i < n; i++) {
                for (var j = 0; j < n; j++) {
                    this.data.l.weight.push(w);
                    this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
                    this.data.l.type.push(this.graphType);
                    if (i == j) {
                        this.data.l.smps.push({})
                    } else {
                        if (this.allVsAllType == "upper") {
                            if (j > i) {
                                this.data.l.smps.push({
                                    xAxis: [this.data.y.smps[j]],
                                    yAxis: [this.data.y.smps[i]]
                                })
                            } else {
                                this.data.l.smps.push({})
                            }
                        } else {
                            if (this.allVsAllType == "lower") {
                                if (i > j) {
                                    this.data.l.smps.push({
                                        xAxis: [this.data.y.smps[j]],
                                        yAxis: [this.data.y.smps[i]]
                                    })
                                } else {
                                    this.data.l.smps.push({})
                                }
                            } else {
                                this.data.l.smps.push({
                                    xAxis: [this.data.y.smps[j]],
                                    yAxis: [this.data.y.smps[i]]
                                })
                            }
                        }
                    }
                }
            }
            this.layoutComb = true;
            this.showAnimationTemp = this.showAnimation;
            this.showAnimation = false;
            this.layout = n + "X" + n;
            this.isValidLayout()
        }
    };
    this.setMultiplePies = function () {
        if (this.graphType.match(/Pie/)) {
            var r, c;
            var n = this.xAxis.length;
            if (this.layout) {
                var topo = this.layout.split(/X/i);
                r = parseInt(topo[0]);
                c = parseInt(topo[1]);
                if (r * c < n) {
                    r = Math.ceil(Math.sqrt(n));
                    c = Math.floor(Math.sqrt(n));
                    this.layout = r + "X" + c
                }
            } else {
                r = Math.ceil(Math.sqrt(n));
                c = Math.floor(Math.sqrt(n));
                this.layout = r + "X" + c
            }
            var wr = 1 / r;
            var wc = 1 / c;
            delete(this.layoutParams);
            delete(this.data.l);
            this.deleteSubGraphAttributes();
            this.data.l = {};
            this.data.l.smps = [];
            this.data.l.weight = [];
            this.data.l.type = [];
            this.data.l.desc = [];
            for (var i = 0; i < n; i++) {
                this.data.l.smps.push([this.xAxis[i]]);
                this.data.l.weight.push([wc, wr]);
                this.data.l.desc.push(this.data.y.desc && this.data.y.desc[0] ? this.data.y.desc[0] : "");
                this.data.l.type.push(this.graphType)
            }
            this.layoutComb = true;
            this.showAnimationTemp = this.showAnimation;
            this.showAnimation = false;
            this.isValidLayout()
        }
    };
    this.ungroupSamples = function () {
        this.isGroupedData = false;
        this.groupingFactors = [];
        this.grpIndices = [];
        this.hiddenGrps = [];
        this.setMaxSmpStringName();
        this.setOriginalIndices(0, false, false, true);
        this.draw();
        return
    };
    this.createHistogram = function (axis) {
        var idx, arr, range, size, bin;
        var cnt = 0;
        var indices = [];
        var xa = [];
        var ya = [];
        var data = {};
        data.y = {};
        data.y.data = [];
        data.y.vars = [];
        data.y.smps = [];
        if (this.graphType.match(/Scatter/)) {
            if (this.type2D == "XYZ") {
                idx = axis == "y" ? this.yAxisIndices[this.yAxisCurrent] : this.xAxisIndices[this.xAxisCurrent];
                indices.push(idx)
            } else {
                if (this.type2D == "XY") {
                    for (var i = 0; i < this.xAxisIndices.length; i++) {
                        idx = axis == "y" ? this.yAxisIndices[i] : this.xAxisIndices[i];
                        indices.push(idx)
                    }
                } else {
                    if (this.type2D == "X") {
                        if (axis == "y") {
                            indices.push(this.yAxisIndices[this.yAxisCurrent])
                        } else {
                            for (var i = 0; i < this.xAxisIndices.length; i++) {
                                indices.push(this.xAxisIndices[i])
                            }
                        }
                    } else {
                        if (axis == "y") {
                            for (var i = 0; i < this.yAxisIndices.length; i++) {
                                indices.push(this.yAxisIndices[i])
                            }
                        } else {
                            indices.push(this.xAxisIndices[this.xAxisCurrent])
                        }
                    }
                }
            }
            for (var i = 0; i < this.histogramBins; i++) {
                data.y.vars.push("Bin" + (i + 1));
                data.y.data[i] = []
            }
            for (var i = 0; i < indices.length; i++) {
                data.y.smps.push(this.data.y.smps[indices[i]]);
                data.y.smps.push(this.data.y.smps[indices[i]] + " counts");
                xa.push(this.data.y.smps[indices[i]]);
                ya.push(this.data.y.smps[indices[i]] + " counts");
                var hist = [];
                for (var j = 0; j < this.histogramBins; j++) {
                    hist[j] = 0
                }
                arr = this.getDataForSmpGrpAtIndex(indices[i]);
                range = this.range(arr);
                size = ((range[1] - range[0]) / this.histogramBins) + (range[0] / (this.histogramBins * 2));
                for (var j = 0; j < arr.length; j++) {
                    bin = Math.floor((arr[j] - range[0]) / size);
                    hist[bin]++
                }
                for (var j = 0; j < this.histogramBins; j++) {
                    data.y.data[j][cnt] = size * (j + 1)
                }
                cnt++;
                for (var j = 0; j < this.histogramBins; j++) {
                    data.y.data[j][cnt] = hist[j]
                }
                cnt++
            }
            this.isCreateHistogram = true;
            this.isHistogram = true;
            this.histogramBarWidthStndBy = this.histogramBarWidth;
            this.dataStndBy = this.data;
            this.data = {};
            this.resetConfig(["graphType", "isHistogram"]);
            this.xAxis = xa;
            this.yAxis = ya;
            this.showLegend = false;
            this.histogramBarWidth = 1.5;
            this.initializeData(data)
        }
    };
    this.removeHistogram = function () {
        this.isCreateHistogram = false;
        this.histogramBarWidth = this.histogramBarWidthStndBy;
        this.switchData()
    };
    this.addRegressionLine = function () {
        var xi, yi, arr1, arr2, reg, lab, col;
        if (this.graphType.match(/Scatter/)) {
            if (this.type2D == "XYZ") {
                xi = this.xAxisIndices[this.xAxisCurrent];
                yi = this.yAxisIndices[this.yAxisCurrent];
                lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                arr1 = this.getDataForSmpGrpAtIndex(xi);
                arr2 = this.getDataForSmpGrpAtIndex(yi);
                reg = this.regression(arr1, arr2);
                this.addRegressionDecoration(reg, lab, this.foreground)
            } else {
                if (this.type2D == "XY") {
                    for (var i = 0; i < this.xAxisIndices.length; i++) {
                        col = i % this.colors.length;
                        xi = this.xAxisIndices[i];
                        yi = this.yAxisIndices[i];
                        lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                        arr1 = this.getDataForSmpGrpAtIndex(xi);
                        arr2 = this.getDataForSmpGrpAtIndex(yi);
                        reg = this.regression(arr1, arr2);
                        this.addRegressionDecoration(reg, lab, this.colors[col])
                    }
                } else {
                    if (this.type2D == "X") {
                        yi = this.yAxisIndices[this.yAxisCurrent];
                        arr2 = this.getDataForSmpGrpAtIndex(yi);
                        for (var i = 0; i < this.xAxisIndices.length; i++) {
                            col = i % this.colors.length;
                            xi = this.xAxisIndices[i];
                            lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                            arr1 = this.getDataForSmpGrpAtIndex(xi);
                            reg = this.regression(arr1, arr2);
                            this.addRegressionDecoration(reg, lab, this.colors[col])
                        }
                    } else {
                        xi = this.xAxisIndices[this.xAxisCurrent];
                        arr1 = this.getDataForSmpGrpAtIndex(xi);
                        for (var i = 0; i < this.yAxisIndices.length; i++) {
                            col = i % this.colors.length;
                            yi = this.yAxisIndices[i];
                            arr2 = this.getDataForSmpGrpAtIndex(yi);
                            lab = this.data.y.smps[xi] + " vs " + this.data.y.smps[yi];
                            reg = this.regression(arr1, arr2);
                            this.addRegressionDecoration(reg, lab, this.colors[col])
                        }
                    }
                }
            }
        }
    };
    this.addRegressionDecoration = function (reg, lab, col) {
        this.showDecorations = true;
        if (!this.data.d) {
            this.data.d = {}
        }
        if (!this.data.d.reg) {
            this.data.d.reg = []
        }
        this.data.d.reg.push({
            slope: reg[0],
            intercept: reg[1],
            cor: reg[2],
            label: lab,
            color: col
        })
    };
    this.addNormalDistributionLine = function (axis) {
        var indices, indices1, idx, idx1, arr, arr1, max, lab, nor, lab, col, cur;
        if (this.graphType.match(/Scatter/)) {
            if (this.type2D == "XYZ") {
                idx = axis == "y" ? this.yAxisIndices[this.yAxisCurrent] : this.xAxisIndices[this.xAxisCurrent];
                idx1 = axis == "y" ? this.xAxisIndices[this.xAxisCurrent] : this.yAxisIndices[this.yAxisCurrent];
                arr = this.getDataForSmpGrpAtIndex(idx);
                arr1 = this.getDataForSmpGrpAtIndex(idx1);
                max = this.max(arr1);
                lab = this.data.y.smps[idx];
                nor = this.meanStandardDeviationN(arr);
                this.addNormalDistributionDecoration(nor, max, lab, this.foreground, axis)
            } else {
                indices = axis == "y" ? this.yAxisIndices : this.xAxisIndices;
                indices1 = axis == "y" ? this.xAxisIndices : this.yAxisIndices;
                cur = axis == "y" ? this.xAxisCurrent : this.yAxisCurrent;
                for (var i = 0; i < indices.length; i++) {
                    col = i % this.colors.length;
                    idx = indices[i];
                    idx1 = indices1[i] ? indices1[i] : indices1[cur];
                    arr = this.getDataForSmpGrpAtIndex(idx);
                    arr1 = this.getDataForSmpGrpAtIndex(idx1);
                    max = this.max(arr1);
                    lab = this.data.y.smps[idx];
                    nor = this.meanStandardDeviationN(arr);
                    this.addNormalDistributionDecoration(nor, max, lab, this.colors[col], axis)
                }
            }
        }
    };
    this.addNormalDistributionDecoration = function (nor, max, lab, col, axis) {
        this.showDecorations = true;
        if (!this.data.d) {
            this.data.d = {}
        }
        if (!this.data.d.nor) {
            this.data.d.nor = []
        }
        if (axis && axis == "y") {
            this.data.d.nor.push({
                mu: nor[0],
                sigma: nor[1],
                yAxis: true,
                max: max,
                label: lab,
                color: col
            })
        } else {
            this.data.d.nor.push({
                mu: nor[0],
                sigma: nor[1],
                max: max,
                label: lab,
                color: col
            })
        }
    };
    this.addKaplanMeierCurve = function (time, censored, label, color) {
        var km = false;
        var tmp = {
            d: {},
            c: {}
        };
        var ts = {};
        var z = 1.95996;
        var z2 = z * z;
        var p, q, n, d, u, l;
        if (time && censored) {
            var ti = this.getSampleIndices(time);
            var ci = this.getSampleIndices(censored);
            if (ti != null && ci != null) {
                for (var i = 0; i < this.varIndices.length; i++) {
                    var t = this.data.y.data[i][ti];
                    var c = this.data.y.data[i][ci];
                    if (!isNaN(c)) {
                        if (!isNaN(c) && c == 0) {
                            tmp.d[t] = tmp.d[t] ? tmp.d[t] + 1 : 1;
                            ts[t] = true
                        } else {
                            tmp.c[t] = tmp.c[t] ? tmp.c[t] + 1 : 1;
                            ts[t] = true
                        }
                    }
                }
                ts = this.getKeys(ts);
                ts.sort(function (a, b) {
                    return a - b
                });
                km = {
                    times: ts,
                    data: []
                };
                for (var i = 0; i < ts.length; i++) {
                    km.data.push([tmp.c[ts[i]] || 0, tmp.d[ts[i]] || 0])
                }
                km.data[0].push(this.varIndices.length);
                for (var i = 1; i < ts.length; i++) {
                    km.data[i].push(km.data[i - 1][2] - (km.data[i - 1][0] + km.data[i - 1][1]))
                }
                p = 1;
                for (var i = 0; i < ts.length; i++) {
                    p = p * (1 - (km.data[i][1] / km.data[i][2]));
                    q = 1 - p;
                    n = (2 * p * this.varIndices.length) + z2 + 1 + (z * Math.sqrt(z2 + 2 - (1 / this.varIndices.length) + 4 * p * ((q * this.varIndices.length) - 1)));
                    d = 2 * (this.varIndices.length + z2);
                    u = n / d;
                    if (p == 1) {
                        u = 1
                    }
                    n = (2 * p * this.varIndices.length) + z2 - 1 - (z * Math.sqrt(z2 - 2 - (1 / this.varIndices.length) + 4 * p * ((q * this.varIndices.length) + 1)));
                    l = n / d;
                    if (p == 0) {
                        l = 0
                    }
                    km.data[i].push(p, u, l)
                }
                this.addKaplanMeierDecoration(time, km, label, color)
            }
        }
    };
    this.addKaplanMeierDecoration = function (time, km, label, color) {
        this.showDecorations = true;
        if (!this.data.d) {
            this.data.d = {}
        }
        if (!this.data.d.kaplanMeier) {
            this.data.d.kaplanMeier = []
        }
        this.data.d.kaplanMeier.push({
            time: time,
            data: km,
            label: label || "Kaplan - Meier " + (this.data.d.kaplanMeier.length + 1),
            color: color || this.colors[this.data.d.kaplanMeier.length % this.colors.length]
        })
    };
    this.addLineDecoration = function (t, c, v, l) {
        if (!this.graphType.match(/Scatter|Network|Genome|Correlation|Venn|Circular/)) {
            if (!this.data.d) {
                this.data.d = {}
            }
            if (!this.data.d.lines) {
                this.data.d.lines = []
            }
            if (t && t == "solid") {
                t = "line"
            }
            this.data.d.lines.push({
                type: t || "line",
                color: c || this.foreground,
                value: v || 0,
                label: l || false
            })
        }
    };
    this.createRandomData = function () {
        var data = {};
        data.y = {};
        data.y.data = [];
        data.y.vars = [];
        data.y.smps = [];
        for (var i = 0; i < this.randomDataSamples; i++) {
            data.y.smps[i] = "Sample" + (i + 1)
        }
        for (var i = 0; i < this.randomDataVariables; i++) {
            data.y.data[i] = [];
            data.y.vars[i] = "Variable" + (i + 1);
            for (var j = 0; j < this.randomDataSamples; j++) {
                data.y.data[i].push(Math.floor(((Math.random() * 2 - 1) + (Math.random() * 2 - 1) + (Math.random() * 2 - 1)) * this.randomDataSigma + this.randomDataMean))
            }
        }
        data.x = {};
        var r = Math.floor(this.randomDataSamples / this.randomDataSampleAnnotationRatio);
        for (var i = 0; i < this.randomDataSampleAnnotations; i++) {
            data.x["Factor" + (i + 1)] = [];
            for (var j = 0; j < this.randomDataSamples; j++) {
                data.x["Factor" + (i + 1)][j] = "Level" + (Math.floor(Math.random() * r) + 1)
            }
        }
        data.z = {};
        var r = Math.floor(this.randomDataVariables / this.randomDataVariableAnnotationRatio);
        for (var i = 0; i < this.randomDataVariableAnnotations; i++) {
            data.z["Annt" + (i + 1)] = [];
            for (var j = 0; j < this.randomDataVariables; j++) {
                data.z["Annt" + (i + 1)][j] = "Desc" + (Math.floor(Math.random() * r) + 1)
            }
        }
        if (this.data && !this.dataStndBy) {
            this.dataStndBy = this.data;
            this.data = {}
        }
        this.resetConfig(["graphType"]);
        this.initializeData(data);
        this.draw()
    };
    this.restoreRandomData = function () {
        this.switchData()
    };
    this.groupSamples = function (annt, stypes, gidxs) {
        if (annt.length < 1) {
            return this.ungroupSamples()
        }
        for (var i = 0; i < annt.length; i++) {
            if (!annt || !this.data.x[annt[i]]) {
                return this.ungroupSamples()
            }
        }
        if (this.layoutComb && this.data.l.comp) {
            this.varIndices = [];
            for (var i = 0; i < this.data.l.comp.length; i++) {
                for (var j = 0; j < this.data.l.comp[i].length; j++) {
                    this.varIndices.push(this.data.l.comp[i][j])
                }
            }
        }
        this.resetIndices();
        this.isGroupedData = true;
        this.groupingFactors = annt;
        this.resetObject(true);
        this.hiddenGrps = [];
        var grps = {};
        var map = [];
        var cnt = 0;
        for (var i = 0; i < this.smpIndices.length; i++) {
            var ii = this.smpIndices[i];
            var keys = [];
            var key;
            for (var j = 0; j < annt.length; j++) {
                var jj = annt[j];
                key = this.data.x[jj][ii];
                if (!key) {
                    key = "NA"
                }
                keys.push(key)
            }
            key = keys.join(" - ");
            if (!grps.hasOwnProperty(key)) {
                this.data.w.smps.push(key);
                map[cnt] = key;
                grps[key] = [];
                grps[key].push(ii);
                cnt++
            } else {
                grps[key].push(ii)
            }
        }
        for (var i = 0; i < map.length; i++) {
            var key = map[i];
            this.data.w.grps.push(grps[key])
        }
        this.grpIndices = [];
        if (gidxs) {
            for (var i = 0; i < gidxs.length; i++) {
                this.grpIndices.push(gidxs[i]);
                this.hiddenGrps.push(false)
            }
        } else {
            for (var i = 0; i < this.data.w.grps.length; i++) {
                this.grpIndices.push(i);
                this.hiddenGrps.push(false)
            }
        }
        for (var i = 0; i < this.varIndices.length; i++) {
            this.data.w.vars.push(this.data.y.vars[this.varIndices[i]])
        }
        var types = [];
        if (stypes) {
            if (this.isArray(stypes)) {
                types = stypes
            } else {
                types.push(stypes)
            }
        } else {
            stypes = this.graphType == "Boxplot" ? "iqr" : "mean";
            types.push(stypes)
        }
        for (var t = 0; t < types.length; t++) {
            var arrs = [];
            var type = types[t];
            if (this.isTransformedData) {
                data = this.data.y.trans
            } else {
                if (this.isRawData) {
                    data = this.data.y.data
                } else {
                    if (this.summaryType == "median" || this.summaryType == "iqr") {
                        data = this.data.y.median
                    } else {
                        if (this.summaryType == "mean") {
                            data = this.data.y.mean
                        } else {
                            if (this.summaryType == "cor") {
                                data = this.data.y.cor
                            } else {
                                if (this.summaryType == "sum") {
                                    data = this.data.y.sum
                                } else {
                                    data = this.data.y[this.summaryType]
                                }
                            }
                        }
                    }
                }
            }
            for (var i = 0; i < this.varIndices.length; i++) {
                var ii = this.varIndices[i];
                arrs[ii] = [];
                for (var j = 0; j < this.data.w.grps.length; j++) {
                    arrs[ii][j] = [];
                    for (var k = 0; k < this.data.w.grps[j].length; k++) {
                        var kk = this.data.w.grps[j][k];
                        arrs[ii][j].push(data[ii][kk])
                    }
                }
            }
            this.summarize(type, arrs)
        }
        this.setMaxVarStringName();
        this.setMaxSmpStringName();
        this.xAxisValues = [];
        this.xAxis2Values = [];
        this.yAxisValues = [];
        this.zAxisValues = [];
        if (!this.layoutComb || !this.layoutAdjust) {
            if (typeof (this.setAxes) == "function") {
                this.setAxes()
            }
        }
        this.setOriginalIndices(0, false, false, true);
        this.draw()
    };
    this.initializeDataAttributes = function (vIndices, sIndices) {
        this.setIndices(vIndices, sIndices);
        if (this.graphType != "Network" && this.graphType != "Genome" && this.graphType != "Venn") {
            this.setMaxVarStringAttr();
            this.setMaxSmpStringAttr()
        }
    };
    this.initializeData = function (newData) {
        if (data && !newData) {
            this.isExample = false;
            this.data = data;
            delete data
        } else {
            if (newData) {
                this.isExample = false;
                this.data = newData;
                delete newData
            } else {
                if (!this.remoteService) {
                    this.isExample = true
                }
                this.data = this.exampleRawData
            }
        }
        this.samplesData = false;
        this.variablesData = false;
        this.nodesData = false;
        this.edgesData = false;
        this.featuresData = false;
        this.validGraphTypes = [];
        if (this.data.y || this.data.venn || this.data.nodes || this.data.tracks || this.data.market || this.data.fx) {
            if (this.data.fx) {
                this.FunctionData()
            }
            if (this.data.market) {
                this.setMarketData();
                this.summaryType = "candle";
                this.validGraphTypes.push("Candlestick")
            }
            if (this.data.venn) {
                this.summaryType = "venn";
                this.validGraphTypes.push("Venn")
            }
            if (this.data.nodes) {
                this.summaryType = "network";
                this.validGraphTypes.push("Network")
            }
            if (this.data.tracks) {
                this.summaryType = "genome";
                this.validGraphTypes.push("Genome")
            }
            if (this.data.y) {
                if (!this.data.y.data && !this.data.y.mean && !this.data.y.median && !this.data.y.cor && !this.data.y.sum && !this.data.y.close) {
                    alert("Dude! there is not a valid data structure");
                    return
                } else {
                    if (this.data.y.data) {
                        this.isRawData = true;
                        this.summaryType = "raw"
                    } else {
                        this.isRawData = false;
                        if (this.data.y.iqr1 && this.data.y.qtl1 && this.data.y.median && this.data.y.qtl3 && this.data.y.iqr3) {
                            this.summaryType = "iqr"
                        } else {
                            if (this.data.y.median) {
                                this.summaryType = "median"
                            } else {
                                if (this.data.y.mean) {
                                    this.summaryType = "mean"
                                } else {
                                    if (this.data.y.cor) {
                                        this.summaryType = "cor"
                                    } else {
                                        if (this.data.y.sum) {
                                            this.summaryType = "sum"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                this.validGraphTypes.push("Bar");
                this.validGraphTypes.push("Line");
                this.validGraphTypes.push("Area");
                this.validGraphTypes.push("AreaLine");
                this.validGraphTypes.push("BarLine");
                this.validGraphTypes.push("Boxplot");
                this.validGraphTypes.push("Dotplot");
                this.validGraphTypes.push("Heatmap");
                this.validGraphTypes.push("Stacked");
                this.validGraphTypes.push("StackedLine");
                this.validGraphTypes.push("StackedPercent");
                this.validGraphTypes.push("StackedPercentLine");
                this.validGraphTypes.push("Pie");
                this.validGraphTypes.push("Correlation");
                this.validGraphTypes.push("Circular");
                if (this.data.y.smps) {
                    if (this.data.y.smps.length > 2) {
                        this.validGraphTypes.push("Scatter2D");
                        this.validGraphTypes.push("ScatterBubble2D");
                        this.validGraphTypes.push("Scatter3D")
                    } else {
                        if (this.data.y.smps.length > 1) {
                            this.validGraphTypes.push("Scatter2D")
                        }
                    }
                }
            }
            this.validGraphTypes.sort()
        }
        this.initializeDataAttributes(this.data.initialVarIndices, this.data.initialSmpIndices);
        delete(this.data.initialVarIndices);
        delete(this.data.initialSmpIndices)
    };
    this.setMarketTechnicalData = function () {
        if (this.stockIndicators.length > 0) {
            var n = {};
            var e = false;
            var v = {
                Sma5: 5,
                Sma10: 10,
                Sma20: 20,
                Sma25: 25,
                Sma50: 50
            };
            var r = [];
            for (var i = 0; i < this.stockIndicators.length; i++) {
                if (v.hasOwnProperty(this.stockIndicators[i])) {
                    r.push(this.stockIndicators[i])
                }
            }
            if (r.length > 0) {
                this.stockIndicators = r;
                var t = {};
                for (var i = 0; i < this.stockIndicators.length; i++) {
                    var s = this.stockIndicators[i];
                    if (v.hasOwnProperty(s) && !this.data.y.hasOwnProperty(s)) {
                        n[s] = true;
                        e = true;
                        t[s] = [];
                        this.data.y[s] = [];
                        for (var j = 0; j < this.data.y.vars.length; j++) {
                            t[s][j] = [];
                            this.data.y[s][j] = []
                        }
                    }
                }
                if (e) {
                    for (var i = 0; i < this.data.y.smps.length; i++) {
                        for (var j = 0; j < this.data.y.vars.length; j++) {
                            for (var k = 0; k < this.stockIndicators.length; k++) {
                                var s = this.stockIndicators[k];
                                if (n.hasOwnProperty(s)) {
                                    if (!isNaN(this.data.y.close[j][i])) {
                                        t[s][j].push(this.data.y.close[j][i]);
                                        if (t[s][j].length == v[s]) {
                                            if (s.match(/Sma/)) {
                                                this.data.y[s][j][i] = this.mean(t[s][j]);
                                                t[s][j].shift()
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };
    this.setMarketData = function () {
        if (this.data.market && !this.isMarketDataFormated) {
            var input = this.data.market;
            this.data.market = {};
            this.data.market.smps = [];
            this.data.market.vars = [];
            this.data.market.close = [];
            this.data.market.open = [];
            this.data.market.high = [];
            this.data.market.low = [];
            this.data.market.volume = [];
            this.data.market.desc = ["Price", "Vol"];
            var dates = {};
            var t = 0;
            for (var i = 0; i < input.length; i++) {
                this.data.market.vars.push(input[i].symbol);
                this.data.market.close[i] = [];
                this.data.market.open[i] = [];
                this.data.market.high[i] = [];
                this.data.market.low[i] = [];
                this.data.market.volume[i] = [];
                var data = input[i].data;
                for (var j = data.length - 1; j >= 0; j--) {
                    var d = this.parseDate(data[j][0]);
                    var idx = 0;
                    if (!dates.hasOwnProperty(d)) {
                        idx = t;
                        dates[d] = t;
                        this.data.market.smps.push(d);
                        t++
                    } else {
                        idx = dates[d]
                    }
                    this.data.market.open[i][idx] = data[j][1];
                    this.data.market.high[i][idx] = data[j][2];
                    this.data.market.low[i][idx] = data[j][3];
                    this.data.market.close[i][idx] = data[j][4];
                    this.data.market.volume[i][idx] = data[j][5]
                }
            }
        }
        this.isMarketDataFormated = true
    };
    this.switchToMarketData = function () {
        var market = this.data.market;
        this.dataStndBy = this.data;
        this.data = {};
        this.data.y = market;
        this.initializeDataAttributes();
        if (this.showVolume) {
            this.deleteSubGraphAttributes();
            this.data.l = {};
            this.data.l.vars = [this.data.y.vars, this.data.y.vars];
            this.data.l.weight = this.graphOrientation == "vertical" ? [0.75, 0.25] : [0.25, 0.75];
            this.data.l.type = ["Candlestick", "Candlestick"];
            this.data.l.name = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
            this.data.l.desc = this.graphOrientation == "vertical" ? ["Price", "Volume"] : ["Volume", "Price"];
            this.segregateSamplesBy = false;
            this.segregateVariablesBy = false;
            this.layoutComb = true;
            this.layout = "1X2";
            this.isValidLayout()
        }
    };
    this.switchFromMarketData = function () {
        this.switchData();
        if (this.showVolume) {
            this.resetLayout();
            this.isValidLayout()
        }
    };
    this.switchData = function () {
        if (this.dataStndBy) {
            this.initConfig();
            this.data = this.dataStndBy;
            this.initializeData(this.data)
        }
    };
    this.updateData = function (data) {
        this.initializeData(data);
        this.initializeGraph()
    };
    this.initializeData()
};
CanvasXpress.prototype.FunctionData = function () {
    this.implied = function (a) {
        if (a == "neg") {
            return false
        }
        return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|\w+$/.test(a)
    };
    this.tokenize = function (f) {
        var b;
        var a = [];
        var d = new String("");
        var c = /(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[xy]|[a-z]+|[-+*\/(),^]|<=?|>=?|==|!=|&&|\|\|/g;
        f = f.toLowerCase();
        f = f.replace(/\s/g, "");
        f = f.replace(/\+\+/g, "+");
        f = f.replace(/\+-/g, "-");
        f = f.replace(/-\+/g, "-");
        f = f.replace(/--/g, "+");
        f = f.replace(/^\+/, "");
        f = f.replace(/([(*\/&\|<>=])\+/g, "$1");
        f = f.replace(/^-/, "neg ");
        f = f.replace(/([(*\/&\|<>=])-/g, "$1neg ");
        f = f.replace(/\)(\(|\w)/g, ")*$1");
        f = f.replace(/(\d)\(/g, "$1*(");
        while (b = c.exec(f)) {
            if (this.implied(d) && this.implied(b[0].toString())) {
                a.push("*")
            }
            a.push(d = b[0])
        }
        return a
    };
    this.isValidEnd = function (a) {
        return /^(\d+\.\d+|\d+\.?|\.\d+)(e[-+]?\d+)?|[)xye]|pi|rand$/.test(a)
    };
    this.toPostFx = function (d) {
        var b = new String();
        var c = new String("");
        var a = new Array();
        var e = new Array();
        while (b = d.shift()) {
            if (b == "(") {
                a.push(b)
            } else {
                if (this.precedence[b]) {
                    while (a.length && a[a.length - 1] != "(" && this.precedence[a[a.length - 1]] >= this.precedence[b]) {
                        e.push(a.pop())
                    }
                    if (b == "," && !this.isValidEnd(c)) {
                        e.push("Unexpected: " + c)
                    }
                    if (b != ",") {
                        a.push(b)
                    }
                } else {
                    if (b == ")") {
                        if (!this.isValidEnd(c)) {
                            e.push("Unexpected: " + c)
                        }
                        while (a.length && a[a.length - 1] != "(") {
                            e.push(a.pop())
                        }
                        if (a.length == 0) {
                            e.push("Unmatched: )")
                        }
                        a.pop()
                    } else {
                        if (/^[-+]?(\d+\.?|\d*\.\d+)(e[-+]?\d+)?$/.test(b)) {
                            e.push(b)
                        } else {
                            e.push("Unknown: " + b)
                        }
                    }
                }
            }
            c = b
        }
        if (!this.isValidEnd(c)) {
            e.push("Unexpected: " + c)
        }
        while (b = a.pop()) {
            if (b == "(") {
                e.push("Unmatched: (")
            }
            e.push(b)
        }
        return e
    };
    this.syntaxCheck = function (d) {
        var a = new Number(0);
        var c = new String();
        for (var b = 0; b < d.length; b++, a++) {
            if (/^Un(matched|known|expected).*/.test(c = d[b])) {
                return c
            }
            if (this.expects[c]) {
                if (a < this.expects[c]) {
                    return "Invalid use of: " + c
                }
                a -= this.expects[c]
            }
        }
        return a == 1 ? false : (d.length ? "Unused arguments" : "No function")
    };
    this.evaluate = function (e, b, f) {
        var a = new Array();
        var d = new String();
        for (var c = 0; c < e.length; c++) {
            d = e[c];
            if (d == "x") {
                a.push(b)
            } else {
                if (d == "y") {
                    a.push(f)
                } else {
                    if (d == "pi") {
                        a.push(Math.PI)
                    } else {
                        if (d == "e") {
                            a.push(Math.E)
                        } else {
                            if (d == "rand") {
                                a.push(Math.random())
                            } else {
                                if (this[this.alias[d] || d]) {
                                    a.push(this[this.alias[d] || d](a.pop(), this[this.alias[d] || d].length > 1 ? a.pop() : 0))
                                } else {
                                    a.push(d)
                                }
                            }
                        }
                    }
                }
            }
            if (isNaN(a[a.length - 1])) {
                return Number.NaN
            }
        }
        return parseFloat(a.pop())
    };
    this.set2DPlot = function (j, g) {
        var k = {
            vars: [],
            smps: ["X", "Y"],
            data: []
        };
        var f = this.setMinX ? this.setMinX : (0 - 1);
        var b = this.setMaxX ? this.setMaxX : (1 - 0);
        var e = this.setMinY ? this.setMinY : (0 - 1);
        var a = this.setMaxY ? this.setMaxY : (1 - 0);
        var p = (b - f) / this.functionIntervals;
        var o = (a - e) / this.functionIntervals;
        var c = 1;
        if (g == 1) {
            var m = f;
            for (var h = 0; h < this.functionIntervals; h++) {
                var l = this.evaluate(j, m, 0);
                if (isNaN(l)) {
                    l = ""
                }
                m += p;
                k.vars.push("v" + c);
                k.data.push([m, l]);
                c++
            }
        } else {
            var l = e;
            for (var h = 0; h < this.functionIntervals; h++) {
                var m = this.evaluate(j, 0, l);
                if (isNaN(m)) {
                    m = ""
                }
                l += o;
                k.vars.push("v" + c);
                k.data.push([m, l]);
                c++
            }
        }
        return k
    };
    this.set3DPlot = function (k) {
        var l = {
            vars: [],
            smps: ["X", "Y", "Z"],
            data: []
        };
        var f = this.setMinX ? this.setMinX : -Math.PI / 2;
        var b = this.setMaxX ? this.setMaxX : Math.PI / 2;
        var e = this.setMinY ? this.setMinY : -Math.PI / 2;
        var a = this.setMaxY ? this.setMaxY : Math.PI / 2;
        var q = this.width <= 180 ? 20 : this.width <= 600 ? 30 : 40;
        var c = 1;
        for (var h = 0; h <= q; h++) {
            var o = e + (a - e) * h / q;
            for (var g = 0; g <= q; g++) {
                var p = f + (b - f) * g / q;
                var m = this.evaluate(k, p, o);
                if (!isFinite(m)) {
                    m = 0
                }
                l.vars.push("v" + c);
                l.data.push([p, m, o]);
                c++
            }
        }
        return l
    };
    this.initializeFunctionData = function () {
        var e = this.toPostFx(this.tokenize(this.data.fx));
        var c = this.syntaxCheck(e);
        if (c) {
            alert(c);
            return
        }
        var a = 0;
        for (var b in e) {
            if (e[b] == "x") {
                a |= 1
            } else {
                if (e[b] == "y") {
                    a |= 2
                }
            }
        }
        var d;
        if (a == 0) {
            a = 1
        }
        if (a == 3) {
            this.data.y = this.set3DPlot(e);
            this.graphType = "Scatter3D";
            this.colorBy = "Y"
        } else {
            this.data.y = this.set2DPlot(e, a);
            this.graphType = "Scatter2D";
            this.lineType = "spline"
        }
        this.scatterType = "function"
    };
    this.initializeFunctionData()
};
CanvasXpress.prototype.initRemote = function () {
    this.ajaxRequest = function (url, callback, format, method) {
        format = format == "json" ? "json" : "text";
        method = method == "POST" ? "POST" : "GET";
        var http = false;
        if (window.XMLHttpRequest) {
            try {
                http = new XMLHttpRequest()
            } catch (e) {
                http = false
            }
        } else {
            if (typeof ActiveXObject != "undefined") {
                try {
                    http = new ActiveXObject("Msxml2.XMLHTTP")
                } catch (e) {
                    try {
                        http = new ActiveXObject("Microsoft.XMLHTTP")
                    } catch (E) {
                        http = false
                    }
                }
            }
        }
        if (http && url && callback) {
            var now = "uid=" + new Date().getTime();
            url += (url.indexOf("?") + 1) ? "&" : "?";
            url += now;
            http.open(method, url, true);
            if (method == "GET") {
                if (http.overrideMimeType) {
                    http.overrideMimeType("text/xml")
                }
            } else {
                var parameters = false;
                var parts = url.split("?");
                url = parts[0];
                parameters = parts[1];
                http.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                http.setRequestHeader("Content-length", parameters.length);
                http.setRequestHeader("Connection", "close")
            }
            http.onreadystatechange = function () {
                if (http.readyState == 4) {
                    if (http.status == 200) {
                        var result = "";
                        if (http.responseText) {
                            result = http.responseText
                        }
                        if (format == "json") {
                            result = result.replace(/[\n\r]/g, "");
                            result = eval("(" + result + ")")
                        }
                        if (callback) {
                            callback(result)
                        }
                    } else {
                        alert(http.status)
                    }
                }
            };
            http.send(parameters)
        }
    };
    this.requestRemoteData = function (ini) {
        this.hideViewport();
        var params = "index=" + this.remoteDataIndex + "&dir=" + this.remoteDirection;
        for (var p in this.remoteParams) {
            params += "&" + p + "=" + this.remoteParams[p]
        }
        if (ini) {
            params += "&records=true"
        }
        var url = this.remoteService + "?" + params;
        this.ajaxRequest(url, this.updateRemoteData, "json", "GET")
    };
    this.requestRemoteIds = function (d) {
        if (this.remoteUpdate) {
            var params = "update=true";
            for (var p in this.remoteParams) {
                params += "&" + p + "=" + this.remoteParams[p]
            }
            var url = this.remoteService + "?" + params;
            var that = this;
            var updater = function () {
                this.update = function () {
                    clearInterval(cl);
                    that.ajaxRequest(url, that.updateRemoteIds, "json", "GET")
                };
                var cl = setInterval(this.update, d / 5 || 1)
            };
            updater.call()
        }
    };
    this.updateRemoteIds = function (t) {
        return function (res) {
            var that = t;
            var s = document.getElementById(t.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
            if (s) {
                if (res.ids) {
                    that.remoteIds = res.ids
                }
                var c = s.selectedIndex;
                var x = s.childNodes[c].text;
                var updater = function () {
                    this.update = function () {
                        if (s.childNodes.length >= that.remoteIds.length) {
                            that.remoteUpdate = false;
                            clearInterval(cl)
                        } else {
                            that.resetSelectOptionsRemoteData(s, x);
                            that.requestRemoteIds()
                        }
                    };
                    var cl = setInterval(this.update, that.remoteUpdateDelay)
                };
                updater.call()
            }
        }
    }(this);
    this.saveRemoteParameters = function (o) {
        var params = "index=" + this.remoteDataIndex + "&save=true";
        for (var p in this.remoteParams) {
            params += "&" + p + "=" + this.remoteParams[p]
        }
        params += "&params=" + JSON.stringify(this.userConfig);
        var url = this.remoteService + "?" + params;
        this.ajaxRequest(url, function () {
            alert("Parameters svaed")
        }, "json", "POST")
    };
    this.castRemoteParameters = function (o) {
        o.remoteParentId = this.remoteParentId;
        o.remoteService = this.remoteService;
        o.remoteDirection = this.remoteDirection;
        o.remoteDataIndex = this.remoteDataIndex;
        o.remoteWindow = this.remoteWindow;
        o.remoteAutoPlay = this.remoteAutoPlay;
        o.remoteAutoPlayDelay = this.remoteAutoPlayDelay;
        for (var p in this.remoteParams) {
            o.remoteParams[p] = this.remoteParams[p]
        }
        o.addRemoveNavigationTopListeners("addEvtListener");
        o.addRemoveNavigationLeftRightListeners("addEvtListener")
    };
    this.maintainIndices = function (n) {
        if (!this.graphType.match(/Network|Genome|Venn/) && !n.config.graphType.match(/Network|Genome|Venn/)) {
            if (this.data.y.vars.length == n.data.y.vars.length) {
                n.data.initialVarIndices = this.varIndices
            }
            if (this.data.y.smps.length == n.data.y.smps.length) {
                n.data.initialSmpIndices = this.smpIndices
            }
        }
    };
    this.maintainState = function (n) {
        if (!this.graphType.match(/Network|Genome|Venn/) && !n.graphType.match(/Network|Genome|Venn/)) {
            if (this.isGroupedData && n.data.x) {
                for (var i = 0; i < this.groupingFactors.length; i++) {
                    if (!n.data.x[this.groupingFactors[i]]) {
                        return
                    }
                }
                if (this.isCompatibleGraphType(this.graphType, n.graphType)) {
                    n.graphType = this.graphType
                }
                var gidxs = this.data.y.smps.length == n.data.y.smps.length ? this.grpIndices : false;
                n.groupSamples(this.groupingFactors, false, gidxs)
            }
        }
    };
    this.updateRemoteData = function (t) {
        return function (res) {
            if (res && res.data) {
                var d = t.appendUserConfig(res.data);
                var a = t.remoteDirection == "next" ? true : false;
                var w = document.getElementById("container-" + t.target);
                if (w) {
                    var p = w.parentNode;
                    var r = w.getClientRects();
                    var o = document.getElementById(t.target);
                    var l = t.target;
                    t.insertTarget(d.renderTo, w, o.width, o.height, a);
                    d.hidden = true;
                    t.maintainIndices(d);
                    var n = new CanvasXpress(d);
                    t.castRemoteParameters(n);
                    t.maintainState(n);
                    t.addSelectOptionsRemoteData(res.ids);
                    t.resetInfoSpan(false, true);
                    t.animateTransition(p, r[0], l);
                    t.requestRemoteIds(t.remoteUpdateDelay);
                    if (t.Ext) {
                        if (!n.Ext) {
                            n.Ext = {
                                canvasId: d.renderTo,
                                canvas: n,
                                extId: t.Ext.id || t.Ext.extId
                            }
                        }
                    }
                    if (res.postprocess) {
                        for (var i = 0; i < res.postprocess.length; i++) {
                            var fn = res.postprocess[i].func;
                            var pr = res.postprocess[i].param;
                            if (fn) {
                                if (pr) {
                                    n[fn].apply(n, pr)
                                } else {
                                    n[fn]()
                                }
                            }
                        }
                    }
                    if (res.info) {
                        n.updateInfoDiv(res.info);
                        n.showInfoDiv()
                    }
                    if (t.showCode) {
                        n.updateCodeDiv()
                    }
                }
            } else {
                t.remoteDataIndex = t.remoteDirection == "next" ? t.remoteDataIndex - 1 : t.remoteDataIndex + 1;
                t.remoteUpdating = false
            }
        }
    }(this);
    this.appendUserConfig = function (d) {
        for (var i in this.userConfig) {
            if (!i.match(/decrease|remote/)) {
                if (!d.config[i]) {
                    d.config[i] = this.userConfig[i]
                }
            }
        }
        return d
    };
    this.updateCurrentRemoteData = function (s, c) {
        if (!s) {
            s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
        }
        if (!c) {
            c = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent")
        }
        if (s && c) {
            s.selectedIndex = this.remoteDataIndex;
            if (this.remoteIds.length == 0) {
                for (var i = 0; i < s.childNodes.length; i++) {
                    this.remoteIds.push(s.childNodes[i].text)
                }
            }
            if (s.childNodes[s.selectedIndex]) {
                var v = s.childNodes[s.selectedIndex].text;
                c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
            } else {
                this.resetSelectOptionsRemoteData(s)
            }
        }
    };
    this.resetSelectOptionsRemoteData = function (s, t) {
        if (!s) {
            s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
        }
        if (s) {
            if (this.remoteIds.length == 0) {
                for (var i = 0; i < s.childNodes.length; i++) {
                    this.remoteIds.push(s.childNodes[i].text)
                }
            }
            this.clearSelectOptionsRemoteData(s);
            this.addSelectOptionsRemoteData(this.remoteIds, s, t)
        }
    };
    this.clearSelectOptionsRemoteData = function (s) {
        if (!s) {
            s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
        }
        if (s && s.hasChildNodes()) {
            while (s.childNodes.length >= 1) {
                s.removeChild(s.firstChild)
            }
        }
    };
    this.addSelectOptionsRemoteData = function (ids, s, t) {
        if (ids) {
            this.remoteIds = ids;
            if (!s) {
                s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect")
            }
            if (s) {
                for (var i = 0; i < this.remoteIds.length; i++) {
                    var opt = document.createElement("option");
                    opt.text = this.remoteIds[i];
                    opt.value = i;
                    if (t) {
                        if (this.remoteIds[i] == t) {
                            opt.selected = "selected";
                            this.remoteDataIndex = i;
                            s.selectedIndex = this.remoteDataIndex
                        }
                    } else {
                        if (this.remoteDataIndex == i) {
                            opt.selected = "selected";
                            s.selectedIndex = this.remoteDataIndex
                        }
                    }
                    try {
                        s.add(opt, null)
                    } catch (ex) {
                        s.add(opt)
                    }
                }
                if (this.remoteIds.length == 1) {
                    this.hideNavigation()
                } else {
                    this.showNavigation()
                }
            }
        }
    };
    this.animateTransition = function (b, r, o) {
        if (b && r) {
            var that = this;
            var step = 15;
            var s = 0;
            var c1 = b.firstChild;
            var c2 = b.lastChild;
            var w = r.width;
            var h = r.height;
            b.parentNode.style.overflow = "hidden";
            if (this.isIE) {
                if (this.remoteDirection == "next") {
                    b.removeChild(c1)
                } else {
                    b.removeChild(c2)
                }
                b.parentNode.style.overflow = "visible";
                this.remoteUpdating = false
            } else {
                var updater = function () {
                    this.update = function () {
                        var n = Math.atan((s / step) * 10 - 5) * 0.5 / Math.atan(5) + 0.5;
                        var l = w * n;
                        if (s >= step) {
                            clearInterval(clearUpdateInt);
                            that.destroy(o);
                            if (that.remoteDirection == "next") {
                                c2.style.left = 0 + "px"
                            } else {
                                c1.style.left = 0 + "px"
                            }
                            b.parentNode.style.overflow = "visible";
                            that.remoteUpdating = false;
                            that.updateCurrentRemoteData()
                        } else {
                            if (that.remoteDirection == "next") {
                                c1.style.left = (l * -1) + "px";
                                c2.style.left = (l * -1) + "px"
                            } else {
                                c1.style.left = (-w + l) + "px";
                                c2.style.left = (-w + l) + "px"
                            }
                            c1.style.display = "block";
                            c2.style.display = "block"
                        }
                        s++
                    };
                    var clearUpdateInt = setInterval(this.update, 100)
                };
                updater.call()
            }
        }
    };
    this.handleRemoteSelect = function (t) {
        return function (e) {
            var s = t.isIE ? e.srcElement : e.target;
            var i = s.children[s.selectedIndex].value;
            var c = document.getElementById(t.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent");
            t.remoteDirection = i > t.remoteDataIndex ? "next" : "previous";
            t.remoteDataIndex = i;
            var v = s.children[s.selectedIndex].text;
            if (c && s) {
                s.style.display = "none";
                t.resetSelectOptionsRemoteData(s);
                c.value = v.length > 40 ? v.substring(0, 37) + "..." : v
            }
            t.requestRemoteData()
        }
    }(this);
    this.handleRemoteClickStop = function (t) {
        return function (e) {
            t.remoteStop = true
        }
    }(this);
    this.handleRemoteClickPlay = function (t) {
        return function (e) {
            var s = t.isIE ? e.srcElement.parentNode.lastChild : e.target.parentNode.lastChild;
            t.remoteDirection = "next";
            t.remoteStop = false;
            t.playRemoteData(s)
        }
    }(this);
    this.playRemoteData = function (s) {
        var updater = function () {
            that = CanvasXpress.references[0];
            if (that) {
                if (!that.remoteUpdating && !that.remoteStop) {
                    that.remoteUpdating = true;
                    that.showInfoSpan(false, "Updating ...", true);
                    if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
                        that.remoteDataIndex = 0
                    } else {
                        that.remoteDataIndex++
                    }
                    that.requestRemoteData()
                }
            }
            this.update = function () {
                that = CanvasXpress.references[0];
                if (that) {
                    if (!that.remoteUpdating && !that.remoteStop) {
                        that.remoteUpdating = true;
                        that.showInfoSpan(false, "Updating ...", true);
                        if (s && s.tagName.match(/select/i) && that.remoteDataIndex >= s.length - 1) {
                            that.remoteDataIndex = 0
                        } else {
                            that.remoteDataIndex++
                        }
                        that.requestRemoteData()
                    }
                    if (that.remoteStop) {
                        clearInterval(cl)
                    }
                } else {
                    clearInterval(cl)
                }
            };
            var cl = setInterval(this.update, that.remoteAutoPlayDelay)
        };
        updater.call()
    };
    this.handleRemoteClickPrev = function (t) {
        return function (e) {
            if (!t.remoteUpdating) {
                var s = t.isIE ? e.srcElement.parentNode.lastChild : e.target.parentNode.lastChild;
                t.remoteUpdating = true;
                t.showInfoSpan(false, "Updating ...", true);
                t.remoteDirection = "previous";
                if (s && s.tagName.match(/select/i) && t.remoteDataIndex <= 0) {
                    t.remoteDataIndex = s.length - 1
                } else {
                    t.remoteDataIndex--
                }
                t.requestRemoteData()
            }
        }
    }(this);
    this.handleRemoteClickNext = function (t) {
        return function (e) {
            if (!t.remoteUpdating) {
                var s = t.isIE ? e.srcElement.parentNode.lastChild : e.target.parentNode.lastChild;
                t.remoteUpdating = true;
                t.showInfoSpan(false, "Updating ...", true);
                t.remoteDirection = "next";
                if (s && s.tagName.match(/select/i) && t.remoteDataIndex >= s.length - 1) {
                    t.remoteDataIndex = 0
                } else {
                    t.remoteDataIndex++
                }
                t.requestRemoteData()
            }
        }
    }(this);
    this.handleRemoteClickDown = function (t) {
        return function (e) {
            if (!t.remoteUpdating) {
                var s = document.getElementById(t.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
                if (s) {
                    if (s.style.display == "none") {
                        s.style.display = "block";
                        s.options[s.selectedIndex].selected = true
                    } else {
                        s.style.display = "none"
                    }
                }
            }
        }
    }(this);
    this.addRemoteNavigationTop = function (w) {
        var m = "5px";
        var n = document.createElement("div");
        n.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBar";
        n.style.padding = "2px";
        n.style.color = this.skinColor;
        n.style.border = "1px solid " + this.skinBorderColor;
        n.style.backgroundColor = this.skinBackgroundColor;
        n.style.boxShadow = "2px 2px 2px " + this.skinShadowColor;
        n.style.MozBoxShadow = "2px 2px 2px " + this.skinShadowColor;
        n.style.borderRadius = "4px";
        n.style.width = "435px";
        n.style.position = "absolute";
        n.style.marginLeft = w + "px";
        n.style.zIndex = 9500;
        n.style.display = "none";
        var r = document.createElement("img");
        r.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarPrev";
        r.src = this.imageDir + this.previousButton;
        r.alt = "Previous graph";
        r.title = "Previous graph";
        r.style.margin = m;
        n.appendChild(r);
        var p = document.createElement("img");
        p.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarPlay";
        p.src = this.imageDir + this.playButton;
        p.alt = "Iterate over graphs";
        p.title = "Iterate over graphs";
        p.style.margin = m;
        n.appendChild(p);
        var e = document.createElement("img");
        e.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarStop";
        e.src = this.imageDir + this.stopButton;
        e.alt = "Stop iteration";
        e.title = "Stop iteration";
        e.style.margin = m;
        n.appendChild(e);
        var f = document.createElement("img");
        f.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarNext";
        f.src = this.imageDir + this.nextButton;
        f.alt = "Next graph";
        f.title = "Next graph";
        f.style.margin = m;
        n.appendChild(f);
        var c = document.createElement("input");
        c.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent";
        c.type = "text";
        c.style.padding = "1px 1px 2px 1px";
        c.style.position = "absolute";
        c.style.cursor = "default";
        c.style.display = "block";
        c.style.left = "102px";
        c.style.top = "0px";
        c.style.margin = "5px";
        c.style.width = "322px";
        c.style.borderRadius = "4px";
        c.style.MozBorderRadius = "4px";
        n.appendChild(c);
        var d = document.createElement("img");
        d.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarDown";
        d.src = this.imageDir + this.dropdownButton;
        d.alt = "Select graph";
        d.title = "Select graph";
        d.style.margin = m;
        d.style.position = "absolute";
        d.style.top = "3px";
        d.style.right = "4px";
        n.appendChild(d);
        var s = document.createElement("select");
        s.id = this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect";
        s.style.position = "absolute";
        s.style.margin = "5px";
        s.style.color = this.skinColor;
        s.style.backgroundColor = this.skinBackgroundColor;
        s.style.border = "1px solid " + this.skinBorderColor;
        s.style.marginTop = "1px";
        s.style.left = "102px";
        s.style.top = "26px";
        s.style.maxWidth = "800px";
        s.style.display = "none";
        s.size = 10;
        n.appendChild(s);
        return n
    };
    this.addRemoveNavigationTopListeners = function (t) {
        var r = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarPrev");
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarPlay");
        var e = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarStop");
        var f = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarNext");
        var d = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarDown");
        var s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
        if (r) {
            this[t](r, "click", this.handleRemoteClickPrev, false)
        }
        if (p) {
            this[t](p, "click", this.handleRemoteClickPlay, false)
        }
        if (e) {
            this[t](e, "click", this.handleRemoteClickStop, false)
        }
        if (f) {
            this[t](f, "click", this.handleRemoteClickNext, false)
        }
        if (d) {
            this[t](d, "click", this.handleRemoteClickDown, false)
        }
        if (s) {
            this[t](s, "change", this.handleRemoteSelect, false)
        }
    };
    this.selectDataSet = function (e) {
        var t = document.activeElement;
        if (t.id == this.remoteParentId + "-canvasXpressRemoteWindowTopBarCurrent") {
            var s = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBarSelect");
            var p = [];
            if (s && t.value.length > 0) {
                if (this.remoteIds.length == 0) {
                    for (var i = 0; i < s.childNodes.length; i++) {
                        this.remoteIds.push(s.childNodes[i].text)
                    }
                }
                this.clearSelectOptionsRemoteData(s);
                for (var i = 0; i < this.remoteIds.length; i++) {
                    if (this.remoteIds[i].toLowerCase().indexOf(t.value.toLowerCase()) >= 0) {
                        p.push(i)
                    }
                }
                for (var i = 0; i < p.length; i++) {
                    var o = document.createElement("option");
                    o.text = this.remoteIds[p[i]];
                    o.value = p[i];
                    try {
                        s.add(o, null)
                    } catch (ex) {
                        s.add(o)
                    }
                }
                s.style.display = "block"
            }
        }
    };
    this.addRemoteNavigationBottom = function (w) {
        var n = document.createElement("div");
        n.id = this.remoteParentId + "-canvasXpressRemoteWindowBottomBar";
        n.style.position = "absolute";
        n.style.marginLeft = w + "px";
        n.style.display = "none";
        n.style.height = "18px";
        return n
    };
    this.addRemoteNavigationLeftRight = function (d, w, h, m, q) {
        var n = document.createElement("div");
        var i = document.createElement("img");
        n.style.height = (h + q) + "px";
        n.style.width = m + "px";
        n.style.marginLeft = "3px";
        n.style.marginRight = "3px";
        n.style.top = "0px";
        i.style.position = "absolute";
        i.style.top = (h / 2) + "px";
        i.style.left = "1px";
        if (d == "l") {
            n.style.position = "relative";
            n.id = this.remoteParentId + "-canvasXpressRemoteWindowPrevBar";
            n.style.left = "0px";
            n.style.display = "none";
            i.src = this.imageDir + this.previousButton
        } else {
            n.style.position = "absolute";
            n.id = this.remoteParentId + "-canvasXpressRemoteWindowNextBar";
            n.style.left = (m + w + 14) + "px";
            n.style.display = "none";
            i.src = this.imageDir + this.nextButton
        }
        i.style.margin = "auto";
        n.appendChild(i);
        return n
    };
    this.addRemoveNavigationLeftRightListeners = function (t) {
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var n = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        if (p) {
            this[t](p, "click", this.handleRemoteClickPrev, false)
        }
        if (n) {
            this[t](n, "click", this.handleRemoteClickNext, false)
        }
    };
    this.updateRemoteNavigationWindow = function () {
        var c = document.getElementById(this.target);
        var x = 24;
        var y = 36;
        var l = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var r = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        var w = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindow");
        var b = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBuffer");
        if (l && r && w && b) {
            var il = l.childNodes[0];
            l.style.left = "7px";
            l.style.height = (c.height + y + 7) + "px";
            il.style.top = (c.height / 2) + "px";
            var ir = r.childNodes[0];
            r.style.left = (c.width + x + 7) + "px";
            r.style.height = (c.height + y + 7) + "px";
            ir.style.top = (c.height / 2) + "px";
            w.style.height = ((y * 2) + c.height) + "px";
            w.style.width = ((x * 2) + c.width) + "px";
            b.style.width = (parseInt(c.parentNode.parentNode.clientWidth) * 2) + "px";
            b.style.left = (x + 7) + "px";
            b.style.top = (y + 7) + "px";
            this.resizeExtContainer((x * 2) + c.width)
        }
    };
    this.addRemoteWindow = function () {
        var w = document.getElementById("container-" + this.target);
        var c = document.getElementById(this.target);
        var p = w.parentNode;
        var x = 24;
        var y = 36;
        if (p.id && !p.id.match(/canvasXpressRemoteWindow/)) {
            this.remoteParentId = p.id;
            var d = document.createElement("div");
            var t = this.addRemoteNavigationTop(x + 7);
            var l = this.addRemoteNavigationLeftRight("l", c.width, c.height, x, y + 14);
            var v = document.createElement("div");
            var r = this.addRemoteNavigationLeftRight("r", c.width, c.height, x, y + 14);
            var b = this.addRemoteNavigationBottom(x + 7);
            d.id = this.remoteParentId + "-canvasXpressRemoteWindow";
            d.style.marginTop = "3px";
            d.style.height = (y + 18 + c.height + 14) + "px";
            d.style.width = ((x * 2) + c.width + 14) + "px";
            d.style.position = "relative";
            v.id = this.remoteParentId + "-canvasXpressRemoteWindowBuffer";
            v.style.width = ((parseInt(c.parentNode.parentNode.clientWidth) + 7) * 2) + "px";
            v.style.position = "absolute";
            v.style.left = x + "px";
            v.style.top = y + "px";
            v.style.overflow = "hidden";
            d.appendChild(t);
            d.appendChild(l);
            d.appendChild(v);
            d.appendChild(r);
            d.appendChild(b);
            p.insertBefore(d, w);
            v.appendChild(w.parentNode.appendChild(w));
            this.addRemoveNavigationTopListeners("addEvtListener");
            this.addRemoveNavigationLeftRightListeners("addEvtListener");
            this.requestRemoteData(true);
            this.initialRemoteDataRequest = true;
            if (this.remoteAutoPlay) {
                this.remoteUpdating = true;
                this.remoteDirection = "next";
                this.remoteStop = false;
                this.playRemoteData(t.lastChild)
            }
        } else {
            this.initialRemoteDataRequest = false
        }
    };
    this.resizeExtContainer = function (w, h) {
        if (this.Ext && this.Ext.extId && Ext) {
            var cont = Ext.getCmp(this.Ext.extId);
            var rw = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindow");
            if (cont && rw) {
                var wc = cont.getWidth();
                var hc = cont.getHeight();
                var parent = cont.ownerCt;
                if (parent) {
                    var cl = parent.getXType();
                    var wp = parent.getWidth();
                    var hp = parent.getHeight();
                    var ad = 0;
                    if (cl == "window") {} else {
                        if (cl == "panel") {
                            ad = wp >= w ? 0 : 15;
                            if (wc <= wp && w < wp) {
                                w = wp;
                                ad = -15
                            }
                        }
                    }
                    cont.setWidth(w + ad);
                    cont.doLayout();
                    parent.doLayout();
                    parent.ownerCt.doLayout()
                }
            }
        }
    };
    this.hideNavigation = function () {
        var t = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBar");
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var n = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        var b = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBottomBar");
        if (t) {
            t.style.display = "none"
        }
        if (p) {
            p.style.display = "none"
        }
        if (n) {
            n.style.display = "none"
        }
        if (b) {
            b.style.display = "none"
        }
    };
    this.showNavigation = function () {
        var t = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowTopBar");
        var p = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowPrevBar");
        var n = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowNextBar");
        var b = document.getElementById(this.remoteParentId + "-canvasXpressRemoteWindowBottomBar");
        if (t) {
            t.style.display = "block"
        }
        if (p) {
            p.style.display = "block"
        }
        if (n) {
            n.style.display = "block"
        }
        if (b) {
            b.style.display = "block"
        }
    };
    this.initializeRemote = function () {
        if (this.remoteService) {
            this.addRemoteWindow()
        }
    };
    this.initializeRemote()
};
CanvasXpress.prototype.initGraph = function () {
    this.draw = function (b, d, a, c) {
        this.setUserEvents();
        this.initializeGraph(true, b, d, a, c);
        if (this.userEvents.enddraw) {
            this.userEvents.enddraw.call(this)
        }
    };
    this.isValidGraphType = function (a) {
        switch (a) {
            case "Bar":
            case "Line":
            case "Area":
            case "AreaLine":
            case "Dotplot":
            case "Heatmap":
            case "Stacked":
            case "StackedPercent":
            case "Boxplot":
            case "Correlation":
            case "Pie":
            case "Circular":
                if (this.data.y) {
                    return true
                } else {
                    return false
                }
            case "BarLine":
            case "StackedLine":
            case "StackedPercentLine":
                if (this.data.y && this.data.a && this.data.a.xAxis && this.data.a.xAxis2) {
                    return true
                } else {
                    return false
                }
            case "Scatter2D":
                if (this.data.y && this.data.y.smps && this.data.y.smps.length > 1) {
                    return true
                } else {
                    return false
                }
            case "ScatterBubble2D":
            case "Scatter3D":
                if (this.data.y && this.data.y.smps && this.data.y.smps.length > 2) {
                    return true
                } else {
                    return false
                }
            case "Candlestick":
                if (this.data.market) {
                    return true
                } else {
                    return false
                }
            case "Venn":
                if (this.data.venn) {
                    return true
                } else {
                    return false
                }
            case "Network":
                if (this.data.nodes) {
                    return true
                } else {
                    return false
                }
            case "Genome":
                if (this.data.tracks) {
                    return true
                } else {
                    return false
                }
        }
        return false
    };
    this.setColorScheme = function () {
        switch (this.colorScheme) {
            case "reset":
                this.colors = this.colors0;
                break;
            case "basic":
                this.colors = this.colors1;
                break;
            case "dark":
                this.colors = this.colors2;
                break;
            case "strong":
                this.colors = this.colors3;
                break;
            case "light":
                this.colors = this.colors4;
                break;
            case "pastel":
                this.colors = this.colors5;
                break;
            case "balanced":
                this.colors = this.colors6;
                break;
            case "user":
                this.colors = this.colors;
                break
        }
    };
    this.reinitializeGraph = function () {
        if (this.graphType == "Candlestick") {
            this.isGraphTime = true;
            if (!this.isMarketSwitched) {
                this.switchToMarketData();
                this.initAxes();
                this.summaryType = "candle";
                this.initializeDataAttributes();
                this.isMarketSwitched = true
            }
            this.setMarketTechnicalData()
        } else {
            if (this.isExample && this.isMarketSwitched) {
                this.switchFromMarketData();
                this.isMarketSwitched = false;
                this.summaryType = this.data.y.data ? "raw" : "mean";
                this.initializeDataAttributes();
                this.isGraphTime = false;
                if (this.showVolume) {
                    this.layoutComb = false
                }
            } else {
                if (this.graphType.match(/Scatter/) && this.allVsAll) {
                    this.setAllVsAll()
                } else {
                    if (this.graphType.match(/Pie/) && this.xAxis.length > 1) {
                        this.setMultiplePies()
                    }
                }
            }
        }
    };
    this.initializeGraph = function (m, a, l, g, b) {
        var d = this;
        var h = 5;
        var k = 0;
        var e = [];
        var j = function () {
            for (var n = 0; n < e.length; n++) {
                if (!CanvasXpress.cacheImages.hasOwnProperty(e[n])) {
                    return false
                }
            }
            return true
        };
        if (this.graphType == "Network") {
            e = this.getNetworkImages()
        } else {
            if (this.graphType.match(/scatter/i)) {
				for (var c = 0; c < this.images.length; c++) {
                    if (!this.images[c].match(/^http:\/\//)) {
                        this.images[c] = this.imageDir + this.images[c]
                    }
					e.push(this.images[c])
                }
            }
        }
        if (this.backgroundImage) {
            if (!this.backgroundImage.match(/^http:\/\//)) {
                this.backgroundImage = this.imageDir + this.backgroundImage
            }
            e.push(this.backgroundImage)
        }
        if (e.length > 0) {
            if (this.graphType == "Network") {
                this.Network(true)
            } else {
                if (this.graphType == "Scatter3D") {
                    this.Scatter3D(true)
                } else {
                    if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
                        this.Scatter2D(true)
                    }
                }
            }
        }
        if (e.length > 0 && !j()) {
            for (var c = 0; c < e.length; c++) {
                if (!CanvasXpress.cacheImages.hasOwnProperty(e[c])) {
                    CanvasXpress.cacheImages[e[c]] = true;
                    var f = new Image;
                    f.onload = function () {
                        CanvasXpress.cacheImages[this.src] = this;
                        if (k < (h * e.length)) {
                            if (j()) {
                                d.renderGraph(m, a, l, g, b)
                            } else {
                                k++
                            }
                        } else {
                            alert("Problem loading images")
                        }
                    };
                    f.src = e[c]
                }
            }
        } else {
            this.renderGraph(m, a, l, g, b)
        }
    };
    this.renderGraph = function (g, d, a, c, f) {
        if (this.initialRemoteDataRequest) {
            return
        }
        this.setColorScheme();
        this.reinitializeGraph();
        if ((!this.layoutComb || !this.layoutAdjust) && !c) {
            if (this.graphType != "Candlestick" || (this.graphType == "Candlestick" && !this.showVolume)) {
                this.initAxes(g)
            }
        }
        if (g) {
            this.resizeCanvas(true, d, a)
        } else {
            this.resizeCanvas(false, d, a)
        }
        if (this.isVML) {
            this.showShadow = false
        }
        if (this.isValidAnimation() && this.showAnimation && !this.isAnimation) {
            this.createAnimation(this.animationType)
        } else {
            var e = this.layoutComb ? true : false;
            switch (this.graphType) {
                case "Bar":
                case "Dotplot":
                    if (this.isBoxPlotCalc && this.isGroupedData) {
                        this.groupSamples(this.getGroupingFactors(true))
                    }
                    if (this.is3DPlot) {
                        this.Scatter3D()
                    } else {
                        this.oneDPlot()
                    }
                    break;
                case "Line":
                case "Area":
                case "AreaLine":
                case "BarLine":
                case "Heatmap":
                case "Stacked":
                case "StackedLine":
                case "StackedPercent":
                case "StackedPercentLine":
                case "Candlestick":
                    if (this.isBoxPlotCalc && this.isGroupedData) {
                        this.groupSamples(this.getGroupingFactors(true))
                    }
                    this.oneDPlot();
                    break;
                case "Boxplot":
                    if (!this.isBoxPlotCalc && this.isGroupedData) {
                        this.groupSamples(this.getGroupingFactors(true))
                    }
                    this.oneDPlot();
                    break;
                case "Scatter2D":
                case "ScatterBubble2D":
                    this.Scatter2D();
                    break;
                case "Scatter3D":
                    this.Scatter3D();
                    break;
                case "Correlation":
                    this.Correlation();
                    break;
                case "Venn":
                    this.Venn();
                    break;
                case "Pie":
                    this.Pie();
                    break;
                case "Circular":
                    this.Circular();
                    break;
                case "Network":
                    if (f) {
                        var b = this.calculateLayout;
                        var e = this.randomNetwork;
                        this.calculateLayout = false;
                        this.randomNetwork = false;
                        this.Network();
                        this.calculateLayout = b;
                        this.randomNetwork = e
                    } else {
                        this.Network()
                    }
                    break;
                case "Genome":
                    this.Genome();
                    break
            }
            this.drawCanvasBox();
            if (this.showCode) {
                this.updateCodeDiv()
            }
            if (this.showDataTable) {
                this.updateDataTable()
            } else {
                if (this.dataTableLastState && this.dataTableLastState != "docked") {
                    this.hideUnhideDataTable(true)
                }
            }
            this.setAcknowledgementVisibility();
            if (this.graphType != "Network") {
                this.drawCitation()
            }
        }
    };
    this.initializeGraph()
};
CanvasXpress.prototype.initAxes = function (b, a) {
    this.getValidAxes = function (c) {
        var d = [];
        if (this.graphType == "Scatter2D") {
            d.push("xAxis");
            d.push("yAxis")
        } else {
            if (this.graphType == "ScatterBubble2D" || this.graphType == "Scatter3D") {
                d.push("xAxis");
                d.push("yAxis");
                d.push("zAxis")
            } else {
                if (this.graphType.match(/Network|Genome|Correlation|Venn|Heatmap|Pie/)) {
                    if (c) {
                        d.push("xAxis")
                    } else {
                        return false
                    }
                } else {
                    if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) || (this.graphType == "Candlestick" && this.showVolume)) {
                        d.push("xAxis");
                        d.push("xAxis2")
                    } else {
                        if (this.graphType == "Circular") {
                            d.push("xAxis");
                            d.push("rAxis")
                        } else {
                            d.push("xAxis")
                        }
                    }
                }
            }
        }
        return d
    };
    this.addRemoveSamplesInAxis = function (e, d, c) {
        if (this.graphType == "Scatter2D" || this.graphType == "ScatterBubble2D") {
            if (c) {
                return this.removeSamplesFromAxis(e, d)
            } else {
                return this.addSamplesToAxis(e, d)
            }
        } else {
            if (this.graphType == "Scatter3D" || this.graphType == "Pie") {
                return this.switchSampleInAxis(e, d)
            }
        }
    };
    this.addSamplesToAxis = function (e, d) {
        if (this[d]) {
            if (this.isArray(e)) {
                for (var c = 0; c < e.length; c++) {
                    this[d].push(e[c])
                }
            } else {
                this[d].push(e)
            }
            return false
        } else {
            return "Not a valid axis"
        }
    };
    this.removeSamplesFromAxis = function (g, f) {
        if (this[f]) {
            if (this[f].length > 1) {
                var d = {};
                var c = [];
                if (this.isArray(g)) {
                    for (var e = 0; e < g.length; e++) {
                        d[g[e]] = 1
                    }
                } else {
                    d[g] = 1
                }
                for (var e = 0; e < this[f].length; e++) {
                    if (!d.hasOwnProperty(this[f][e])) {
                        c.push(this[f][e])
                    }
                }
                this[f] = c;
                return false
            } else {
                return f + " cannot be null"
            }
        } else {
            return "Not a valid axis"
        }
    };
    this.switchSampleInAxis = function (d, c) {
        if (this[c]) {
            this[c][0] = d;
            return false
        } else {
            return "Not a valid axis"
        }
    };
    this.addRemoveVariablesInAxis = function (e, d, c) {
        if (c) {
            return this.removeVariablesFromAxis(e, d)
        } else {
            return this.addVariablesToAxis(e, d)
        }
    };
    this.addVariablesToAxis = function (e, d) {
        if (!this.data.a) {
            this.data.a = {}
        }
        if (!this.data.a[d]) {
            this.data.a[d] = []
        }
        if (this.isArray(e)) {
            for (var c = 0; c < e.length; c++) {
                this.data.a[d].push(e[c])
            }
        } else {
            this.data.a[d].push(e)
        }
        this.resetVariablesVisibleByAxis(d);
        return false
    };
    this.removeVariablesFromAxis = function (g, f) {
        if (this.data.a && this.data.a[f]) {
            var d = {};
            var c = [];
            if (this.isArray(g)) {
                for (var e = 0; e < g.length; e++) {
                    d[g[e]] = 1
                }
            } else {
                d[g] = 1
            }
            for (var e = 0; e < this.data.a[f].length; e++) {
                if (!d.hasOwnProperty(this.data.a[f][e])) {
                    c.push(this.data.a[f][e])
                }
            }
            this.data.a[f] = c
        }
        this.resetVariablesVisibleByAxis(f);
        return false
    };
    this.formatAxisValue = function (d, c) {
        if (this[c + "TickFormat"]) {
            if (this.graphType == "Candlestick" && this.summaryType == "volume") {
                if (this.xAxis2TickFormat) {
                    return sprintf(this.xAxis2TickFormat, d)
                } else {
                    return sprintf(this[c + "TickFormat"], d)
                }
            } else {
                return sprintf(this[c + "TickFormat"], d)
            }
        } else {
            return this.graphType == "Candlestick" && this.summaryType == "volume" ? sprintf("%." + this.xAxis2Decs + "f", d) : sprintf("%." + this[c + "Decs"] + "f", d)
        }
    };
    this.getAxisRangeBySample = function (c) {
        var g = [];
        if (this.isArray(c)) {
            for (var e = 0; e < this.varIndices.length; e++) {
                var f = this.varIndices[e];
                for (var d = 0; d < c.length; d++) {
                    g.push(this.getDataAtPos(f, d))
                }
            }
        } else {
            for (var e = 0; e < this.varIndices.length; e++) {
                var f = this.varIndices[e];
                g.push(this.getDataAtPos(f, c))
            }
        }
        return this.range(g)
    };
    this.getAxisIncrements = function (f, n, o, j, p) {
        if (n - f <= Number.MIN_VALUE) {
            return 0.1
        }
        var l;
        var m = ((p || n) - f) * this.axisExtension;
        var d = f - m;
        var h = (p || n) + m;
        var i = h - d;
        var k = -Math.floor(Math.log(i / o) / Math.LN10);
        var e = Math.pow(10, - k);
        var g = this.getAxisDecimals(e);
        var c = ((i / o) / e);
        if (j) {
            l = parseFloat(this.formatNumber(((p || n) - f) / o, g))
        } else {
            if (c < 1.5) {
                l = e
            } else {
                if (c < 2) {
                    l = e * 2
                } else {
                    if (c < 2.5) {
                        l = e * 2.5
                    } else {
                        if (c < 5) {
                            l = e * 5
                        } else {
                            if (c < 7.5) {
                                l = e * 7.5
                            } else {
                                l = e * 10
                            }
                        }
                    }
                }
            }
        }
        if (this.getAxisMin(f, l) + (l * o) < n) {
            return this.getAxisIncrements(f, n, o, j, (p || n) + l)
        } else {
            return l
        }
    };
    this.getAxisMin = function (c, d) {
        var e = d * Math.floor(c / d);
        return e < 0 && this.minData >= 0 ? 0 : e
    };
    this.getAxisDecimals = function (d) {
        var c = 1000000;
        var e = (((d * c) - (parseInt(d) * c)) / c).toString().replace(/\./, "").length - 1;
        return e
    };
    this.setAxis = function (c) {
        var d = this.isGroupedData ? this.data.w : this.data.y;
        if (this[c].length == 0) {
            if (c == "xAxis") {
                this[c].push(d.smps[this.smpIndices[0]])
            } else {
                if (c == "yAxis") {
                    if (d.smps.length > 1) {
                        this[c].push(d.smps[this.smpIndices[1]])
                    } else {
                        this[c].push(d.smps[this.smpIndices[0]])
                    }
                } else {
                    if (c == "zAxis") {
                        if (d.smps.length > 2) {
                            this[c].push(d.smps[this.smpIndices[2]])
                        } else {
                            if (d.smps.length > 1) {
                                this[c].push(d.smps[this.smpIndices[1]])
                            } else {
                                this[c].push(d.smps[this.smpIndices[0]])
                            }
                        }
                    }
                }
            }
        } else {
            if (this.graphType == "Scatter3D" && this[c].length > 1) {
                this[c] = [this[c][0]]
            }
        }
    };
    this.setAxisValues = function (e) {
        var z, p, m, n, o, x, k, f;
        var d = {};
        var h = e + "MinorValues";
        var l = e + "Values";
        var v = e + "Ticks";
        var w = e + "TickFormat";
        var u = e + "Incr";
        var c = e + "Decs";
        var q = e + "Min";
        var g = e + "Transform";
        var t = e + "MaxStrLength";
        if (this[g] == "percentile") {
            this[c] = 0;
            this[l] = [];
            this[h] = [];
            var y = [0, 25, 50, 75, 100];
            for (var s = 0; s < y.length; s++) {
                this[l].push(y[s])
            }
            for (var s = 5; s < 100; s += 5) {
                this[h].push(s)
            }
        } else {
            if (this[l].length == 0 || b) {
                if (b) {
                    this[l] = [];
                    this[h] = []
                }
                z = this[q];
                o = this[u] / this[v];
                for (var s = 1; s <= this[v]; s++) {
                    for (var r = 1; r < this[v]; r++) {
                        this[h].push(z + (o * r))
                    }
                    z += this[u];
                    if (this[c] == 0 && z.toString().match(/\.5$/)) {
                        this[c] = 1
                    }
                    if (this[w]) {
                        p = sprintf(this[w], z)
                    } else {
                        p = this.formatNumber(sprintf("%." + this[c] + "f", z), this[c])
                    }
                    if (d.hasOwnProperty(p) && !this[w]) {
                        k = true
                    } else {
                        d[p] = 1
                    }
                    this[l].push(p)
                }
            } else {
                m = this[l];
                this[l] = [];
                for (var s = 0; s < m.length; s++) {
                    z = m[s];
                    n = parseFloat(z);
                    if (this[w]) {
                        p = sprintf(this[w], n)
                    } else {
                        p = this.formatNumber(sprintf("%." + this[c] + "f", n), this[c])
                    }
                    if (d.hasOwnProperty(p) && !this[w]) {
                        k = true
                    } else {
                        d[p] = 1
                    }
                    this[l].push(p)
                }
            }
        }
        if (k) {
            this[c]++;
            this[l] = [];
            this[h] = [];
            this.setAxisValues(e)
        } else {
            f = this.getMaxText(this[l]);
            if (!this[t]) {
                this[t] = f
            } else {
                this[t] = this.getMaxText([this[t], f])
            }
        }
    };
    this.setAxisAttributes = function (h, o, r, e, n) {
	
	var q = e && e.match(/log/) ? true : false;
        var l = h + "Ticks";
        var d = h + "Incr";
        var g = h + "Exact";
        var c = h + "AbsMin";
        var k = h + "AbsMax";
        var i = h + "Min";
        var p = h + "Max";
        var m = h + "Range";
        var j = h + "Decs";
        var f = h + "Transform";
        this.setRangeData(o, r, q, n);
        if (e) {
            if (e == "log2") {
                this.minData = Math.log(this.minData) / Math.LN2;
                this.maxData = Math.log(this.maxData) / Math.LN2
            } else {
                if (e == "log10") {
                    this.minData = Math.log(this.minData) / Math.LN10;
                    this.maxData = Math.log(this.maxData) / Math.LN10
                } else {
                    if (e == "exp2") {
                        this.minData = Math.pow(2, this.minData);
                        this.maxData = Math.pow(2, this.maxData)
                    } else {
                        if (e == "exp10") {
                            this.minData = Math.pow(10, this.minData);
                            this.maxData = Math.pow(10, this.maxData)
                        } else {
                            if (e == "percentile") {
                                this.minData = -12.5;
                                this.maxData = 112.5
                            }
                        }
                    }
                }
            }
        }
        this[c] = this.setMin == null ? this.minData : this[c];
        this[k] = this.setMax == null ? this.maxData : this[k];
        this[d] = this.getAxisIncrements(this.minData, this.maxData, this[l], this[g]);
        this[j] = this.getAxisDecimals(this[d]);
        if (n) {
            this[i] = 0;
            if (this.graphType.match(/Percent/)) {
                this[p] = 100
            } else {
                this[p] = this[i] + (this[d] * this[l])
            }
        } else {
            if (this[g] || (e && e == "percentile")) {
                this[i] = this.minData;
                this[p] = this.maxData
            } else {
                this[i] = this.getAxisMin(this.minData, this[d]);
                this[p] = this[i] + (this[d] * this[l]);
                if (this[p] - (this[d] * 2) > this.maxData) {
                    if (this[i] - this[d] > 0) {
                        this[i] -= this[d];
                        this[p] -= this[d]
                    }
                    if (this.minData > 0 && this[i] < 0) {
                        this[i] += this[d];
                        this[p] += this[d]
                    }
                }
            }
        }
        this[m] = this[p] - this[i];
        this.setAxisValues(h)
    };
    this.setAxes = function (d) {
        if (this.graphType.match(/Correlation/)) {
            var c = this.isGroupedData ? this.data.w : this.data.y;
            this.setMin = null;
            this.setMax = null;
            if (this.correlationAnchorLegend) {
                this.setAxisAttributes("xAxis")
            }
            if (!c.cor || c.cor.length == 0) {
                this.summarize("cor");
                this.setRangeData("cor")
            }
            if (!this.yAxisTitle) {
                this.yAxisTitle = "Correlation"
            }
        } else {
            if (this.graphType.match(/Scatter|Pie/)) {
                var g = this.smpIndices;
                var q = ["xAxis"];
                var l = ["X"];
                this.setMin = null;
                this.setMax = null;
                if (this.graphType.match(/Scatter/)) {
                    q.push("yAxis");
                    l.push("Y")
                }
                if (this.graphType.match(/ScatterBubble2D|Scatter3D/)) {
                    q.push("zAxis");
                    l.push("Z")
                }
                if (this.graphType == "Scatter3D") {
                    this.xAxisTicks = 10;
                    this.yAxisTicks = 10;
                    this.zAxisTicks = 10
                }
                for (var r = 0; r < q.length; r++) {
                    var v = q[r] + "Indices";
                    var o = "setMin" + l[r];
                    var p = "setMax" + l[r];
                    this.setAxis(q[r]);
                    this[v] = this.getSampleIndices(this[q[r]]);
                    this.setSamplesVisible(this[v]);
                    if (this[o]) {
                        this.setMin = this[o]
                    }
                    if (this[p]) {
                        this.setMax = this[p]
                    }
                    this.setAxisAttributes(q[r], r > 0 ? d : false, false, this[q[r] + "Transform"]);
                    this.setSamplesVisible(g)
                }
                if (!this.xAxisTitle) {
                    this.xAxisTitle = this.xAxis.length == 1 ? this.xAxis[0] : " "
                }
                if (!this.yAxisTitle) {
                    this.yAxisTitle = this.yAxis.length == 1 ? this.yAxis[0] : " "
                }
                if (!this.zAxisTitle) {
                    this.zAxisTitle = this.zAxis.length == 1 ? this.zAxis[0] : " "
                }
            } else {
                if (this.graphType.match(/Genome/)) {
                    var s = this.setMin;
                    var u = this.setMax;
                    this.setRangeData("genome");
                    this.xAxisExact = true;
                    this.xAxisTransform = false;
                    this.xAxisAbsMin = this.minData;
                    this.xAxisAbsMax = this.maxData;
                    if (s != null) {
                        this.setMin = s
                    }
                    if (u != null) {
                        this.setMax = u
                    }
                    this.xAxisMin = this.setMin != null ? this.setMin : this.minData - 1;
                    this.xAxisMax = this.setMax != null ? this.setMax : this.maxData + 1;
                    this.xAxisDecs = 0;
                    this.xAxisRange = this.xAxisMax - this.xAxisMin;
                    this.xAxisTicks = this.ticks;
                    this.xAxisIncr = this.xAxisRange / this.xAxisTicks;
                    this.setAxisValues("xAxis")
                } else {
                    var j = this.smpIndices;
                    var n = this.varIndices;
                    var k = this.grpIndices;
                    var f = this.varIndices;
                    var h = this.graphType == "Dotplot" && this.isGroupedData ? true : false;
                    var m = this.graphType.match(/Percent/) ? "percentile" : false;
                    var t = this.graphType.match(/Stacked/) || (this.graphType.match(/Area/) && this.areaIsCumulative) ? true : false;
                    var e = this.graphType == "Candlestick" ? "candle" : m ? m : false;
                    if (this.varIndicesStart > -1 || this.smpIndicesStart > -1) {
                        this.setAllVariablesVisible();
                        this.setAllSamplesVisible();
                        if (this.graphType == "Heatmap") {
                            this.graphOrientation = "horizontal"
                        }
                    } else {
                        if (this.graphType == "StackedPercent" || this.graphType == "StackedPercentLine") {
                            this.setMin = null;
                            this.setMax = null;
                            this.axisExact = true;
                            this.xAxisExact = true
                        } else {
                            if (this.graphType == "Boxplot" && !this.isGroupedData) {
                                if (!this.data.y.median) {
                                    this.summarize("iqr")
                                }
                            }
                        }
                    }
                    if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) {
                        this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis"))
                    }
                    this.setAxisAttributes("xAxis", e, h, m, t);
                    this["xAxisTitle"] = !this["xAxisTitle"] && this.data.y.desc ? this.data.y.desc[0] : "";
                    if ((this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/) && this.data.a) || (this.graphType == "Candlestick" && this.showVolume)) {
                        e = this.graphType == "Candlestick" ? "volume" : false;
                        if (this.graphType.match(/BarLine|AreaLine|StackedLine|StackedPercentLine/)) {
                            this.setVariablesVisible(f);
                            this.setVariablesVisible(this.getVariablesVisibleByAxis("xAxis2"))
                        }
                        var p = this.setMax != null ? this.setMax : null;
                        var o = this.setMin != null ? this.setMin : null;
                        this.setMax = this.setMax2 != null ? this.setMax2 : null;
                        this.setMin = this.setMin2 != null ? this.setMin2 : null;
                        this.setAxisAttributes("xAxis2", e, h);
                        this["xAxis2Title"] = !this["xAxis2Title"] && this.data.y.desc ? this.data.y.desc[1] : "";
                        this.setMax = p != null ? p : null;
                        this.setMin = o != null ? o : null
                    }
                    if (this.graphType == "Circular" && this.rAxis) {
                        this.setAxisAttributes("rAxis", "circular", h, m, false, true)
                    }
                    this.setVariablesVisible(f);
                    this.smpIndices = j;
                    this.varIndices = n;
                    this.grpIndices = k
                }
            }
        }
    };
    this.setScatterPointSize = function () {
        this.scatterPointSize = this.varIndices.length > 50 ? this.sizes[1] : this.varIndices.length > 20 ? this.sizes[2] : this.sizes[3];
        if (this.layoutComb) {
            this.scatterPointSize = Math.ceil(this.scatterPointSize / this.layoutRows)
        }
    };
    this.setAxisUnits = function (e, g) {
        var f = e + "Unit";
        var d = e + "Range";
        var c = g ? g : e.substring(0, 1);
        this[f] = this[c] / this[d]
    };
    this.setAxisFont = function (h, g) {
        var f = this.graphType == "Venn" ? 16 : 12;
        if (this.autoScaleFont || !this.axisTickFont || !this.decorationFont || !this.axisTitleFont) {
            var c, e, d;
            if (g >= 600) {
                c = 12 * this.tickScaleFontFactor;
                d = 10 * this.decorationScaleFontFactor;
                e = this.getFontPt(this.scaleTextToFont(h, f, g - 2)) * this.axisTitleScaleFontFactor
            } else {
                if (g >= 400) {
                    c = 10 * this.tickScaleFontFactor;
                    d = 8 * this.decorationScaleFontFactor;
                    e = this.getFontPt(this.scaleTextToFont(h, f, g - 2)) * this.axisTitleScaleFontFactor
                } else {
                    if (g >= 200) {
                        c = 8 * this.tickScaleFontFactor;
                        d = 6 * this.decorationScaleFontFactor;
                        e = 8 * this.axisTitleScaleFontFactor
                    } else {
                        if (g >= 100) {
                            c = 6 * this.tickScaleFontFactor;
                            d = 4 * this.decorationScaleFontFactor;
                            e = 6 * this.axisTitleScaleFontFactor
                        } else {
                            c = 4 * this.tickScaleFontFactor;
                            d = 2 * this.decorationScaleFontFactor;
                            e = 4 * this.axisTitleScaleFontFactor
                        }
                    }
                }
            }
            this.axisTickFont = (parseInt(c)) + "Pt " + this.fontName;
            this.decorationFont = (parseInt(d)) + "Pt " + this.fontName;
            this.axisTitleFont = (parseInt(e)) + "Pt " + this.fontName
        } else {
            this.axisTickFont = parseInt(this.axisTickFontSize) + "Pt " + this.fontName;
            this.decorationFont = parseInt(this.decorationFontSize) + "Pt " + this.fontName;
            this.axisTitleFont = parseInt(this.axisTitleFontSize) + "Pt " + this.fontName
        }
    };
    this.getAxisFont = function (c) {
        if (c >= 600) {
            return 12
        } else {
            if (c >= 400) {
                return 10
            } else {
                if (c >= 200) {
                    return 8
                } else {
                    return 6
                }
            }
        }
    };
    this.getHeatmapShades = function (d, c) {
        switch (d) {
            case "white":
            case "black":
                if (c && c != "white" && c != "black") {
                    return this.getHeatmapShades(c)
                } else {
                    return this.greys
                }
            case "grey":
                return this.greys;
            case "green":
                return this.greens;
            case "red":
                return this.reds;
            case "blue":
                return this.blues;
            case "yellow":
                return this.yellows;
            case "cyan":
                return this.cyans;
            case "purple":
                return this.purples
        }
    };
    this.setHeatmapColors = function (c) {
        this.setRGB();
        var k = c ? c : this.maxData - this.minData;
        var d = this.heatmapType.split("-");
        var m = 256 / this.indicatorBins;
        var l = this.getHeatmapShades(d[0], d[1]);
        this.heatmapColors = [];
        this.heatmapBin = (k ? k : 1) / this.indicatorBins;
        if (this.indicatorCenter.match("rainbow") && d.length > 1) {
            var e = ["red", "purple", "blue", "cyan", "green", "yellow"];
            if (this.indicatorCenter == "rainbow-green") {
                e.reverse()
            }
            var n = null;
            for (var h = 0; h < e.length; h++) {
                if (e[h] == d[0]) {
                    n = h
                }
            }
            if (n == null) {
                alert("Dude! " + d[0] + " ain't a valid color ... This is not looking good ...");
                this.heatmapColors = this.blues;
                return
            }
            var f = [e[n]];
            n++;
            while (f.length < 6) {
                if (n > 5) {
                    n = 0
                }
                f.push(e[n]);
                n++
            }
            n = null;
            for (var h = 0; h < f.length; h++) {
                if (f[h] == d[1]) {
                    n = h
                }
            }
            if (n == null) {
                alert("Dude! " + d[1] + " ain't a valid color ... This is not looking good ...");
                this.heatmapColors = this.blues;
                return
            }
            for (var h = 0; h < n; h++) {
                l = this.getHeatmapShades(f[h]);
                for (var g = 0; g < m; g++) {
                    this.heatmapColors.push(l[g])
                }
            }
        } else {
            if (d.length > 1) {
                if ((d[0] == "white" && d[1] != "black") || (d[0] == "black" && d[1] != "white")) {
                    this.heatmapType = d[1];
                    this.setHeatmapColors(c)
                } else {
                    if (d[1] == "white") {
                        if (d[0] == "black") {
                            this.heatmapColors.push("rgb(0,0,0)");
                            for (var h = m - 1; h >= 0; h--) {
                                this.heatmapColors.push(l[h]);
                                this.heatmapColors.push(l[h])
                            }
                        } else {
                            for (var h = 0; h < m; h++) {
                                this.heatmapColors.push(l[h]);
                                this.heatmapColors.push(l[h])
                            }
                            this.heatmapColors.push("rgb(255,255,255)")
                        }
                    } else {
                        if (d[1] == "black") {
                            if (d[0] == "white") {
                                this.heatmapColors.push("rgb(255,255,255)");
                                for (var h = 0; h < m; h++) {
                                    this.heatmapColors.push(l[h]);
                                    this.heatmapColors.push(l[h])
                                }
                            } else {
                                for (var h = 0; h < m; h++) {
                                    this.heatmapColors.push(l[h]);
                                    this.heatmapColors.push(l[h])
                                }
                                this.heatmapColors.push("rgb(0,0,0)")
                            }
                        } else {
                            for (var h = 0; h < m; h++) {
                                this.heatmapColors.push(l[h])
                            }
                            if (this.indicatorCenter == "black") {
                                this.heatmapColors.push("rgb(0,0,0)")
                            } else {
                                this.heatmapColors.push("rgb(255,255,255)")
                            }
                            l = this.getHeatmapShades(d[1]);
                            for (var h = m - 1; h >= 0; h--) {
                                this.heatmapColors.push(l[h])
                            }
                        }
                    }
                }
            } else {
                if (this.indicatorCenter == "black" && color[0] != "grey") {
                    this.heatmapColors.push("rgb(0,0,0)")
                } else {
                    this.heatmapColors.push("rgb(255,255,255)")
                }
                for (var h = m - 1; h >= 0; h--) {
                    this.heatmapColors.push(l[h]);
                    this.heatmapColors.push(l[h])
                }
            }
        }
    };
    this.initializeAxis = function () {
        if (!this.graphType.match(/Venn|Network/)) {
            if (!a) {
                this.setAxes();
                this.setHeatmapColors()
            }
        }
    };
    this.initializeAxis()
};
CanvasXpress.prototype.Scatter3D = function (a) {
    this.set3DText = function () {
        this.setAxisFont(false, this.x)
    };
    this.equalizeMargins = function () {
        var b = Math.max(this.marginLeft, Math.max(this.marginRight, Math.max(this.marginTop, this.marginBottom)));
        this.marginLeft = b;
        this.marginRight = b;
        this.marginTop = b;
        this.marginBottom = b
    };
    this.set3DXYDimensions = function () {
        this.equalizeMargins();
        if (this.tmpHeight) {
            this.height = this.tmpHeight
        }
        if (this.tmpWidth) {
            this.width = this.tmpWidth
        }
        var b = Math.min(this.height, this.width) - 40;
        this.tmpHeight = this.height;
        this.tmpWidth = this.width;
        this.height = b;
        this.width = b;
        this.x = this.width - (this.marginTop + this.top);
        this.y = this.height - (this.marginTop + this.top);
        this.left = this.top;
        if (this.showLegend || this.showIndicators) {
            this.setLegendDimensions();
            var b = Math.max(this.legendWidth, this.legendHeight) / 2;
            this.x -= b;
            this.y -= b;
            this.width = this.x + this.legendWidth + this.marginLeft + this.marginRight;
            this.height = this.y + this.legendHeight + this.marginTop + this.marginBottom
        }
        this.resizeCanvas();
        this.resizeViewport();
        this.setScatterPointSize()
    };
    this.draw3DLayout = function (j, b, o, k, c, p, g, d) {
		var f, r, e, q, n;
        var h = this.marginLeft + this.offsetX + this.left;
        var s = this.marginTop + this.offsetY + this.top;
        for (var m = 0; m < j.length; m++) {
            n = this.get3DTransfrom(j[m], b[m], o[m]);
            f = n[0] + h;
            r = n[1] + s;
            n = this.get3DTransfrom(k[m], c[m], p[m]);
            e = n[0] + h;
            q = n[1] + s;
            if (d == "dotted") {
                this.drawLine("dottedLine", f, r, e, q, g[m], false, "butt")
            } else {
                this.drawLine("line", f, r, e, q, g[m], false, "butt")
            }
        }
    };
    this.draw3DBar = function (q, o, n, v, Q, S) {
        var I = this.marginLeft + this.offsetX + this.left;
        var E = this.marginTop + this.offsetY + this.top;
        var k = I + (this.x / 2);
        var g = E + (this.y / 2);
        var M = v / 2;
        var N = [
            [
                [q - v, o, n - v],
                [q + v, o, n - v],
                [q + v, M, n - v],
                [q - v, M, n - v]
            ],
            [
                [q + v, o, n - v],
                [q + v, o, n + v],
                [q + v, M, n + v],
                [q + v, M, n - v]
            ],
            [
                [q - v, o, n + v],
                [q + v, o, n + v],
                [q + v, M, n + v],
                [q - v, M, n + v]
            ],
            [
                [q - v, o, n - v],
                [q - v, o, n + v],
                [q - v, M, n + v],
                [q - v, M, n - v]
            ],
            [
                [q - v, o, n - v],
                [q + v, o, n - v],
                [q + v, o, n + v],
                [q - v, o, n + v]
            ]
        ];
        var P = [];
        var R = [];
        var O = [];
        var H = [];
        for (var L = 0; L < N.length; L++) {
            P[L] = [];
            for (var K = 0; K < N[L].length; K++) {
                var G = this.xAxisMin < 0 ? 0 : this.xAxisMin;
                var D = this.yAxisMin < 0 ? 0 : this.yAxisMin;
                var C = this.zAxisMin < 0 ? 0 : this.zAxisMin;
                var A = ((N[L][K][0] - G) * this.xAxisUnit) - this.xAxisOffset;
                var u = this.yAxisOffset - ((N[L][K][1] - D) * this.yAxisUnit);
                var p = ((N[L][K][2] - C) * this.zAxisUnit) - this.zAxisOffset;
                P[L].push(this.get3DTransfrom(A, u, p))
            }
            H.push(L);
            O.push(this.euclidianDistance([(P[L][0][0] + P[L][2][0]) / 2, (P[L][0][1] + P[L][2][1]) / 2, (P[L][0][2] + P[L][2][2]) / 2], [this.zero3DPoint[0], this.zero3DPoint[1], - this.x]))
        }
        H.sort(function (d, c) {
            return O[c] - O[d]
        });
        for (var B = 1; B < P.length; B++) {
            var L = H[B];
            var F = B < 3 ? this.darkenLightenColor(Q, - B * 30) : Q;
            var m = [];
            var J = [];
            for (var K = 0; K < P[L].length; K++) {
                m.push(P[L][K][0] + I);
                J.push(P[L][K][1] + E)
            }
            this.addArea(this.drawShape("polygon", m, J, false, false, F, this.foreground, "closed"), S)
        }
    };
    this.set3DXLayout = function () {
        var z = [],
            d = [],
            n = [],
            w = [],
            c = [],
            k = [],
            e = [];
        var v, m, p, b, A, r, j, h;
        var f = this.lenX / 15;
        var q = (15 * -f) + f;
        var g = this.xAxisTitle ? this.xAxisTitle : this.is3DPlot ? "Samples" : this.data.y.smps[this.xAxisIndex];
        var u = this.marginLeft + this.offsetX + this.left;
        var o = this.marginTop + this.offsetY + this.top;
        if (this.show3DGrid) {
            p = q;
            v = 0;
            m = 0;
            while (p < this.lenX) {
                if ((v + 1) % 3) {
                    if (!this.is3DPlot) {
                        z[m] = p;
                        d[m] = -this.lenY;
                        n[m] = this.lenZ;
                        w[m] = p;
                        c[m] = this.lenY;
                        k[m] = this.lenZ;
                        e.push(this.xAxisTickColor);
                        m++
                    }
                    z[m] = -this.lenX;
                    d[m] = p * this.lenY / this.lenX;
                    n[m] = this.lenZ;
                    w[m] = this.lenX;
                    c[m] = p * this.lenY / this.lenX;
                    k[m] = this.lenZ;
                    e.push(this.xAxisTickColor);
                    m++
                }
                p += f;
                v++
            }
            this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle);
            z = [], d = [], n = [], w = [], c = [], k = [], e = [];
            p = q;
            v = 0;
            m = 0;
            A = this.xAxisIncr;
            while (p < this.lenX) {
                if (!((v + 1) % 3)) {
                    if (!this.is3DPlot) {
                        z[m] = p;
                        d[m] = -this.lenY;
                        n[m] = this.lenZ;
                        w[m] = p;
                        c[m] = this.lenY;
                        k[m] = this.lenZ;
                        e.push(this.foreground);
                        m++
                    }
                    z[m] = -this.lenX;
                    d[m] = p * this.lenY / this.lenX;
                    n[m] = this.lenZ;
                    w[m] = this.lenX;
                    c[m] = p * this.lenY / this.lenX;
                    k[m] = this.lenZ;
                    e.push(this.foreground);
                    b = this.get3DTransfrom(p, this.lenY, - this.lenZ);
                    j = b[0] + u;
                    h = b[1] + o;
                    r = this.formatAxisValue(this.xAxisMin + A, "xAxis");
                    A += this.xAxisIncr;
                    if (this.xAxisShow && !this.is3DPlot) {
                        this.drawText(r, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, - Math.PI / 2)
                    }
                    m++
                }
                p += f;
                v++
            }
            this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
        }
        if (this.xAxisShow && !this.is3DPlot) {
            this.draw3DAxisTitle(q - (f * 2), this.lenX + f, this.lenY + (f * 4), this.lenY + (f * 4), - this.lenZ - (f * 4), - this.lenZ - (f * 4), g, "x")
        }
        z = [-this.lenX, - this.lenX, this.lenX, - this.lenX];
        d = [-this.lenY, - this.lenY, - this.lenY, this.lenY];
        n = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
        w = [-this.lenX, this.lenX, this.lenX, this.lenX];
        c = [this.lenY, - this.lenY, this.lenY, this.lenY];
        k = [this.lenZ, this.lenZ, this.lenZ, this.lenZ];
        e = [this.foreground, this.foreground, this.foreground, this.foreground];
        this.draw3DLayout(z, d, n, w, c, k, e, this.xAxisTickStyle)
    };
    this.set3DYLayout = function () {
        var B = [],
            d = [],
            n = [],
            A = [],
            c = [],
            k = [],
            e = [];
        var w, m, q, b, C, u, j, h;
        var f = this.lenY / 15;
        var z = this.yAxisLen / 30;
        var r = (15 * -f) + f;
        var g = this.yAxisTitle ? this.yAxisTitle : this.is3DPlot ? "Value" : this.data.y.smps[this.yAxisIndex];
        var v = this.marginLeft + this.offsetX + this.left;
        var o = this.marginTop + this.offsetY + this.top;
        var p = [];
        if (this.show3DGrid) {
            q = r;
            w = 0;
            m = 0;
            while (q < this.lenY) {
                if ((w + 1) % 3) {
                    if (!this.is3DPlot) {
                        B[m] = -this.lenX;
                        d[m] = -this.lenY;
                        n[m] = q * this.lenZ / this.lenY;
                        A[m] = -this.lenX;
                        c[m] = this.lenY;
                        k[m] = q * this.lenZ / this.lenY;
                        e.push(this.yAxisTickColor);
                        m++
                    }
                    B[m] = -this.lenX;
                    d[m] = q;
                    n[m] = -this.lenZ;
                    A[m] = -this.lenX;
                    c[m] = q;
                    k[m] = this.lenZ;
                    e.push(this.yAxisTickColor);
                    m++
                }
                q += f;
                w++
            }
            this.draw3DLayout(B, d, n, A, c, k, e, this.yAxisTickStyle);
            B = [], d = [], n = [], A = [], c = [], k = [], e = [];
            q = r;
            w = 0;
            m = 0;
            C = this.is3DPlot ? this.yAxisIncr * this.xAxisTicks * 9 / 10 : this.yAxisIncr * 9;
            while (q < this.lenY) {
                if (!((w + 1) % 3)) {
                    if (!this.is3DPlot) {
                        B[m] = -this.lenX;
                        d[m] = -this.lenY;
                        n[m] = q * this.lenZ / this.lenY;
                        A[m] = -this.lenX;
                        c[m] = this.lenY;
                        k[m] = q * this.lenZ / this.lenY;
                        e.push(this.foreground);
                        m++
                    }
                    B[m] = -this.lenX;
                    d[m] = q;
                    n[m] = -this.lenZ;
                    A[m] = -this.lenX;
                    c[m] = q;
                    k[m] = this.lenZ;
                    e.push(this.foreground);
                    b = this.get3DTransfrom(-this.lenX, q, - this.lenZ);
                    j = b[0] + v;
                    h = b[1] + o;
                    u = this.formatAxisValue(this.yAxisMin + C, "yAxis");
                    C -= this.is3DPlot ? this.yAxisIncr * this.xAxisTicks / 10 : this.yAxisIncr;
                    if (this.yAxisShow) {
                        if (this.yRotate >= 45 && this.xRotate >= 45) {
                            this.drawText(u, j, h + 5, this.axisTickFont, this.axisTickColor, "right", false, - Math.PI / 2)
                        } else {
                            this.drawText(u, j - 5, h, this.axisTickFont, this.axisTickColor, "right")
                        }
                    }
                    m++
                }
                q += f;
                w++
            }
            this.draw3DLayout(B, d, n, A, c, k, e, this.yAxisTickStyle)
        }
        if (this.yAxisShow) {
            this.draw3DAxisTitle(-this.lenX - (f * 4), - this.lenX - (f * 4), r - (f * 2), this.lenY + f, - this.lenZ - (f * 4), - this.lenZ - (f * 4), g, "y")
        }
        B = [-this.lenX, - this.lenX, - this.lenX, - this.lenX];
        d = [-this.lenY, - this.lenY, - this.lenY, this.lenY];
        n = [-this.lenZ, this.lenZ, this.lenZ, this.lenZ];
        A = [-this.lenX, - this.lenX, - this.lenX, - this.lenX];
        c = [this.lenY, - this.lenY, this.lenY, this.lenY];
        k = [-this.lenZ, - this.lenZ, this.lenZ, - this.lenZ];
        e = [this.foreground, this.foreground, this.foreground, this.foreground];
        this.draw3DLayout(B, d, n, A, c, k, e, this.yAxisTickStyle)
    };
    this.set3DZLayout = function () {
        var F = [],
            d = [],
            q = [],
            E = [],
            c = [],
            n = [],
            f = [];
        var C, o, v, p, b, H, A, m, k;
        var g = this.is3DPlot ? this.lenZ / (this.varIndices.length * 0.5) : this.lenZ / 15;
        var e = this.is3DPlot ? this.lenZ / (this.smpIndices.length * 0.5) : false;
        var z = this.is3DPlot ? ((this.varIndices.length * 0.5) * -g) + g : (15 * -g) + g;
        var w = this.is3DPlot ? ((this.smpIndices.length * 0.5) * -e) + e : false;
        var j = this.zAxisTitle ? this.zAxisTitle : this.is3DPlot ? "Variables" : this.data.y.smps[this.zAxisIndex];
        var B = this.marginLeft + this.offsetX + this.left;
        var r = this.marginTop + this.offsetY + this.top;
        if (this.show3DGrid && !this.is3DPlot) {
            v = z;
            C = 0;
            o = 0;
            while (v < this.lenZ) {
                if ((C + 1) % 3) {
                    F[o] = -this.lenX;
                    d[o] = this.lenY;
                    q[o] = v;
                    E[o] = this.lenX;
                    c[o] = this.lenY;
                    n[o] = v;
                    f.push(this.zAxisTickColor);
                    o++;
                    F[o] = v * this.lenX / this.lenZ;
                    d[o] = this.lenY;
                    q[o] = -this.lenZ;
                    E[o] = v * this.lenX / this.lenZ;
                    c[o] = this.lenY;
                    n[o] = this.lenZ;
                    f.push(this.zAxisTickColor);
                    o++
                }
                v += g;
                C++
            }
            this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle);
            F = [], d = [], q = [], E = [], c = [], n = [], f = [];
            v = z;
            C = 0;
            o = 0;
            H = this.zAxisIncr;
            while (v < this.lenZ) {
                if (!((C + 1) % 3)) {
                    F[o] = -this.lenX;
                    d[o] = this.lenY;
                    q[o] = v;
                    E[o] = this.lenX;
                    c[o] = this.lenY;
                    n[o] = v;
                    f.push(this.foreground);
                    o++;
                    F[o] = v * this.lenX / this.lenZ;
                    d[o] = this.lenY;
                    q[o] = -this.lenZ;
                    E[o] = v * this.lenX / this.lenZ;
                    c[o] = this.lenY;
                    n[o] = this.lenZ;
                    f.push(this.foreground);
                    b = this.get3DTransfrom(this.lenX, this.lenY, v);
                    m = b[0] + B;
                    k = b[1] + r;
                    A = this.formatAxisValue(this.zAxisMin + H, "zAxis");
                    H += this.zAxisIncr;
                    if (this.zAxisShow) {
                        if (this.xRotate >= 45) {
                            if (this.yRotate >= 45) {
                                this.drawText(A, m + 5, k, this.axisTickFont, this.axisTickColor, "left")
                            } else {
                                this.drawText(A, m, k + 5, this.axisTickFont, this.axisTickColor, "right", false, - Math.PI / 2)
                            }
                        } else {
                            this.drawText(A, m + 5, k, this.axisTickFont, this.axisTickColor, "left")
                        }
                    }
                    o++
                }
                v += g;
                C++
            }
            this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle)
        } else {
            if (this.is3DPlot) {
                var h = this;
                var D = function () {
                    var l = C / h.varLabelInterval;
                    if (parseInt(l) == parseFloat(l)) {
                        b = h.get3DTransfrom(h.lenX, h.lenY, v - (g / 2));
                        m = b[0] + B;
                        k = b[1] + r;
                        A = h.data.y.vars[h.varIndices[C]];
                        if (h.xRotate >= 45) {
                            if (h.yRotate >= 45) {
                                h.drawText(A, m + 5, k, h.axisTickFont, h.axisTickColor, "left")
                            } else {
                                h.drawText(A, m, k + 5, h.axisTickFont, h.axisTickColor, "right", false, - Math.PI / 2)
                            }
                        } else {
                            h.drawText(A, m + 5, k, h.axisTickFont, h.axisTickColor, "left")
                        }
                    }
                };
                var G = function () {
                    var l = C / h.smpLabelInterval;
                    if (parseInt(l) == parseFloat(l)) {
                        b = h.get3DTransfrom((p * h.lenX / h.lenZ) - (e / 4), h.lenY, - h.lenZ);
                        m = b[0] + B;
                        k = b[1] + r;
                        A = h.data.y.smps[h.smpIndices[C]];
                        h.drawText(A, m, k + 5, h.axisTickFont, h.axisTickColor, "right", false, - Math.PI / 2)
                    }
                };
                v = z;
                C = 0;
                o = 0;
                while (v < this.lenZ) {
                    F[o] = -this.lenX;
                    d[o] = this.lenY;
                    q[o] = v;
                    E[o] = this.lenX;
                    c[o] = this.lenY;
                    n[o] = v;
                    f.push(this.zAxisTickColor);
                    D();
                    o++;
                    C++;
                    v += g
                }
                D();
                C = 0;
                p = w;
                while (p < this.lenZ) {
                    F[o] = p * this.lenX / this.lenZ;
                    d[o] = this.lenY;
                    q[o] = -this.lenZ;
                    E[o] = p * this.lenX / this.lenZ;
                    c[o] = this.lenY;
                    n[o] = this.lenZ;
                    f.push(this.zAxisTickColor);
                    G();
                    o++;
                    C++;
                    p += e
                }
                this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle);
                G()
            }
        }
        if (this.zAxisShow && !this.is3DPlot) {
            this.draw3DAxisTitle(this.lenX + (g * 6), this.lenX + (g * 6), this.lenY + (g * 6), this.lenY + (g * 6), z - (g * 2), this.lenZ + g, j, "z")
        }
        F = [-this.lenX, - this.lenX, this.lenX, - this.lenX];
        d = [this.lenY, this.lenY, this.lenY, this.lenY];
        q = [-this.lenZ, this.lenZ, - this.lenZ, - this.lenZ];
        E = [-this.lenX, this.lenX, this.lenX, this.lenX];
        c = [this.lenY, this.lenY, this.lenY, this.lenY];
        n = [this.lenZ, this.lenZ, this.lenZ, - this.lenZ];
        f = [this.foreground, this.foreground, this.foreground, this.foreground];
        this.draw3DLayout(F, d, q, E, c, n, f, this.zAxisTickStyle)
    };
    this.draw3DAxisTitle = function (v, u, e, d, k, j, n, c) {
        var p = this.measureText(n);
        var r = p / 2;
        var w = n.split("");
        var h = (v + u) / 2;
        var g = (e + d) / 2;
        var f = (k + j) / 2;
        var q = this.marginLeft + this.offsetX;
        var m = this.marginTop + this.offsetY;
        var o = this.xRotate >= 45 || this.yRotate >= 45 ? 4 : 0;
        if (this.xRotate >= 45 || this.yRotate >= 45) {
            p += w.length * 4;
            r = p / 2
        }
        if (c == "x") {
            h -= r;
            for (var s = 0; s < w.length; s++) {
                var b = this.get3DTransfrom(h, g, f);
                this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "top");
                h += this.measureText(w[s]) + o
            }
        } else {
            if (c == "y") {
                g += r;
                for (var s = 0; s < w.length; s++) {
                    var b = this.get3DTransfrom(h, g, f);
                    this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom", - Math.PI / 2);
                    g -= this.measureText(w[s]) + o
                }
            } else {
                if (c == "z") {
                    f -= r;
                    for (var s = 0; s < w.length; s++) {
                        var b = this.get3DTransfrom(h, g, f);
                        this.drawText(w[s], q + b[0], m + b[1], this.axisTitleFont, this.axisTitleColor, "left", "bottom");
                        f += this.measureText(w[s]) + o
                    }
                }
            }
        }
    };
    this.set3DLayout = function () {
        this.set3DXLayout();
        this.set3DYLayout();
        this.set3DZLayout()
    };
    this.set3DAxes = function () {
        var e = ["x", "y", "z"];
        this.setMin = null;
        this.setMax = null;
        if (this.is3DPlot) {
            if (this.xAxisTitle) {
                var c = this.yAxisTitle;
                this.yAxisTitle = this.xAxisTitle;
                this.xAxisTitle = c
            }
            this.yAxisMin = this.xAxisMin;
            this.yAxisMax = this.xAxisMax;
            this.yAxisIncr = this.xAxisIncr;
            this.yAxisDecs = this.xAxisDecs;
            this.yAxisRange = this.xAxisRange;
            this.yAxisUnit = this.lenY * 2 / this.yAxisRange;
            this.yAxisOffset = Math.min(this.lenY, (this.yAxisMin + (this.yAxisRange / 2)) * this.yAxisUnit);
            this.xAxisMin = 0;
            this.xAxisMax = 9;
            this.xAxisIncr = this.isGroupedData ? 10 / (this.grpIndices.length + 1) : 10 / (this.smpIndices.length + 1);
            this.xAxisDecs = 0;
            this.xAxisRange = this.xAxisMax - this.xAxisMin;
            this.xAxisUnit = this.lenX * 2 / this.xAxisRange;
            this.xAxisOffset = Math.min(this.lenX, (this.xAxisMin + (this.xAxisRange / 2)) * this.xAxisUnit);
            this.zAxisMin = 0;
            this.zAxisMax = 9;
            this.zAxisIncr = 10 / (this.varIndices.length + 1);
            this.zAxisDecs = 0;
            this.zAxisRange = this.zAxisMax - this.zAxisMin;
            this.zAxisUnit = this.lenZ * 2 / this.zAxisRange;
            this.zAxisOffset = Math.min(this.lenZ, (this.zAxisMin + (this.zAxisRange / 2)) * this.zAxisUnit)
        } else {
            for (var b = 0; b < e.length; b++) {
                var f = this.smpIndices;
                var d = e[b].toUpperCase();
                this[e[b] + "AxisIndex"] = this.getSampleIndices([this[e[b] + "Axis"]])[0];
                this.setSamplesVisible([this[e[b] + "AxisIndex"]]);
                this.setRangeData();
                this[e[b] + "AxisMin"] = this["setMin" + d] != null ? this["setMin" + d] : this.minData;
                this[e[b] + "AxisMax"] = this["setMax" + d] != null ? this["setMax" + d] : this.maxData;
                this[e[b] + "AxisIncr"] = this.getAxisIncrements(this[e[b] + "AxisMin"], this[e[b] + "AxisMax"], 10, this[e[b] + "AxisExact"]);
                this[e[b] + "AxisDecs"] = this.getAxisDecimals(this[e[b] + "AxisIncr"]);
                this[e[b] + "AxisMin"] = this.getAxisMin(this[e[b] + "AxisMin"], this[e[b] + "AxisIncr"]);
                this[e[b] + "AxisMax"] = this[e[b] + "AxisMin"] + (this[e[b] + "AxisIncr"] * 10);
                this[e[b] + "AxisRange"] = this[e[b] + "AxisMax"] - this[e[b] + "AxisMin"];
                this[e[b] + "AxisUnit"] = this["len" + d] * 2 / this[e[b] + "AxisRange"];
                this[e[b] + "AxisOffset"] = Math.min(this["len" + d], (this[e[b] + "AxisMin"] + (this[e[b] + "AxisRange"] / 2)) * this[e[b] + "AxisUnit"]);
                this.setSamplesVisible(f)
            }
        }
        this.set3DCenter()
    };
    this.set3DCenter = function () {
        var f = this.xAxisMin < 0 ? 0 : this.xAxisMin;
        var d = this.yAxisMin < 0 ? 0 : this.yAxisMin;
        var c = this.zAxisMin < 0 ? 0 : this.zAxisMin;
        var b = ((((this.xAxisMin + this.xAxisMax) / 2) - f) * this.xAxisUnit) - this.xAxisOffset;
        var g = this.yAxisOffset - ((((this.yAxisMin + this.yAxisMax) / 2) - d) * this.yAxisUnit);
        var e = ((((this.zAxisMin + this.zAxisMax) / 2) - c) * this.zAxisUnit) - this.zAxisOffset;
        this.zero3DPoint = this.get3DTransfrom(b, g, e)
    };
    this.is3DVisibleDataPoint = function (b, d, c) {
        if (b >= this.xAxisMin && b <= this.xAxisMax) {
            if (d >= this.yAxisMin && d <= this.yAxisMax) {
                if (c >= this.zAxisMin && c <= this.zAxisMax) {
                    return true
                }
            }
        }
        return false
    };
    this.isCulled = function (b, h, e, g) {
        for (i = 0; i < g; i++) {
            var f = this.cull3D[i];
            var d = f[2];
            if (e <= d && b >= f[0] - d && b <= f[0] + d && h >= f[1] - d && h <= f[1] + d) {
                return true
            }
        }
        return false
    };
    this.draw3DDataPoints = function () {
        var ab = this.marginLeft + this.offsetX + this.left;
        var T = this.marginTop + this.offsetY + this.top;
        var F = this.xAxisIndex + ":" + this.yAxisIndex + ":" + this.zAxisIndex;
        var E = [];
        var o = [];
        var J = [];
        var G = [];
        var U = [];
        var f = [];
        var ac = [];
        var ak = [];
        var e = [];
        var Q = 0;
		var color = [];
		
		
        if (this.is3DPlot) {
			
            var W = 0;
            for (var af = 0; af < this.varIndices.length; af++) {
                var N = this.varIndices[af];
                for (var ad = 0; ad < this.smpIndices.length; ad++) {
                    var A = this.smpIndices[ad];
                    var S = (ad * this.xAxisIncr) + (this.xAxisIncr / 2);
                    var R = this.getDataAtPos(N, A);
                    var P = (af * this.zAxisIncr) + (this.zAxisIncr / 2);
                    var w = 0;
                    var v = this.yAxisMin < 0 ? 0 : this.yAxisMin;
                    var u = 0;
                    var m = ((S - w) * this.xAxisUnit) - this.xAxisOffset;
                    var k = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((R - v) * this.yAxisUnit);
                    var h = ((P - u) * this.zAxisUnit) - this.zAxisOffset;
                    ac.push(true);
                    E.push([S, R, P]);
                    var I = this.get3DTransfrom(m, k, h);
                    o.push(I);
                    J.push(I[2]);
                    f.push(this.euclidianDistance([o[W][0], o[W][1], o[W][2]], [this.zero3DPoint[0], this.zero3DPoint[1], - this.x]));
                    e.push([N, A]);
                    U.push(W++)
                }
            }
        } else {
			for (var af = 0; af < this.varIndices.length; af++) {
				var N = this.varIndices[af];
				var S = this.getDataAtPos(N, this.xAxisIndex);
                var R = this.getDataAtPos(N, this.yAxisIndex);
                var P = this.getDataAtPos(N, this.zAxisIndex);
					
				color.push(colorCombination(this.getDataAtPos(N, 3))); //Sapan Change
				var w = this.xAxisMin < 0 ? 0 : this.xAxisMin;
                var v = this.yAxisMin < 0 ? 0 : this.yAxisMin;
                var u = this.zAxisMin < 0 ? 0 : this.zAxisMin;
                var m = ((S - w) * this.xAxisUnit) - this.xAxisOffset;
                var k = this.scatterType && this.scatterType.match(/bar/) ? 0 : this.yAxisOffset - ((R - v) * this.yAxisUnit);
                var h = ((P - u) * this.zAxisUnit) - this.zAxisOffset;
                ac.push(this.is3DVisibleDataPoint(S, R, P));
                E.push([S, R, P]);
                var I = this.get3DTransfrom(m, k, h);
                o.push(I);
				J.push(I[2]);
				if (this.scatterType != "function") {
					U.push(af);
                    f.push(this.euclidianDistance([o[af][0], o[af][1], o[af][2]], [this.zero3DPoint[0], this.zero3DPoint[1], - this.x]))
                }
            }
        }
        var L = this.range(J);
		
		if (this.scatterType && this.scatterType == "function") {
			var aa = Math.sqrt(o.length);
            var N = 0;
            var K = [];
            for (var af = 1; af < aa; af++) {
                for (var ad = 0; ad < aa - 1; ad++) {
                    var ae = ((af - 1) * aa) + ad;
                    var d = (af * aa) + ad;
                    var Z = ((af - 1) * aa) + ad + 1;
                    var ai = (af * aa) + ad + 1;
                    var M = [o[ae][0], o[d][0], o[ai][0], o[Z][0]];
                    var B = [o[ae][1], o[d][1], o[ai][1], o[Z][1]];
                    var am = [o[ae][2], o[d][2], o[ai][2], o[Z][2]];
                    var O = this.colorBy ? this.legendColorRange : false;
                    var H = this.colorBy ? this.getHeatmapColor(O[0], O[1], this.mean([E[ae][1], E[d][1], E[ai][1], E[Z][1]])) : false;
                    U.push(N++);
                    f.push(this.euclidianDistance([this.mean(M), this.mean(B), this.mean(am)], [this.zero3DPoint[0], this.zero3DPoint[1], - this.x]));
                    K.push([M, B, H])
                }
            }
            U.sort(function (g, c) {
                return f[c] - f[g]
            });
			for (var N = 0; N < K.length; N++) {
                var af = U[N];
                if (ac[af]) {
                    var al = [af, this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
                    if (this.colorBy) {
                        this.addArea(this.drawShape("polygon", K[af][0], K[af][1], false, false, K[af][2], this.foreground, "close"), al)
                    } else {
                        this.addArea(this.drawShape("polygon", K[af][0], K[af][1], false, false, false, this.foreground, "open"), al)
                    }
                }
            }
        } 
		else {
			
			
            var ah = this.is3DPlot ? this.scatterPointSize / (30 * this.bar3DInverseWeight) : this.scatterPointSize / (3 * this.bar3DInverseWeight);
			for (var N = 0; N < o.length; N++) {
                var af = U[N];
				
                var aj = color[N]; //Sapan Change
                var ag = this.scatterType && this.scatterType.match(/image/i) ? this.images[ad] : false;
                var al = this.is3DPlot ? [e[af][0], e[af][1]] : [af, this.xAxisIndex, this.yAxisIndex, this.zAxisIndex];
                if (ac[af] && this.isVisibleSelectedDataPoint(af, F)) {
                    if (this.scatterType && this.scatterType.match(/bar/)) {
                        var V = this.isInSelectedDataPoints(af, F) ? this.selectedBackgroundColor : aj;
                        this.draw3DBar(E[af][0], E[af][1], E[af][2], ah, V, al)
                    } 
					else {
						var Y = this.shapeBy ? this.dataShapes[af] : this.shapes[0];
                        var X = ag ? "image" : Y;
                        var V = this.sizeBy ? this.dataSizes[af] : this.scatterPointSize;
						var S = ab + o[af][0];
                        var R = T + o[af][1];
                        var P = Math.floor(this.percentile(L[0], L[1], o[af][2]));
                        V = V - ((V * (P / 100)) / 3);
						this.drawSelectedBackground(af, F, Y, S, R, V, V);
						
						this.addArea(this.drawShape(X, S, R, V, V, aj, this.foreground, "closed", false, false, false, false, false, false, ag), al);
						
						this.drawSelectedBackgroundLabel(af, F, S, R);
                        if (this.scatterType && this.scatterType.match(/line/)) {
                            G[af] = [o[af][0], o[af][1]]
                        }
                    }
                }
            }
			
			if (this.scatterType && this.scatterType.match(/line/) && G.length > 0) {
				for (var af = 0; af < G.length - 1; af++) {
                    if (ac[af] && this.isVisibleSelectedDataPoint(af, F) && ac[af + 1] && this.isVisibleSelectedDataPoint(af + 1, F)) {
                        var D = ab + G[af][0];
                        var b = T + G[af][1];
                        var C = ab + G[af + 1][0];
                        var an = T + G[af + 1][1];
                        this.drawLine("line", D, b, C, an, this.colors[0])
                    }
                }
            }
			
        }
		
	};
    this.set3DprivateParams = function () {
        this.set3DText();
        this.set3DParams()
    };
    this.draw3DPlot = function () {
        
		this.setDataColorShapeSize();
        this.set3DXYDimensions();
        this.set3DprivateParams();
        this.set3DRotation();
        this.set3DAxes();
        this.set3DLayout();
        this.drawTitle();
        this.draw3DDataPoints();
		this.drawScatterLegend()
    };
    this.initializeScatter3D = function () {
        if (this.layoutValid) {
            this.drawLayoutCompartments(this.draw3DPlot)
        } else {
            this.draw3DPlot()
        }
    };
    if (!a) {
        this.initializeScatter3D()
    }
};
CanvasXpress.doc = {
    F: {
        fill: {
            T: "color",
            M: "Genome",
            C: "Color for the feature"
        },
        id: {
            T: "string",
            M: "Genome",
            C: "Feature id"
        }
    },
    M: {
        Overlays: {
            D: "Colored boxes to help in the visualization of samples and variables",
            P: ["overlayFont", "overlayFontColor", "overlayFontSize", "overlayScaleFontFactor", "overlaysWidth", "showLevelOverlays", "showOverlays", "smpOverlayRecycleColors", "smpOverlays", "varOverlayRecycleColors", "varOverlays"],
            B: ["showLevelOverlays", "showOverlays", "smpOverlayRecycleColors", "smpOverlays", "varOverlayRecycleColors", "varOverlays"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Stacked: "true",
                Heatmap: "true"
            }
        },
        Axes: {
            D: "Axes parameters",
            P: ["axisExact", "axisExtension", "rAxisAbsMax", "rAxisAbsMin", "rAxisCurrent", "rAxisExact", "rAxisMaxStrLength", "rAxisMinorTicks", "rAxisMinorValues", "rAxisShow", "rAxisTickColor", "rAxisTickFormat", "rAxisTickStyle", "rAxisTicks", "rAxisTitle", "rAxisTransform", "rAxisTransformTicks", "rAxisValues", "setMax", "setMax2", "setMaxR", "setMaxX", "setMaxY", "setMaxZ", "setMin", "setMin2", "setMinR", "setMinX", "setMinY", "setMinZ", "ticks", "timeTicksFirst", "timeValueIndices", "timeValues", "xAxis", "xAxis2", "xAxis2AbsMax", "xAxis2AbsMin", "xAxis2Exact", "xAxis2MaxStrLength", "xAxis2MinorTicks", "xAxis2MinorValues", "xAxis2TickFormat", "xAxis2Ticks", "xAxis2Values", "xAxisAbsMax", "xAxisAbsMin", "xAxisCurrent", "xAxisExact", "xAxisMaxStrLength", "xAxisMinorTicks", "xAxisMinorValues", "xAxisShow", "xAxisTickColor", "xAxisTickFormat", "xAxisTickStyle", "xAxisTicks", "xAxisTitle", "xAxisTransform", "xAxisTransformTicks", "xAxisValues", "yAxis", "yAxisAbsMax", "yAxisAbsMin", "yAxisCurrent", "yAxisExact", "yAxisMaxStrLength", "yAxisMinorTicks", "yAxisMinorValues", "yAxisShow", "yAxisTickColor", "yAxisTickFormat", "yAxisTickStyle", "yAxisTicks", "yAxisTitle", "yAxisTransform", "yAxisTransformTicks", "yAxisValues", "zAxis", "zAxisAbsMax", "zAxisAbsMin", "zAxisCurrent", "zAxisExact", "zAxisMaxStrLength", "zAxisMinorTicks", "zAxisMinorValues", "zAxisShow", "zAxisTickColor", "zAxisTickFormat", "zAxisTickStyle", "zAxisTicks", "zAxisTitle", "zAxisTransform", "zAxisTransformTicks", "zAxisValues"],
            B: ["rAxisShow", "rAxisTickColor", "rAxisTitle", "rAxisTransform", "rAxisTransformTicks", "xAxisShow", "xAxisTickColor", "xAxisTitle", "xAxisTransform", "xAxisTransformTicks", "yAxisShow", "yAxisTickColor", "yAxisTitle", "yAxisTransform", "yAxisTransformTicks", "zAxisShow", "zAxisTickColor", "zAxisTitle", "zAxisTransform", "zAxisTransformTicks"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        Clustering: {
            D: "Paremeters used in clustering",
            P: ["centerData", "clusterAxis", "distance", "imputeMethod", "kmeansClusters", "linkage", "maxIterations", "useSmpVarIndexOnClustering"],
            B: ["centerData", "clusterAxis", "distance", "imputeMethod", "kmeansClusters", "linkage", "maxIterations", "useSmpVarIndexOnClustering"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Indicators: {
            D: "Legends for color, shape and size in visualizations",
            P: ["indicatorsPosition", "showIndicators"],
            B: ["indicatorsPosition", "showIndicators"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        Text: {
            D: "Properties associated with text attributes :",
            P: ["align", "autoScaleFont", "baseline", "font", "fontName", "fontSize", "fontStyle", "fonts", "maxTextSize", "minTextSize", "scaleTextConstantAdd", "scaleTextConstantMult"]
        },
        "2D Scatter Plot": {
            D: "General parameters in 2d scatter plots",
            P: ["allVsAll", "allVsAllType", "functionIntervals", "histogramBarWidth", "histogramBins", "isCreateHistogram", "isHistogram"],
            B: ["allVsAll", "allVsAllType"],
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true"
            }
        },
        "Axis Resizer": {
            D: "Parameters used when resizing graphs",
            P: ["resizerBackgroundColor", "resizerBackgroundColorCurrent", "resizerBackgroundColorOutlineCurrent", "resizerBackgroundImage", "resizerDraw", "resizerPosition", "resizerTransparency", "resizerType", "resizerWidth"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        Variables: {
            D: "Properties associated with variables",
            P: ["filterVarBy", "highlightVar", "maxVarStringLen", "showVariableNames", "varHighlightColor", "varLabelColor", "varLabelDescription", "varLabelFont", "varLabelFontSize", "varLabelInterval", "varLabelRotate", "varLabelScaleFontFactor", "varTitle", "varTitleColor", "varTitleFont", "varTitleFontSize", "varTitleLabelOverlayPosition", "varTitleScaleFontFactor"],
            B: ["filterVarBy", "highlightVar", "maxVarStringLen", "showVariableNames", "varHighlightColor", "varLabelColor", "varLabelDescription", "varLabelRotate", "varLabelScaleFontFactor", "varTitle", "varTitleColor", "varTitleLabelOverlayPosition", "varTitleScaleFontFactor"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        "Scatter and One-D Plots": {
            D: "General parameters in scatter and one dimesional plots",
            P: ["colorBy", "outlineBy", "shapeBy", "shapeByShape", "sizeBy", "this"],
            B: ["colorBy", "outlineBy", "shapeBy", "sizeBy"],
            U: {
                Bar: "true",
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Dotplot: "true",
                Boxplot: "true",
                Scatter3D: "true",
                Heatmap: "true"
            }
        },
        "Ticks and Axis Titles": {
            D: "Attributes for ticks and titles in axes in one and two dimensional plots",
            P: ["axisTickColor", "axisTickFont", "axisTickFontSize", "axisTitleColor", "axisTitleFont", "axisTitleFontSize", "axisTitleScaleFontFactor", "tickRotate", "tickScaleFontFactor"],
            B: ["axisTickColor", "axisTitleColor", "axisTitleScaleFontFactor", "tickRotate", "tickScaleFontFactor"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        "Venn Diagrams": {
            D: "General paremeters in Venn diagrams",
            P: ["vennColors", "vennCompartments", "vennGroups"],
            B: ["vennGroups"],
            U: {
                Venn: "true"
            }
        },
        Dendrograms: {
            D: "General parameters in dendrograms",
            P: ["dendrogramColor", "dendrogramHang", "dendrogramHeight", "dendrogramSpace", "showSmpDendrogram", "showVarDendrogram", "smpDendrogramPosition", "varDendrogramPosition"],
            B: ["dendrogramColor", "dendrogramHang", "dendrogramHeight", "dendrogramSpace", "showSmpDendrogram", "showVarDendrogram", "smpDendrogramPosition", "varDendrogramPosition"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        "Area Graphs": {
            D: "General parameters in area graphs",
            P: ["areaIsCumulative"],
            B: ["areaIsCumulative"],
            U: {
                Area: "true",
                AreaLine: "true"
            }
        },
        "Candlestick Plots": {
            D: "General parameters in candlestick plots",
            P: ["showVolume", "sma10Color", "sma20Color", "sma25Color", "sma50Color", "sma5Color", "stockIndicators"],
            B: ["showVolume", "sma10Color", "sma20Color", "sma25Color", "sma50Color", "sma5Color", "stockIndicators"],
            U: {
                Candlestick: "true"
            }
        },
        "Pie Charts": {
            D: "General parameters in pie charts",
            P: ["maxPieSectors", "pieSegmentLabels", "pieSegmentPrecision", "pieSegmentSeparation", "pieType", "showPieGrid", "showPieSampleLabel", "showPieValues", "startPieSectors"],
            B: ["maxPieSectors", "pieSegmentLabels", "pieSegmentPrecision", "pieSegmentSeparation", "pieType", "showPieGrid", "showPieSampleLabel", "showPieValues", "startPieSectors"],
            U: {
                Pie: "true"
            }
        },
        "Bar Graphs": {
            D: "General parameters in bar graphs",
            P: ["showDataValues"],
            B: ["showDataValues"],
            U: {
                Bar: "true",
                BarLine: "true"
            }
        },
        General: {
            D: "General properties used in most visualizations :",
            P: ["acknowledgementIcon", "acknowledgementIconPosition", "acknowledgment", "autoAdjust", "autoAdjustMax", "autoAdjustXTries", "autoAdjustYTries", "background", "backgroundGradient1Color", "backgroundGradient2Color", "backgroundImage", "backgroundType", "backgroundWindow", "backgroundWindowGradient1Color", "backgroundWindowGradient2Color", "backgroundWindowGradientOrientation", "canvasBox", "canvasBoxColor", "foreground", "foregroundWindow", "functions", "gradient", "gradientOrientation", "gradientRatio", "gradientType", "graphOrientation", "graphType", "margin", "marginBottom", "marginLeft", "marginRight", "marginTop", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "showShadow", "transparency"],
            B: ["acknowledgementIcon", "acknowledgementIconPosition", "acknowledgment", "autoAdjustXTries", "autoAdjustYTries", "background", "backgroundGradient1Color", "backgroundGradient2Color", "backgroundImage", "backgroundType", "canvasBox", "canvasBoxColor", "foreground", "functions", "graphOrientation", "graphType", "margin", "marginBottom", "marginLeft", "marginRight", "marginTop", "showShadow"]
        },
        "Heatmaps and Networks": {
            D: "General parameters in heatmaps, correlations and networks",
            P: ["heatmapType", "indicatorCenter", "indicatorHeight", "indicatorWidth"],
            B: ["heatmapType", "indicatorCenter", "indicatorHeight", "indicatorWidth"],
            U: {
                Correlation: "true",
                Scatter2D: "true",
                Network: "true",
                Scatter3D: "true",
                Heatmap: "true"
            }
        },
        "Line Graphs": {
            D: "General parameters in line graphs",
            P: ["coordinateLineColor", "lineDecoration", "lineTickness", "lineType", "tension"],
            B: ["coordinateLineColor", "lineDecoration", "lineType"],
            U: {
                StackedLine: "true",
                BarLine: "true",
                StackedPercentLine: "true",
                Line: "true",
                AreaLine: "true"
            }
        },
        "Box Plots": {
            D: "General parameters in box plots",
            P: ["boxPlotOutliersRatio", "showBoxplotOriginalData"],
            U: {
                Dotplot: "true",
                Boxplot: "true"
            }
        },
        Attributes: {
            D: "Lines, Colors, Shapes, Sizes and Time :",
            P: ["arrowPointSize", "capType", "colorHSV", "colorRGB", "colorScheme", "colors", "dashLength", "dotLength", "evenColor", "images", "lines", "oddColor", "outlineWidth", "shapes", "sizes", "timeFormat"],
            B: ["colorScheme", "colors", "evenColor", "oddColor"]
        },
        Events: {
            D: "Event parameters :",
            P: ["broadcast", "broadcastType", "configuratorWidth", "dataEvent", "dataFilterWidth", "destroyCanvasXpressZombies", "disableConfigurator", "disableEvents", "dockable", "eventArrowKeys", "eventKeys", "eventPlusMinusKeys", "helpKeyEvents", "infoTimeIn", "infoTimeOut", "monitorCanvasXpressZombiesTime", "resizable", "showAdvancedConfiguration", "this", "toolbarPermanent"],
            B: ["showAdvancedConfiguration"]
        },
        Animation: {
            D: "Animation parameters :",
            P: ["animationCycles", "animationTime", "animationType", "showAnimation", "showAnimationFont", "showAnimationFontColor", "showAnimationFontSize", "snapshotCopyChangeOnly"]
        },
        "Remote Procedures": {
            D: "Parameters used when getting data remotely :",
            P: ["remoteAutoPlay", "remoteAutoPlayDelay", "remoteDataIndex", "remoteDirection", "remoteIds", "remoteParams", "remoteParentId", "remoteService", "remoteUpdate", "remoteUpdateDelay", "remoteUpdating", "remoteWindow"]
        },
        Images: {
            D: "General parameters with images :",
            P: ["dropdownButton", "imageDir", "nextButton", "playButton", "previousButton", "stopButton"]
        },
        "Network Graphs": {
            D: "General parameters used in networks",
            P: ["approximateNodePositions", "attractiveForceFunction", "autoHideOnDecorationsCenter", "calculateLayout", "colorEdgeBy", "colorNodeBy", "edgeConfigurableProperties", "edgeWidth", "filterEdgeBy", "filterNodeBy", "highlightNode", "initialTemperature", "is3DNetwork", "isSelectNodes", "layoutTime", "moveParentsWithChildren", "network2DRotate", "networkDepth", "networkDivisions", "networkForceConstant", "networkFreeze", "networkFreezeOnLoad", "networkLayoutType", "networkNodeMinDistance", "networkNodesOnTop", "networkRoot", "networkStack", "networkStackIndex", "networkStackStates", "nodeConfigurableProperties", "nodeFont", "nodeFontColor", "nodeFontSize", "nodeHighlightColor", "nodeScaleFontFactor", "nodeSize", "overrideEventlessNodes", "preScaleNetwork", "randomNetwork", "randomNetworkNodeEdgesMax", "randomNetworkNodes", "reduceRandomNetwork", "repulsiveForceFunction", "selectNode", "shapeEdgeBy", "shapeNodeBy", "showHiddenChildEdges", "showNetworkDecorationsLegend", "showNetworkEdgesLegend", "showNetworkNodesLegend", "showNetworkRadialLayout", "showNetworkTextLegend", "showNodeNameThreshold", "sizeDecorationBy", "sizeEdgeBy", "sizeNodeBy", "skipClick", "subNetworks", "temperature"],
            B: ["autoHideOnDecorationsCenter", "calculateLayout", "colorEdgeBy", "colorNodeBy", "edgeWidth", "filterEdgeBy", "filterNodeBy", "highlightNode", "is3DNetwork", "networkLayoutType", "networkNodesOnTop", "networkRoot", "nodeFontColor", "nodeHighlightColor", "nodeScaleFontFactor", "nodeSize", "shapeEdgeBy", "shapeNodeBy", "showHiddenChildEdges", "showNetworkRadialLayout", "showNodeNameThreshold", "sizeDecorationBy", "sizeEdgeBy", "sizeNodeBy"],
            U: {
                Network: "true"
            }
        },
        "Combination Plots": {
            D: "Parameters used in complex plots :",
            P: ["layout", "layoutAdjust", "layoutAxis", "layoutComb", "layoutCurrent", "layoutHeight", "layoutMaxVarLegend", "layoutMulticolor", "layoutWidth", "offsetX", "offsetY", "scaleX", "scaleY", "translateX", "translateY", "weight"]
        },
        "Circular Graphs": {
            D: "General parameters in circular graphs",
            P: ["circularLetterSeparationFactor", "donutProportion", "rAxis", "rAxisZero", "ringSegmentSeparation", "ringType", "ringWeight"],
            B: ["circularLetterSeparationFactor", "donutProportion", "rAxis", "rAxisZero", "ringSegmentSeparation", "ringType", "ringWeight"],
            U: {
                Circular: "true"
            }
        },
        "Data table": {
            D: "Paremters associated with the data table :",
            P: ["colWidth", "dataTableColumnWidth", "dataTableTransposed", "freezeColLeft", "freezeColRight", "freezeRowBottom", "freezeRowTop", "maxCols", "maxRows", "networkShowDataTable", "refresehDataTableOnDraw", "rowHeight", "showDataTable", "showDataTableOnSelect", "startCol", "startRow"],
            B: ["dataTableColumnWidth"]
        },
        "Genome Browser": {
            D: "General paremeters used in genome browser",
            P: ["featrureCoordinateHeight", "featrureQualityHeight", "featrureSignalToNoiseHeight", "featrureTranslateHeight", "featureConfigurableProperties", "featureCoodinateShow", "featureHeightDefault", "featureNameFont", "featureNameFontColor", "featureNameFontSize", "featureQualityShow", "featureQualityValues", "featureSignalToNoiseShow", "featureSignalToNoiseValues", "featureStaggered", "featureTraceHeight", "featureTraceTrim", "featureTracesShow", "featureTranslateShow", "featureTypeDefault", "featureWidthDefault", "filterFeatureBy", "genomeResolution", "maxFeatureStringLen", "periodTicksLabels", "sequenceAColor", "sequenceBColor", "sequenceCColor", "sequenceDColor", "sequenceEColor", "sequenceEndColor", "sequenceFColor", "sequenceFill", "sequenceFont", "sequenceFontSize", "sequenceGColor", "sequenceHColor", "sequenceIColor", "sequenceKColor", "sequenceLColor", "sequenceMColor", "sequenceNColor", "sequencePColor", "sequenceQColor", "sequenceRColor", "sequenceSColor", "sequenceStartColor", "sequenceTColor", "sequenceUColor", "sequenceVColor", "sequenceWColor", "sequenceXColor", "sequenceYColor", "sequenceZColor", "showFeatureNameThereshold", "subtracksMaxDefault", "trackConfigurableProperties", "trackNameFont", "trackNameFontColor", "trackNameFontSize", "wireColor"],
            B: ["featureCoodinateShow", "featureNameFontColor", "featureQualityShow", "featureQualityValues", "featureSignalToNoiseShow", "featureSignalToNoiseValues", "featureStaggered", "featureTracesShow", "featureTranslateShow", "featureTypeDefault", "filterFeatureBy", "maxFeatureStringLen", "sequenceAColor", "sequenceBColor", "sequenceCColor", "sequenceDColor", "sequenceEColor", "sequenceEndColor", "sequenceFColor", "sequenceFill", "sequenceGColor", "sequenceHColor", "sequenceIColor", "sequenceKColor", "sequenceLColor", "sequenceMColor", "sequenceNColor", "sequencePColor", "sequenceQColor", "sequenceRColor", "sequenceSColor", "sequenceStartColor", "sequenceTColor", "sequenceUColor", "sequenceVColor", "sequenceWColor", "sequenceXColor", "sequenceYColor", "sequenceZColor", "showFeatureNameThereshold", "subtracksMaxDefault", "trackNameFontColor"],
            U: {
                Genome: "true"
            }
        },
        Skins: {
            D: "Parameters to change the skin of the application widgets :",
            P: ["skin", "skinHighlight", "skinProperties", "skinPropertiesBlue", "skinPropertiesGrey"]
        },
        Samples: {
            D: "Properties associated with samples",
            P: ["filterSmpBy", "highlightSmp", "maxSmpStringLen", "showSampleNames", "smpHighlightColor", "smpLabelCircular", "smpLabelColor", "smpLabelDescription", "smpLabelFont", "smpLabelFontSize", "smpLabelInterval", "smpLabelRotate", "smpLabelScaleFontFactor", "smpTitle", "smpTitleColor", "smpTitleFont", "smpTitleFontSize", "smpTitleScaleFontFactor"],
            B: ["filterSmpBy", "highlightSmp", "maxSmpStringLen", "showSampleNames", "smpHighlightColor", "smpLabelCircular", "smpLabelColor", "smpLabelDescription", "smpLabelRotate", "smpLabelScaleFontFactor", "smpTitle", "smpTitleColor", "smpTitleScaleFontFactor"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        "Zooming and Panning": {
            D: "Parameters associated with zooming and panning :",
            P: ["panningGlobalX", "panningGlobalY", "panningStep", "panningX", "panningY", "zoom", "zoomGlobal", "zoomSamplesDisable", "zoomStep", "zoomVariablesDisable"],
            B: ["zoomSamplesDisable", "zoomVariablesDisable"]
        },
        Snapshots: {
            D: "Paremeters used in snapshots",
            P: ["isAnimation", "snapshots"],
            U: {
                Network: "true"
            }
        },
        Titles: {
            D: "Properties used to manipulate general title, subtitle and citation :",
            P: ["citation", "citationColor", "citationFont", "citationScaleFontFactor", "smpTitleFontSize", "subtitle", "subtitleHeight", "title", "titleColor", "titleHeight"],
            B: ["citation", "citationColor", "citationScaleFontFactor", "smpTitleFontSize", "subtitle", "subtitleHeight", "title", "titleColor", "titleHeight"]
        },
        Debug: {
            D: "Debugging parameters :",
            P: ["codeType", "debug", "errors", "showCode", "showVersion"]
        },
        Legends: {
            D: "Legends for variables and samples",
            P: ["legendBackgroundColor", "legendBox", "legendBoxColor", "legendColor", "legendFont", "legendFontSize", "legendPosition", "legendScaleFontFactor", "showLegend"],
            B: ["legendBackgroundColor", "legendBox", "legendBoxColor", "legendColor", "legendPosition", "legendScaleFontFactor", "showLegend"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        Filtering: {
            D: "Parameters associated with filtering :",
            P: ["filterType"],
            B: ["filterType"]
        },
        "Dot Plots": {
            D: "General parameters in dot plots",
            P: ["dotPlotDataPointRatio", "dotPlotDataPointTransparency", "dotPlotJitter"],
            U: {
                Dotplot: "true",
                Boxplot: "true"
            }
        },
        "Scatter Plots": {
            D: "General parameters in scatter plots",
            P: ["isSelectDataPoints", "scatterSeries", "scatterType", "selectDataMode", "selectDataModeDescription", "selectDataPoint"],
            B: ["scatterSeries", "scatterType", "selectDataMode", "selectDataModeDescription"],
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Scatter3D: "true"
            }
        },
        Decorations: {
            D: "Additional elements added to graphs to increase data understanding",
            P: ["decorationFont", "decorationFontSize", "decorationScaleFontFactor", "decorations", "decorationsColor", "decorationsColors", "decorationsHeight", "decorationsPosition", "decorationsProperties", "decorationsType", "decorationsWidth", "showDecorations"],
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Network: "true",
                Scatter3D: "true"
            }
        },
        "3D Scatter Plot and Networks": {
            D: "General parameters in 3d scatter plots and neworks",
            P: ["bar3DInverseWeight", "cullingThreshold", "maxRotate", "minRotate", "rotationDelay", "rotationSensitivity", "rotationStep", "show3DGrid", "x3DRatio", "xRotate", "y3DRatio", "yRotate", "z3DRatio", "zRotate"],
            U: {
                Network: "true",
                Scatter3D: "true"
            }
        },
        "Correlation Graphs": {
            D: "General parameters for correlation",
            P: ["correlationAnchorLegend", "correlationAnchorLegendAlignWidth", "correlationAxis", "correlationLabelInterval"],
            B: ["correlationAxis"],
            U: {
                Correlation: "true"
            }
        },
        Functions: {
            D: "Functions exposed in the configurator :",
            P: ["addNormalDistributionLine", "addRegressionLine", "clusterSamples", "clusterVariables", "createHistogram", "createRandomData", "desegregateSamples", "desegregateVariables", "draw", "groupSamples", "hideCodeDiv", "hideInfoDiv", "hideUnhideSmps", "hideUnhideVars", "kmeansSamples", "kmeansVariables", "print", "recalculateLayout", "removeHistogram", "reset", "segregateSamples", "segregateVariables", "setSkin", "showCodeDiv", "showInfoDiv", "sortSamplesByCategory", "sortSamplesByVariable", "sortVariablesByCategory", "sortVariablesBySample", "transform", "transpose", "ungroupSamples", "updateCodeDiv"],
            B: ["addNormalDistributionLine", "addRegressionLine", "clusterSamples", "clusterVariables", "createRandomData", "desegregateSamples", "desegregateVariables", "draw", "groupSamples", "hideUnhideSmps", "hideUnhideVars", "kmeansSamples", "kmeansVariables", "print", "recalculateLayout", "removeHistogram", "reset", "segregateSamples", "segregateVariables", "setSkin", "sortSamplesByCategory", "sortSamplesByVariable", "sortVariablesByCategory", "sortVariablesBySample", "transform", "transpose", "ungroupSamples"]
        },
        Heatmaps: {
            D: "General paremters for heatmaps",
            P: ["isMultidimensionalHeatmap", "smpIndicesStart", "varIndicesStart"],
            U: {
                Heatmap: "true"
            }
        },
        "One dimentional plots": {
            D: "General parameters for one dimensional plots",
            P: ["blockContrast", "blockFactor", "blockSeparationFactor", "is3DPlot", "plotByVariable", "seriesSeparationFactor", "smpHairline", "smpHairlineColor", "smpHairlineWidth"],
            B: ["blockContrast", "is3DPlot", "plotByVariable", "seriesSeparationFactor", "smpHairline", "smpHairlineColor", "smpHairlineWidth"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        Data: {
            D: "Data related parameters",
            P: ["groupingFactors", "isBoxPlotCalc", "isGraphTime", "isGroupedData", "isLogData", "isMarketDataFormated", "isMarketSwitched", "isTransformedData", "missingDataColor", "randomData", "randomDataMean", "randomDataSampleAnnotationRatio", "randomDataSampleAnnotations", "randomDataSamples", "randomDataSigma", "randomDataVariableAnnotationRatio", "randomDataVariableAnnotations", "randomDataVariables", "randomMissingDataPercentage", "ratioReference", "segregateSamplesBy", "segregateVariablesBy", "showErrorBars", "smpSort", "sortDir", "tmpAsciiArray", "transformBase", "transformType", "varSort", "zscoreAxis"],
            B: ["groupingFactors", "isLogData", "missingDataColor", "ratioReference", "segregateSamplesBy", "segregateVariablesBy", "showErrorBars", "sortDir", "transformBase", "transformType", "zscoreAxis"],
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Candlestick: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        }
    },
    N: {
        outline: {
            T: "color",
            M: "Network",
            C: "Color for the outline of the node"
        },
        imagePath: {
            T: "url",
            M: "Network",
            C: "Url for the node image"
        },
        y: {
            T: "float",
            M: "Network",
            C: "Y coordinate"
        },
        outlineWidth: {
            T: "integer",
            M: "Network",
            C: "Pixels used to raw the outline of the node"
        },
        rotate: {
            T: "integer",
            M: "Network",
            C: "Number of degrees to rotate the shape"
        },
        shape: {
            T: "string",
            M: "Network",
            C: "Shape for the node. One of the ones defined in shapes"
        },
        z: {
            T: "float",
            M: "Network",
            C: "Z coordinate"
        },
        zIndex: {
            T: "integer",
            M: "Network",
            C: "Css property for the imagePath"
        },
        x: {
            T: "float",
            M: "Network",
            C: "X coordinate"
        },
        color: {
            T: "color",
            M: "Network",
            C: "Color for the node"
        },
        eventless: {
            T: "boolean",
            M: "Network",
            C: "Flag to disable all events in the node"
        },
        pattern: {
            O: "open, closed",
            T: "option",
            M: "Network",
            C: "Whether to draw a solid shape or just an outline"
        }
    },
    P: {
        yAxisTransform: {
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile"],
            T: "option",
            M: "Axes",
            D: "false",
            C: "Tranformation for the values in the Y axis."
        },
        setMaxX: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Maximum value to set the data in the X axis"
        },
        vennCompartments: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Venn Diagrams",
            C: "Name for the compartments in the the Venn diagrams"
        },
        shapeBy: {
            O: ["false", "variable"],
            T: "option",
            M: "Scatter and One-D Plots",
            X: "getXZData",
            D: "false",
            C: "Name of a variable annotation or a sample name or the string 'variable' to shape the variables."
        },
        pieSegmentLabels: {
            O: ["inside", "outside"],
            T: "option",
            M: "Pie Charts",
            D: "inside",
            C: "Location for the values in the pie charts"
        },
        sequenceLColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,103,0)",
            C: "Color for the leucines in the genome browser"
        },
        featrureQualityHeight: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "12",
            C: "Default size in pixels of the quality height"
        },
        xAxis2Exact: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to force exact values for the data in the 2nd X axis"
        },
        sequenceFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Genome Browser",
            C: "Font for the text of the sequence in the genome browser"
        },
        networkStack: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Network Graphs",
            C: "Array to keep state of the network after a drag or move"
        },
        desegregateSamples: {
            S: ["segregateSamples"],
            T: "void",
            M: "Functions",
            C: "Desegreagate samples previously segregated based on a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        is3DNetwork: {
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to create or not a 3D network"
        },
        backgroundWindow: {
            S: ["backgroundType"],
            A: "true",
            T: "color",
            M: "General",
            D: "rgb(204,204,204)",
            C: "Background color of the canvas window when the background type is a type of window."
        },
        varDendrogramPosition: {
            T: "option",
            M: "Dendrograms",
            D: "top",
            C: "Position for the variable dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph."
        },
        varLabelInterval: {
            A: "true",
            T: "integer",
            M: "Variables",
            D: "1",
            C: "Interval for the variable labels in heatmaps"
        },
        calculateLayout: {
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Flag to force or not to calculate the network layout."
        },
        shapes: {
            A: "true",
            O: ["sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "pacman", "mdavid", "rect2", "rect3", "arc", "rectangle", "image"],
            T: "array",
            M: "Attributes",
            C: "Shapes used in network graphs"
        },
        yAxisMinorValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the minor ticks in the Y axis"
        },
        sequenceTColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,0,0)",
            C: "Color for the thymidines and threonines in the genome browser"
        },
        networkNodeMinDistance: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "2",
            C: "Minimum distance between nodes in forceDirected and organic layouts"
        },
        nodeFontColor: {
            T: "color",
            M: "Network Graphs",
            D: "background color",
            C: "Color for the network text"
        },
        title: {
            S: ["titleHeight", "titleColor"],
            T: "string",
            M: "Titles",
            D: "false",
            C: "Title of the graph."
        },
        featrureTranslateHeight: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "12",
            C: "Default size in pixels of the translation height"
        },
        zAxisMaxStrLength: {
            Z: "true",
            A: "true",
            T: "string",
            M: "Axes",
            C: "Longest string for ticks in the Z axis"
        },
        featureCoodinateShow: {
            T: "boolean",
            M: "Genome Browser",
            D: "true",
            C: "Flag use to show coordinates"
        },
        yAxisExact: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to force exact values for the data in the Y axis"
        },
        showShadow: {
            S: ["shadowOffsetX", "shadowOffsetY", "this.shadowBlur", "shadowColor"],
            T: "boolean",
            M: "General",
            D: "false",
            C: "Flag used to add  shadows to all element in the canvas. It will be forced to false if the browser is IE."
        },
        rAxisTickFormat: {
            A: "true",
            T: "string",
            M: "Axes",
            D: "false",
            C: "Format for the tick values in the R axis"
        },
        colorScheme: {
            S: ["colors"],
            O: ["user", "basic", "dark", "strong", "light", "pastel", "balanced", "reset"],
            T: "option",
            M: "Attributes",
            D: "basic",
            C: "Color schemes can be user defined which will take the colors in the color property or one provided in canvasXpress. The order of the colors will be used to sequentially select when a different color is needed in a particular visualization."
        },
        remoteWindow: {
            A: "true",
            T: "integer",
            M: "Remote Procedures",
            D: "1",
            C: "Number of plots to show  when requesting remote data"
        },
        xAxisMinorValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the minor ticks in the X axis"
        },
        zAxisTickFormat: {
            A: "true",
            T: "string",
            M: "Axes",
            D: "false",
            C: "Format for the tick values in the Z axis"
        },
        showNetworkDecorationsLegend: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Flag to show node legends in the networks"
        },
        isMarketDataFormated: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data",
            C: "Flag to indicate if the data has been formated to display Candlestick."
        },
        rAxisMinorValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the minor ticks in the R axis"
        },
        segregateSamples: {
            S: ["desegregateSamples"],
            T: "option",
            M: "Functions",
            X: "getXData",
            C: "Segregate samples based on a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        skin: {
            A: "true",
            O: ["blue", "grey"],
            T: "option",
            M: "Skins",
            D: "grey",
            C: "Skin for the application"
        },
        isTransformedData: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data",
            C: "Flag to indicate if the data is transformed."
        },
        background: {
            S: ["backgroundType"],
            T: "color",
            M: "General",
            D: "rgb(255,255,255)",
            C: "Background color for the canvas."
        },
        resizerTransparency: {
            A: "true",
            T: "boolean",
            M: "Axis Resizer",
            D: "true",
            C: "Flag to make the axis resizers transparent"
        },
        hideUnhideVars: {
            T: "array",
            M: "Functions",
            X: "getVariablesAsArray",
            C: "Hide or unhide variables. It works like a switch",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        periodTicksLabels: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "5",
            C: "Number of ticks to skip between values in the genome browser"
        },
        colWidth: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "100",
            C: "Mumber of pixels for the width of cells in the data table"
        },
        scaleY: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Scale factor for the Y axis"
        },
        seriesSeparationFactor: {
            T: "float",
            M: "One dimentional plots",
            D: "2",
            C: "Factor to adjust the spacing between the series in the bar graphs"
        },
        varLabelFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Variables",
            C: "Font for the variable labels in one dimensional plots"
        },
        startCol: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data table",
            C: "Starting column in the data table"
        },
        xAxisTransform: {
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile"],
            T: "option",
            M: "Axes",
            D: "false",
            C: "Tranformation for the values in the X axis."
        },
        ratioReference: {
            T: "integer",
            M: "Data",
            D: "0",
            C: "Default index of sample used in ratio transformation."
        },
        citationColor: {
            S: ["citation"],
            T: "color",
            M: "Titles",
            D: "rgb(0,0,0)",
            C: "Color for a reference citation of the graph"
        },
        rAxisZero: {
            T: "boolean",
            M: "Circular Graphs",
            D: "true",
            C: "Flag to force the rAxis to start from zero otherwise it starts from the minimum value"
        },
        decorationsPosition: {
            A: "true",
            O: ["bottom", "right"],
            T: "option",
            M: "Decorations",
            D: "bottom",
            C: "Position for the decorations in scatter plots and network graphs"
        },
        eventPlusMinusKeys: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to enable plus / minus key binding events."
        },
        resizerBackgroundColorCurrent: {
            A: "true",
            T: "color",
            M: "Axis Resizer",
            D: "rgb(153,187,232)",
            C: "Color for the div that shows up the current area selected in the axes in the canvas"
        },
        correlationAnchorLegend: {
            A: "true",
            T: "boolean",
            M: "Correlation Graphs",
            D: "false",
            C: "Flag to show a region above the correlation plot that anchror a sample/variable to a position"
        },
        minRotate: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "false",
            C: "Minimum number of degrees to rotate graph arround axes"
        },
        axisTitleColor: {
            T: "color",
            M: "Ticks and Axis Titles",
            D: "foregroung color",
            C: "Color for the axis title in one and two dimensional plots"
        },
        xAxis2AbsMax: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Maximum unfiltered value for the 2nd X axis"
        },
        panningGlobalX: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            C: "Cumulative number of unit to pan the network in the X dimension"
        },
        xAxis: {
            A: "true",
            T: "array",
            M: "Axes",
            X: "getSamplesAsArray",
            D: "[]",
            C: "Name of the samples groups or variables to be displayed in the X axis"
        },
        featureNameFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Genome Browser",
            C: "Font for the text of the features in the genome browser"
        },
        scatterSeries: {
            O: ["x", "y"],
            T: "option",
            M: "Scatter Plots",
            D: "y",
            C: "Axis that contain the series in the scatter plots"
        },
        offsetY: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Additional amount to move for the Y axis."
        },
        selectNode: {
            Z: "true",
            A: "true",
            T: "object",
            M: "Network Graphs",
            D: "{}",
            C: "Name of nodes (in the data object) to select."
        },
        isGraphTime: {
            A: "true",
            T: "boolean",
            M: "Data",
            D: "false",
            C: "Flag to indicate if the data is a time series so ther is no need to plot every time interval"
        },
        featureQualityShow: {
            T: "boolean",
            M: "Genome Browser",
            D: "true",
            C: "Flag use to show quality"
        },
        featureTraceHeight: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "40",
            C: "Default size in pixels of the trace height"
        },
        lineDecoration: {
            O: ["false", "dot", "symbol"],
            T: "option",
            M: "Line Graphs",
            D: "sybol",
            C: "Lines decorations in the line graphs"
        },
        clusterAxis: {
            S: ["distance", "linkage", "imputeMethod", "centerData", "clusterSamples", "clusterVariables"],
            O: ["samples", "variables"],
            T: "option",
            M: "Clustering",
            D: "samples",
            C: "Default axis to use when clustering data."
        },
        xAxisValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the ticks in the X axis"
        },
        kmeansVariables: {
            S: ["kmeansClusters", "maxIterations"],
            T: "void",
            M: "Functions",
            C: "Cluster variables using kmeans",
            U: {
                StackedPercent: "true",
                Bar: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        maxVarStringLen: {
            T: "integer",
            M: "Variables",
            D: "30",
            C: "Maximum length in characters a variable label or description can have so anything above is truncated."
        },
        varLabelScaleFontFactor: {
            T: "float",
            M: "Variables",
            D: "1",
            C: "Scaling factor used to increse or decrease variable font size in the canvas."
        },
        rotationDelay: {
            A: "true",
            T: "integer",
            M: "3D Scatter Plot and Networks",
            D: "100",
            C: "Time in milliseconds to wait between rendering the plot when dragging the mouse."
        },
        varLabelRotate: {
            T: "integer",
            M: "Variables",
            D: "0",
            C: "Rotation for variable labels in degrees It could be positive or negative."
        },
        colorRGB: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Attributes",
            C: "Color RGB. Red, Green, Blue used in the configurator"
        },
        networkNodesOnTop: {
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Order to use when drawing nodes and edges in the networks"
        },
        setMaxZ: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Maximum value to set the data in the Z axis"
        },
        dendrogramHeight: {
            T: "boolean",
            M: "Dendrograms",
            D: "false",
            C: "Flag to size the branches of the dendrogram."
        },
        setMinZ: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Minimum value to set the data in the Z axis"
        },
        zAxisAbsMin: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Minimum unfiltered value for the Z axis"
        },
        showFeatureNameThereshold: {
            T: "integer",
            M: "Genome Browser",
            D: "20",
            C: "Threshehold used to set te limit when there are too many features in the genome browser"
        },
        varTitleFontSize: {
            A: "true",
            T: "integer",
            M: "Variables",
            D: "10",
            C: "Size for the variable title in one dimensional plots"
        },
        reduceRandomNetwork: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to create or not a single random network for debug and demonstraion purposes"
        },
        edgeWidth: {
            T: "integer",
            M: "Network Graphs",
            D: "1",
            C: "Default width for the edges in the networks"
        },
        sequenceSColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,165,0)",
            C: "Color for the degenerate G/C and serines in the genome browser"
        },
        isMultidimensionalHeatmap: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Heatmaps",
            C: "Flag to indicate if the heatmap is multidimensional"
        },
        maxIterations: {
            S: ["kmeansClusters", "kmeansSamples", "kmeansVariables"],
            T: "integer",
            M: "Clustering",
            D: "10",
            C: "Number of maximum iterations when clustering data with kmeans for one dimensional graphs or maximum number of iterations when calculating force direct layout networks."
        },
        sortDir: {
            O: ["ascending", "descending"],
            T: "option",
            M: "Data",
            D: "ascending",
            C: "Default direction for data sorting."
        },
        filterSmpBy: {
            T: "filter",
            M: "Samples",
            X: "getXData",
            D: "[]",
            C: "Filter samples by their annotation included in the 'data.x' object used in one dimensional plots"
        },
        featrureSignalToNoiseHeight: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "12",
            C: "Default size in pixels of the quality height"
        },
        autoAdjustMax: {
            A: "true",
            T: "integer",
            M: "General",
            D: "3",
            C: "Number of times to try to automaticaly adjust the size of the canvas when autoAdjust is true"
        },
        smpTitleColor: {
            T: "color",
            M: "Samples",
            D: "foreground color",
            C: "Font color for the sample title in one dimensional plots"
        },
        showOverlays: {
            T: "boolean",
            M: "Overlays",
            D: "true",
            C: "Flag to indicate to show or not the overlays in one dimensional plots"
        },
        graphOrientation: {
            O: ["horizontal", "vertical"],
            T: "option",
            M: "General",
            D: "horizontal",
            C: "Orientation of the graph when plotting one dimensional graphs"
        },
        outlineWidth: {
            A: "true",
            T: "integer",
            M: "Attributes",
            D: "1",
            C: "Default width in pixels for the lines"
        },
        randomDataVariableAnnotationRatio: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "2",
            C: "Approximate number of classes in each variable annotation when creating random data"
        },
        marginRight: {
            T: "integer",
            M: "General",
            D: "0",
            C: "Length in pixels for the right margin in the canvas"
        },
        align: {
            A: "true",
            O: ["right", "center", "left"],
            T: "option",
            M: "Text",
            D: "center",
            C: "Default horizontal alignment for drawing text."
        },
        dataTableTransposed: {
            A: "true",
            T: "boolean",
            M: "Data table",
            D: "true",
            C: "Flag to transpose the data in the data table"
        },
        showDataTableOnSelect: {
            A: "true",
            T: "boolean",
            M: "Data table",
            D: "false",
            C: "Flag to indicate to show data after selecting data in the plot"
        },
        wireColor: {
            A: "true",
            T: "color",
            M: "Genome Browser",
            D: "rgba(204,204,204,0.1)",
            C: "Color for the ticks in the genome browser"
        },
        sequenceVColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,103,0)",
            C: "Color for the degenerate A/C/G and valines in the genome browser"
        },
        marginTop: {
            T: "integer",
            M: "General",
            D: "0",
            C: "Length in pixels for the top margin in the canvas"
        },
        setMin: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Minimum value to set the data"
        },
        animationCycles: {
            A: "true",
            T: "integer",
            M: "Animation",
            D: "20",
            C: "Number of cycles to plot the graph for the animations."
        },
        sequenceDColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the degenerate A/G/T and aspartic acids in the genome browser"
        },
        shapeNodeBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to shape the nods."
        },
        errors: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Debug",
            D: "[]",
            C: "Array containing benign errors produced when rendering canvasXpress"
        },
        xAxisShow: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to show on not the values of the ticks in the X axis"
        },
        skinPropertiesGrey: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Skins",
            D: "[]",
            C: "Values for the grey skin"
        },
        canvasBoxColor: {
            S: ["canvasBox"],
            T: "color",
            M: "General",
            D: "rgb(0,0,0)",
            C: "Color for the box around the canvas"
        },
        subtitleHeight: {
            S: ["subtitle", "subtitleColor"],
            T: "integer",
            M: "Titles",
            D: "16",
            C: "Height for the subtitle of the graph. The font height will be adjusted automatically to fit in the canvas."
        },
        indicatorsPosition: {
            O: ["bottom", "right"],
            T: "option",
            M: "Indicators",
            D: "bottom",
            C: "Position for the color, shape and size indicators in several visualizations"
        },
        featureConfigurableProperties: {
            F: "id:[string];Feature id;[],fill:[color];Color for the feature;[]",
            A: "true",
            T: "array",
            M: "Genome Browser",
            D: ["'id'", "'name'", "'hideName'", "'fill'", "'outline'", "'dir'", "'showDir'", "'connect'", "'offset'", "'data'", "'subtype'", "'quality'", "'signalToNoise'", "'coordinate'", "'sequence'", "'trace'", "'gaps'", "'translate'", "'hide'", "'counter'"],
            C: "Feature configurable properties"
        },
        titleHeight: {
            S: ["title", "titleColor"],
            T: "integer",
            M: "Titles",
            D: "30",
            C: "Height for the title of the graph. The font height will be adjusted automatically to fit in the canvas."
        },
        subtracksMaxDefault: {
            T: "integer",
            M: "Genome Browser",
            D: "8",
            C: "Maximum number of subtracks to show in a track"
        },
        acknowledgment: {
            T: "boolean",
            M: "General",
            D: "false",
            C: "Acknowledge canvasXpress"
        },
        sizes: {
            A: "true",
            O: ["4", "6", "8", "10", "12", "14", "16", "18", "20", "22", "24", "26", "28", "30", "32", "34"],
            T: "array",
            M: "Attributes",
            C: "Sizes used invisualizations"
        },
        infoTimeIn: {
            A: "true",
            T: "integer",
            M: "Events",
            D: "3000",
            C: "Time in milliseconds to start showing info after a mouse over"
        },
        layoutHeight: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Height of the current segment of the canvas when there are multiple graphs."
        },
        sizeEdgeBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to size the edges."
        },
        foregroundWindow: {
            S: ["backgroundType"],
            A: "true",
            T: "color",
            M: "General",
            D: "rgb(0,0,0)",
            C: "Foreground color of the canvas window when the background type is a type of window."
        },
        colorBy: {
            O: ["false", "variable"],
            T: "option",
            M: "Scatter and One-D Plots",
            X: "getXZData",
            D: "false",
            C: "Name of a variable annotation or a sample name or the string 'variable' to color the variables."
        },
        randomNetworkNodeEdgesMax: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "5",
            C: "Default number of maximum edges when creating random networks"
        },
        scaleTextConstantAdd: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Text",
            D: "2.5",
            C: "Constants to autoscale text (extra)"
        },
        rAxisExact: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to force exact values for the data in the R axis"
        },
        transformBase: {
            O: ["2", "10"],
            T: "integer",
            M: "Data",
            D: "2",
            C: "Default log or exponential transformation."
        },
        centerData: {
            S: ["distance", "linkage", "clusterAxis", "imputeMethod", "clusterSamples", "clusterVariables"],
            T: "boolean",
            M: "Clustering",
            D: "false",
            C: "Flag to indicate whether to center data when clustering"
        },
        missingDataColor: {
            T: "color",
            M: "Data",
            D: "rgb(255,255,0)",
            C: "Color for the missing data"
        },
        rAxisMinorTicks: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "A flag to show minor tick lines in the R axis"
        },
        offsetX: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Additional amount to move for the X axis"
        },
        rAxisAbsMin: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Minimum unfiltered value for the R axis"
        },
        zAxisTickStyle: {
            A: "true",
            O: ["solid", "dotted"],
            T: "option",
            M: "Axes",
            D: "solid",
            C: "Style for the tick lines in the Z axis"
        },
        showNodeNameThreshold: {
            T: "integer",
            M: "Network Graphs",
            D: "50",
            C: "Thereshold used to set the limit to hide or display the name of nodes in a network. If the number of nodes exceed this thereshold then the name will not be shown."
        },
        smpLabelRotate: {
            T: "integer",
            M: "Samples",
            D: "0",
            C: "Rotation for sample labels in degrees. It could be positive or negative."
        },
        randomDataSampleAnnotations: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "3",
            C: "Default number of sample annotations when creating random data"
        },
        isSelectDataPoints: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Scatter Plots",
            D: "0",
            C: "Number of selected data points (in the data object)."
        },
        showNetworkRadialLayout: {
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to show or not a radial layout wire."
        },
        resizerWidth: {
            A: "true",
            T: "integer",
            M: "Axis Resizer",
            D: "18",
            C: "Length in pixels for the width of the visible axis resizer"
        },
        overlayFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Overlays",
            C: "Font for the overlays in one dimensional plots"
        },
        infoTimeOut: {
            A: "true",
            T: "integer",
            M: "Events",
            D: "3000",
            C: "Time in milliseconds to wait between updates for the mouse over info to show up"
        },
        rAxisTickStyle: {
            A: "true",
            O: ["solid", "dotted"],
            T: "option",
            M: "Axes",
            D: "solid",
            C: "Style for the tick lines in the R axis"
        },
        setMinY: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Minimum value to set the data in the Y axis"
        },
        showNetworkEdgesLegend: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Flag to show edge legends in the networks"
        },
        panningGlobalY: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            C: "Cumulative umber of unit to pan the network in the Y dimension"
        },
        filterNodeBy: {
            T: "filter",
            M: "Network Graphs",
            X: "getNodeData",
            D: "[]",
            C: "Filter nodes by their properties used in network graphs"
        },
        zAxisTicks: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "5",
            C: "Number of ticks in the Z axis"
        },
        featureHeightDefault: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "14",
            C: "Default size in pixels of the feature height"
        },
        remoteIds: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Remote Procedures",
            C: "Array of the remoteIds passed after a service call"
        },
        freezeColLeft: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "0",
            C: "Number of columns to freeze in the left side of the data table"
        },
        dotPlotDataPointTransparency: {
            S: ["showBoxplotOriginalData", "dotPlotDataPointRatio"],
            A: "true",
            T: "float",
            M: "Dot Plots",
            D: "0.5",
            C: "Fraction to adjust color transparency for the data points when displaying original data in boxplots."
        },
        yAxisTickFormat: {
            A: "true",
            T: "string",
            M: "Axes",
            D: "false",
            C: "Format for the tick values in the Y axis"
        },
        isGroupedData: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data",
            C: "Flag to indicate if the data is grouped."
        },
        setMin2: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Minimum value to set the data in the 2nd axis"
        },
        zoomGlobal: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            C: "Cumulative zoom factor for the networks."
        },
        decorationsType: {
            A: "true",
            O: ["pie", "bar", "heatmap", "stacked", "stackedpercent"],
            T: "option",
            M: "Decorations",
            D: "bar",
            C: "Type for the decorations in the networks. The types stacked and stackedpercent must be two dimensional. Heatmap could be one or two dimensional"
        },
        showVersion: {
            A: "true",
            T: "boolean",
            M: "Debug",
            D: "true",
            C: "Flag to show version when mouse over top-left corner of the canvas."
        },
        networkDepth: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Network Graphs",
            C: "Depth of the radial network."
        },
        showHiddenChildEdges: {
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Flag to show or not children nodes when the parent node is hidden."
        },
        randomDataSigma: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "100",
            C: "Sigma value when creating random data"
        },
        nodeConfigurableProperties: {
            A: "true",
            T: "array",
            M: "Network Graphs",
            D: ["'x'", "'y'", "'z'", "'shape'", "'color'", "'outline'", "'size'", "'width'", "'height'", "'pattern'", "'rotate'", "'outlineWidth'", "'imagePath'", "'zIndex'", "'eventless'"],
            N: "x:[float];X coordinate;[],y:[float];Y coordinate;[],z:[float];Z coordinate;[],shape:[string];Shape for the node. One of the ones defined in shapes;[shapes],color:[color];Color for the node;[],outline:[color];Color for the outline of the node;[],pattern:[open|closed];Whether to draw a solid shape or just an outline;[],rotate:[integer];Number of degrees to rotate the shape;[],outlineWidth:[integer];Pixels used to raw the outline of the node;[],imagePath:[url];Url for the node image;[],zIndex:[integer];Css property for the imagePath;[],eventless:[boolean];Flag to disable all events in the node;[overrideEventlessNodes]",
            C: "Node configurable properties"
        },
        zoomStep: {
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            D: "0.2",
            C: "Percentage step for zooming networks and genome panel."
        },
        axisTitleScaleFontFactor: {
            T: "float",
            M: "Ticks and Axis Titles",
            D: "1",
            C: "Scaling factor used to increse or decrease title font size in the canvas in one and two dimensional plots"
        },
        zAxisExact: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to force exact values for the data in the Z axis"
        },
        featureSignalToNoiseValues: {
            T: "boolean",
            M: "Genome Browser",
            D: "false",
            C: "Flag use to show values for the quality"
        },
        tickScaleFontFactor: {
            T: "float",
            M: "Ticks and Axis Titles",
            D: "1",
            C: "Scaling factor used to increse or decrease tick font size in the canvas in one and two dimensional plots"
        },
        showNetworkTextLegend: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Flag to show node legends in the networks"
        },
        showIndicators: {
            T: "boolean",
            M: "Indicators",
            D: "true",
            C: "Flag to show color, shape and size indicators in several visualizations"
        },
        createHistogram: {
            A: "true",
            O: ["x", "y"],
            T: "option",
            M: "Functions",
            C: "Create a histogram in 2D-Scatter plots in the 'x' axis or the 'y' axis",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Scatter3D: "true"
            }
        },
        sma20Color: {
            T: "color",
            M: "Candlestick Plots",
            D: "rgb(0,0,255)",
            C: "The color for the 25 day single moving average"
        },
        smpHairlineColor: {
            T: "color",
            M: "One dimentional plots",
            D: "rgb(204,204,204)",
            C: "The color for the thin line that appears in the middle of the bar graphs"
        },
        axisTitleFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Ticks and Axis Titles",
            C: "Font for the axis titles in one and two dimensional plots"
        },
        functions: {
            Z: "true",
            T: "array",
            M: "General",
            C: "Functions exposed to the api"
        },
        decorationsProperties: {
            A: "true",
            T: "object",
            M: "Decorations",
            D: "{}",
            C: "Object to assign properties like color for the network decorations"
        },
        ticks: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "50",
            C: "Number of ticks in the genome browser"
        },
        rAxisMaxStrLength: {
            Z: "true",
            A: "true",
            T: "string",
            M: "Axes",
            C: "Longest string for ticks in the R axis"
        },
        showAnimationFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Animation",
            C: "Font for the text in animations"
        },
        nodeFontSize: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "node width",
            C: "Size in pixels for the font size of text in the networks"
        },
        sortSamplesByVariable: {
            S: ["sortDir", "sortSamplesByCategory"],
            T: "array",
            M: "Functions",
            X: "getVariablesAsArray",
            C: "Sort the samples by the value of a variable",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        resizerBackgroundImage: {
            A: "true",
            Z: "true",
            T: "url",
            M: "Axis Resizer",
            D: "-1",
            C: "Object to store data when the canvas is zoomed with the axis resizer resizerEventData @type {object}"
        },
        sizeDecorationBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to size the network decoration."
        },
        setSkin: {
            O: ["blue", "grey"],
            T: "option",
            M: "Functions",
            C: "Change the skin of the application"
        },
        trackConfigurableProperties: {
            A: "true",
            T: "array",
            M: "Genome Browser",
            D: ["'name'", "'hideName'", "'hideFeatureNames'", "'type'", "'height'", "'fill'", "'outline'", "'data'", "'hide'", "'connect'", "'subtracksMax'", "'highlight'"],
            C: "Track configurable properties",
            G: "name:[string];Track name;[]"
        },
        xAxisTickColor: {
            T: "color",
            M: "Axes",
            D: "rgb(204,204,204)",
            C: "Color for the tick lines in the X axis"
        },
        yAxisTickColor: {
            T: "color",
            M: "Axes",
            D: "rgb(204,204,204)",
            C: "Color for the tick lines in the Y axis"
        },
        isAnimation: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Snapshots",
            C: "Flag to indicate if there is an active animation"
        },
        pieSegmentPrecision: {
            T: "integer",
            M: "Pie Charts",
            D: "0",
            C: "Number of decimals for values in the Pie charts"
        },
        layoutMulticolor: {
            A: "true",
            T: "boolean",
            M: "Combination Plots",
            D: "true",
            C: "Flag to cycle colors when displaying multiple graps in the canvas. If set to false the color will be reseted for every graph."
        },
        decorationScaleFontFactor: {
            A: "true",
            T: "float",
            M: "Decorations",
            D: "1",
            C: "Scaling factor used to increse or decrease decoration font size in the canvas."
        },
        previousButton: {
            A: "true",
            T: "image",
            M: "Images",
            D: "rewind.png",
            C: "Relative path to an image file to the previous button (not including the image directory)"
        },
        boxPlotOutliersRatio: {
            A: "true",
            T: "integer",
            M: "Box Plots",
            D: "8",
            C: "Ratio for the size of the outliers with respect to boxplot"
        },
        panningY: {
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            D: "0",
            C: "Number of unit to pan the network in the Y dimension"
        },
        varTitleColor: {
            T: "color",
            M: "Variables",
            D: "foreground color",
            C: "Font color for the variable titles in one dimensional plots"
        },
        setMinR: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Minimum value to set the data in the R axis"
        },
        randomDataMean: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "100",
            C: "Mean value when creating random data"
        },
        transpose: {
            T: "void",
            M: "Functions",
            C: "Transpose the data. It takes no parameters",
            U: {
                StackedPercent: "true",
                Bar: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        smpLabelScaleFontFactor: {
            T: "float",
            M: "Samples",
            D: "1",
            C: "Scaling factor used to increse or decrease sample label font size in the canvas."
        },
        circularLetterSeparationFactor: {
            T: "float",
            M: "Circular Graphs",
            D: "2",
            C: "Factor to adjust the spacing between letters in the circular graphs. The greater the number the closer the letters in the labels"
        },
        debug: {
            A: "true",
            T: "boolean",
            M: "Debug",
            D: "true",
            C: "Flag to turn on alerts."
        },
        citation: {
            S: ["citationColor"],
            T: "string",
            M: "Titles",
            D: "false",
            C: "A reference citation of the graph which is placed at the bottom right corner"
        },
        smpSort: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Data",
            C: "Sample index used in sorting the data."
        },
        resizerBackgroundColorOutlineCurrent: {
            A: "true",
            T: "color",
            M: "Axis Resizer",
            D: "rgb(153,187,232)",
            C: "Color for the div that shows up the current area selected in the axes in the canvas"
        },
        showAnimation: {
            A: "true",
            T: "boolean",
            M: "Animation",
            D: "false",
            C: "Flag to show or not animation for the graphs"
        },
        networkFreezeOnLoad: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to prevent autoscaling for the network layout after loading."
        },
        layoutTime: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "15",
            C: "Time in milliseconds used to calculate the layout for the network"
        },
        xAxisAbsMax: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Maximum unfiltered value for the X axis"
        },
        isLogData: {
            T: "boolean",
            M: "Data",
            D: "false",
            C: "Flag to indicate if the data is Log transformed."
        },
        tension: {
            A: "true",
            T: "float",
            M: "Line Graphs",
            D: "0.3",
            C: "Curvature for the splines"
        },
        networkStackIndex: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Network Graphs",
            C: "Index in the network stack for undo and redo operations"
        },
        axisTickColor: {
            T: "color",
            M: "Ticks and Axis Titles",
            D: "foregroung color",
            C: "Color for the axis ticks in one and two dimensional plots"
        },
        resizerBackgroundColor: {
            A: "true",
            T: "color",
            M: "Axis Resizer",
            D: "rgb(204,204,204)",
            C: "Color for the div that shows up when resizing the axes in the canvas or the whole canvas"
        },
        groupSamples: {
            S: ["ungroupSamples"],
            T: "array",
            M: "Functions",
            X: "getXData",
            C: "Group samples based on a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        zRotate: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "0",
            C: "Number of degrees to rotate graph arround the Z axis"
        },
        remoteDirection: {
            A: "true",
            O: ["next", "prev"],
            T: "option",
            M: "Remote Procedures",
            D: "next",
            C: "Direction parameter used to obtain data remotely."
        },
        featureWidthDefault: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "3",
            C: "Default size in pixels of the feature width"
        },
        skinPropertiesBlue: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Skins",
            D: "[]",
            C: "Values for the blue skin"
        },
        rAxisShow: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to show on not the values of the ticks in the R axis"
        },
        showVariableNames: {
            T: "boolean",
            M: "Variables",
            D: "true",
            C: "Flag to show the variable names in one dimensional plots"
        },
        lineTickness: {
            A: "true",
            T: "float",
            M: "Line Graphs",
            D: "1",
            C: "Thickness in pixels for line plots"
        },
        decorationFontSize: {
            A: "true",
            T: "font",
            M: "Decorations",
            D: "10",
            C: "Font size for the decorations in scatter plots and network graphs"
        },
        fontSize: {
            A: "true",
            T: "integer",
            M: "Text",
            D: "12",
            C: "Font size for text in complex plot only. See other categories to modify specific font sizes."
        },
        imageDir: {
            A: "true",
            T: "url",
            M: "Images",
            D: "http://canvasxpress.org/images/",
            C: "Relative path to a directory contaioning images"
        },
        filterType: {
            O: ["and", "or"],
            T: "option",
            M: "Filtering",
            D: "and",
            C: "Type for the filter. Can be 'and' or 'or'"
        },
        animationTime: {
            A: "true",
            T: "integer",
            M: "Animation",
            D: "30",
            C: "Time in milliseconds to wait between rendering the plot when showing the animation."
        },
        layoutMaxVarLegend: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Combination Plots",
            C: "Maximum length of legend when multiple graphs are displayed in the canvas."
        },
        resizable: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to disable resizing the canvas by dragging the mouse over the edges"
        },
        attractiveForceFunction: {
            A: "true",
            O: ["Eades", "FruchtermanReingold"],
            T: "option",
            M: "Network Graphs",
            D: "FruchtermanReingold",
            C: "Type of function to apply when calculating attractive force in forceDirected network layouts"
        },
        rotationStep: {
            A: "true",
            T: "integer",
            M: "3D Scatter Plot and Networks",
            D: "2",
            C: "Number of degrees used when the plot is automatically rotated"
        },
        xAxis2Ticks: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "5",
            C: "Number of ticks in the 2nd X axis"
        },
        layoutCurrent: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Combination Plots",
            C: "Integer to identify the current graph being displayed in the canvas."
        },
        graphType: {
            O: ["Bar", "Line", "Area", "AreaLine", "BarLine", "Boxplot", "Dotplot", "Heatmap", "Candlestick", "Stacked", "StackedLine", "StackedPercent", "StackedPercentLine", "Scatter2D", "ScatterBubble2D", "Scatter3D", "Correlation", "Pie", "Venn", "Network", "Genome", "Circular"],
            T: "option",
            M: "General",
            D: "Bar",
            C: "Type of graph"
        },
        distance: {
            S: ["linkage", "clusterAxis", "centerData", "clusterSamples", "clusterVariables"],
            O: ["euclidian", "manhattan", "max"],
            T: "option",
            M: "Clustering",
            D: "euclidian",
            C: "Distance metric to use when clustering data."
        },
        featureSignalToNoiseShow: {
            T: "boolean",
            M: "Genome Browser",
            D: "true",
            C: "Flag use to show quality"
        },
        remoteUpdateDelay: {
            A: "true",
            T: "integer",
            M: "Remote Procedures",
            D: "10000",
            C: "Time in milliseconds to wait between tryig to get an upated version of the file containing the data"
        },
        layout: {
            A: "true",
            T: "string",
            M: "Combination Plots",
            D: "1X1",
            C: "Topology of the canvas. Number of rows and columns."
        },
        marginBottom: {
            T: "integer",
            M: "General",
            D: "0",
            C: "Length in pixels for the bottom margin in the canvas"
        },
        filterEdgeBy: {
            T: "filter",
            M: "Network Graphs",
            X: "getEdgeData",
            D: "[]",
            C: "Filter edges by their properties used in network graphs"
        },
        showPieValues: {
            T: "float",
            M: "Pie Charts",
            D: "true",
            C: "A flag to show the values for the pie"
        },
        smpTitleFontSize: {
            A: "true",
            T: "integer",
            M: "Samples",
            D: "10",
            C: "Size for the sample title in one dimensional plots"
        },
        edgeConfigurableProperties: {
            A: "true",
            T: "array",
            M: "Network Graphs",
            D: ["'width'", "'cap'", "'exact'", "'type'"],
            C: "Edge configurable properties",
            E: "width:[integer];Pixel width for the edges between nodes;[],cap:[butt|round|square];Type of cap for the end of the lines;[capType],exact:[boolean];Flag to indicate to create the edge between nodes without substracting the size of the nodes;[],type:[string];Type of line use to join the nodes;[lines]"
        },
        ringType: {
            T: "array",
            M: "Circular Graphs",
            D: "[]",
            C: "Array containing the types for each ring in the circular plots"
        },
        zoomSamplesDisable: {
            S: ["zoomVariablesDisable"],
            T: "boolean",
            M: "Zooming and Panning",
            D: "false",
            C: "Flag to disable zooming of samples with mouse wheel in Heatmaps"
        },
        decorationsColor: {
            A: "true",
            T: "color",
            M: "Decorations",
            D: "foreground color",
            C: "Color for the decorations in scatter plots and network graphs"
        },
        sequenceUColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,0,0)",
            C: "Color for the uracils in the genome browser"
        },
        freezeRowTop: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "0",
            C: "Number of rows to freeze at the top of the data table"
        },
        nodeHighlightColor: {
            T: "color",
            M: "Network Graphs",
            D: "rgb(255,0,0)",
            C: "The color for the highlighted nodes."
        },
        oddColor: {
            T: "color",
            M: "Attributes",
            D: "background color",
            C: "The color for the odd numbers in samples or sequences"
        },
        capType: {
            A: "true",
            O: ["butt", "round", "square"],
            T: "option",
            M: "Attributes",
            D: "butt",
            C: "Default type of cap for lines."
        },
        showAnimationFontColor: {
            A: "true",
            T: "color",
            M: "Animation",
            D: "background color",
            C: "Color for the animation text"
        },
        canvasBox: {
            S: ["canvasBoxColor"],
            T: "boolean",
            M: "General",
            D: "true",
            C: "Flag to create a box around the canvas"
        },
        updateCodeDiv: {
            A: "true",
            T: "void",
            M: "Functions",
            C: "Update the code to generate the plot"
        },
        rAxisTicks: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "5",
            C: "Number of ticks in the R axis"
        },
        sortVariablesBySample: {
            S: ["sortDir", "sortVariablesByCategory"],
            T: "array",
            M: "Functions",
            X: "getSamplesAsArray",
            C: "Sort the variables by the value of a sample",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        randomNetwork: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to create or not random network for debug and demonstraion purposes"
        },
        layoutWidth: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Width of the current segment of the canvas when there are multiple graphs."
        },
        histogramBarWidth: {
            A: "true",
            T: "float",
            M: "2D Scatter Plot",
            D: "0.5",
            C: "Length in pixels for half of the bar width in the 2D sccaterplot histogram"
        },
        correlationAxis: {
            O: ["samples", "variables"],
            T: "option",
            M: "Correlation Graphs",
            D: "samples",
            C: "Axis used for the correlation."
        },
        zAxisTransformTicks: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to transform the values of the ticks in the Z axis"
        },
        shadowOffsetX: {
            S: ["showShadow"],
            A: "true",
            T: "integer",
            M: "General",
            D: "3",
            C: "Length in pixels for the shadow offset in the X axis."
        },
        xAxisTicks: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "5",
            C: "Number of ticks in the X axis"
        },
        rAxisTransformTicks: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to transform the values of the ticks in the R axis"
        },
        sequenceZColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the glutamines in the genome browser"
        },
        setMaxY: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Maximum value to set the data in the Y axis"
        },
        skinProperties: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Skins",
            D: ["'skinBackgroundColor'", "'skinBorderColor'", "'skinColor'", "'skinShadowColor'"],
            C: "Properties for the skin"
        },
        ungroupSamples: {
            S: ["groupSamples"],
            T: "void",
            M: "Functions",
            C: "Ungroup samples previously grouped according to a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        legendFontSize: {
            S: ["autoScaleFont", "legendScaleFontFactor"],
            A: "true",
            T: "integer",
            M: "Legends",
            D: "10",
            C: "Font size for the legends. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the legend scaling factor"
        },
        randomDataSamples: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "50",
            C: "Default number of samples when creating random data"
        },
        setMaxR: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Maximum value to set the data in the R axis"
        },
        shapeByShape: {
            A: "true",
            O: ["false", "sphere", "square", "triangle", "star", "rhombus", "octagon", "oval", "plus", "minus", "mdavid"],
            T: "array",
            M: "Scatter and One-D Plots",
            D: "false",
            C: "String that identify the shape to use in multidimensional heatmaps. shapeByData will take precedence over this property."
        },
        indicatorHeight: {
            T: "integer",
            M: "Heatmaps and Networks",
            D: "8",
            C: "Length in pixels for the heatmap indicator"
        },
        marginLeft: {
            T: "integer",
            M: "General",
            D: "0",
            C: "Length in pixels for the left margin in the canvas"
        },
        xAxis2: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            X: "getSamplesAsArray",
            C: "Name of the samples groups or variables to be displayed in the 2nd X axis"
        },
        yAxisTitle: {
            T: "string",
            M: "Axes",
            D: "false",
            C: "Title for the Y axis"
        },
        broadcast: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to enable broadcasting to other canvasXpress objects in the page"
        },
        layoutComb: {
            A: "true",
            T: "boolean",
            M: "Combination Plots",
            D: "false",
            C: "Flag that identify that multiple graphs will be displayed in the canvas."
        },
        eventKeys: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to enable key binding events. This prevent some default browser shortcuts and it is system specific. Please see the Event section bellow."
        },
        yRotate: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "0",
            C: "Number of degrees to rotate graph arround the Y axis"
        },
        smpTitleFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Samples",
            C: "Font for the sample title in one dimensional plots"
        },
        featureTraceTrim: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "1",
            C: "Default triming for nucleotide values in the traces (expressed in percent)"
        },
        segregateVariablesBy: {
            O: ["false", "string"],
            T: "option",
            M: "Data",
            D: "false",
            C: "String to indicate the annotation used to segregate the variables. It must be a category in the 'data.z' object"
        },
        sequenceCColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,255)",
            C: "Color for the cytosines and cysteins in the genome browser"
        },
        nextButton: {
            A: "true",
            T: "image",
            M: "Images",
            D: "fast_forward.png",
            C: "Relative path to an image file to the next button (not including the image directory)"
        },
        yAxisMaxStrLength: {
            Z: "true",
            A: "true",
            T: "string",
            M: "Axes",
            C: "Longest string for ticks in the Y axis"
        },
        showSmpDendrogram: {
            T: "boolean",
            M: "Dendrograms",
            D: "false",
            C: "Flag to show or not the sample dendrogram"
        },
        showAdvancedConfiguration: {
            T: "boolean",
            M: "Events",
            D: "false",
            C: "Flag to show advanced configuration properties."
        },
        disableEvents: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "false",
            C: "Flag to disable all events."
        },
        showVarDendrogram: {
            T: "boolean",
            M: "Dendrograms",
            D: "false",
            C: "Flag to show or not the variable dendrogram"
        },
        freezeColRight: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "0",
            C: "Number of columns to freeze in the right side of the data table"
        },
        pieType: {
            O: ["separated", "solid"],
            T: "option",
            M: "Pie Charts",
            D: "separated",
            C: "Position for the pices of the pie"
        },
        featrureCoordinateHeight: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "12",
            C: "Default size in pixels of the coordinates height"
        },
        fonts: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Text",
            C: "Font name. It will be set depending on the browser. It could be Optimer, Helvetiker, Gentilis or Verdana, sans-serif"
        },
        rAxis: {
            T: "string",
            M: "Circular Graphs",
            D: "false",
            C: "Radial axis for circular plots. It must be the name of a variable"
        },
        smpLabelColor: {
            T: "color",
            M: "Samples",
            D: "foreground color",
            C: "Font color for the sample labels in one dimensional plots"
        },
        remoteDataIndex: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Remote Procedures",
            C: "Index of the canvasXpress object requested"
        },
        reset: {
            T: "void",
            M: "Functions",
            C: "Reset the canvas"
        },
        showDecorations: {
            A: "true",
            T: "boolean",
            M: "Decorations",
            D: "false",
            C: "Flag to show or not extra decorations like (regression lines, splines, etc) in scatter plots and (heatmaps, pie charts or stacked bar graphs in) network graphs"
        },
        approximateNodePositions: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to force approximate X, Y node positions."
        },
        heatmapType: {
            O: ["blue", "blue-green", "blue-red", "blue-yellow", "blue-cyan", "blue-purple", "green", "green-blue", "green-red", "green-yellow", "green-cyan", "green-purple", "red", "red-blue", "red-green", "red-yellow", "red-cyan", "red-purple", "yellow", "yellow-green", "yellow-red", "yellow-yellow", "yellow-cyan", "yellow-purple", "cyan", "cyan-green", "cyan-red", "cyan-cyan", "cyan-cyan", "cyan-purple", "purple", "purple-green", "purple-red", "purple-purple", "purple-cyan", "purple-purple"],
            T: "option",
            M: "Heatmaps and Networks",
            D: "blue-red",
            C: "Color shades for the heatmap. It could be red, blue, green, yellow, cyan, purple or any combination of two colors separated by a dash"
        },
        citationScaleFontFactor: {
            T: "float",
            M: "Titles",
            D: "1",
            C: "Scaling factor used to increase or decrease citation font size in the canvas"
        },
        zoomVariablesDisable: {
            S: ["zoomSamplesDisable"],
            T: "boolean",
            M: "Zooming and Panning",
            D: "false",
            C: "Flag to disable zooming of variables with mouse wheel in Heatmaps"
        },
        hideInfoDiv: {
            A: "true",
            T: "void",
            M: "Functions",
            C: "Hide additional information"
        },
        smpTitleScaleFontFactor: {
            T: "float",
            M: "Samples",
            D: "1",
            C: "Scaling factor used to increse or decrease sample title font size in the canvas"
        },
        xAxisTickStyle: {
            A: "true",
            O: ["solid", "dotted"],
            T: "option",
            M: "Axes",
            D: "solid",
            C: "Style for the tick lines in the X axis"
        },
        axisExact: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to force exact values for the data"
        },
        monitorCanvasXpressZombiesTime: {
            A: "true",
            T: "integer",
            M: "Events",
            D: "30000",
            C: "Time in milliseconds to wait between checking for canvasXpress zombies"
        },
        subtitle: {
            S: ["subtitleHeight", "subtitleColor"],
            T: "string",
            M: "Titles",
            D: "rgb(0,0,0)",
            C: "Title of the graph."
        },
        selectDataPoint: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Scatter Plots",
            D: "[]",
            C: "Ids of data points (in the data object) to select."
        },
        animationType: {
            A: "true",
            O: ["grow", "spring", "random"],
            T: "option",
            M: "Animation",
            D: "grow",
            C: "Type of animation"
        },
        showErrorBars: {
            T: "boolean",
            M: "Data",
            D: "true",
            C: "Flag to indicate whether to show or not error bars in the graphs."
        },
        autoAdjustXTries: {
            Z: "true",
            T: "integer",
            M: "General",
            C: "Counter to try to automaticaly adjust the horizontal size of the canvas when autoAdjust is true"
        },
        margin: {
            T: "integer",
            M: "General",
            D: "5",
            C: "Length in pixels for the distance between many areas in the graphs"
        },
        colorEdgeBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to color the edges."
        },
        xAxisMaxStrLength: {
            Z: "true",
            A: "true",
            T: "string",
            M: "Axes",
            C: "Longest string for ticks in the X axis"
        },
        acknowledgementIconPosition: {
            O: ["outside", "inside"],
            T: "option",
            M: "General",
            D: "outside",
            C: "Acknowledge canvasXpress icon position"
        },
        broadcastType: {
            A: "true",
            O: ["var", "comb"],
            T: "option",
            M: "Events",
            D: "var",
            C: "Model for broadcasting to identify either variables or a combination of variable and samples"
        },
        autoAdjustYTries: {
            Z: "true",
            T: "integer",
            M: "General",
            C: "Counter to try to automaticaly adjust the vertical size of the canvas when autoAdjust is true"
        },
        segregateSamplesBy: {
            O: ["false", "string"],
            T: "option",
            M: "Data",
            D: "false",
            C: "String to indicate the annotation used to segregate the samples. It must be a category in the 'data.x' object"
        },
        print: {
            T: "void",
            M: "Functions",
            C: "Save the current parameters for a remote data set. @param {void} saveRemoteParameters"
        },
        backgroundType: {
            S: ["backgroundImage", "gradientOrientation", "backgroundGradient1Color", "backgroundGradient2Color"],
            O: ["solid", "gradient", "window", "windowGradient", "windowGradient2", "windowSolidGradient", "image", "windowImage"],
            T: "option",
            M: "General",
            D: "solid",
            C: "Type of background for the canvas. The canvas may have a window for plotting the data which may be a gradient, a solid pattern or an image."
        },
        maxSmpStringLen: {
            T: "integer",
            M: "Samples",
            D: "50",
            C: "Maximum length in characters a sample label or description can have so anything above is truncated."
        },
        showAnimationFontSize: {
            A: "true",
            T: "integer",
            M: "Animation",
            D: "10",
            C: "Size in pixels for the font size of text involved in the animation"
        },
        axisExtension: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "0.1",
            C: "Percentage to extend the values in the data"
        },
        autoAdjust: {
            A: "true",
            T: "boolean",
            M: "General",
            D: "true",
            C: "Flag to automaticaly adjust the size of the canvas in most visualizations. If set to 'false' you can easily adjust the rows and columns in the heatmap visualizations"
        },
        sequenceMColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,103,0)",
            C: "Color for the degenerate A/G and methionines in the genome browser"
        },
        dockable: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to disable docking of data table filters and configurator in the canvas"
        },
        randomDataVariableAnnotations: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "2",
            C: "Default number of variable annotations when creating random data"
        },
        xAxis2AbsMin: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Minimum unfiltered value for the 2nd X axis"
        },
        subNetworks: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Network Graphs",
            C: "Array to keep independent networks"
        },
        showInfoDiv: {
            A: "true",
            T: "void",
            M: "Functions",
            C: "Show additional information"
        },
        yAxisAbsMin: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Minimum unfiltered value for the Y axis"
        },
        blockContrast: {
            T: "boolean",
            M: "One dimentional plots",
            D: "false",
            C: "A flag to creates a shade between the samples so there are two backgrounds, one for the odd samples and one for the even samples."
        },
        xAxisExact: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to force exact values for the data in the X axis"
        },
        legendBox: {
            S: ["legendBoxColor", "legendBackgroundColor"],
            T: "boolean",
            M: "Legends",
            D: "true",
            C: "Flag to create a box around the legend"
        },
        showDataTable: {
            A: "true",
            T: "boolean",
            M: "Data table",
            D: "false",
            C: "Flag to indicate to show the data table"
        },
        remoteService: {
            A: "true",
            T: "url",
            M: "Remote Procedures",
            D: "false",
            C: "Url used to obtain data remotely. It expects and array of canvasXpress objects"
        },
        randomDataVariables: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "50",
            C: "Default number of variables when creating random data"
        },
        gradientRatio: {
            S: ["gradientType"],
            A: "true",
            T: "float",
            M: "General",
            D: "1.3",
            C: "Ratio used to generate the linear gradients applied to all elements in the visualizations"
        },
        decorationFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Decorations",
            C: "Font for the decoration in scatter plots and network graphs"
        },
        playButton: {
            A: "true",
            T: "image",
            M: "Images",
            D: "play.png",
            C: "Relative path to an image file to the play button (not including the image directory)"
        },
        varOverlayRecycleColors: {
            T: "boolean",
            M: "Overlays",
            D: "false",
            C: "Flag to indicate to recycle variable overlay colors with each overlay"
        },
        sequenceRColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,0,0)",
            C: "Color for the degenerate A/G and arginines in the genome browser"
        },
        zAxisShow: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to show on not the values of the ticks in the Z axis"
        },
        dotPlotDataPointRatio: {
            S: ["showBoxplotOriginalData", "dotPlotDataPointTransparency"],
            A: "true",
            T: "float",
            M: "Dot Plots",
            D: "2",
            C: "Ratio to adjust the size of the data points when displaying original data in boxplots. The higher the number the smaller the data points"
        },
        smpOverlays: {
            T: "array",
            M: "Overlays",
            X: "getXData",
            D: "[]",
            C: "Sample annotations included in the 'data.x' object used in one dimensional plots"
        },
        sequenceNColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the degenerate A/C/G/T and asparagines in the genome browser"
        },
        translateY: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Amount to translate for the Y axis."
        },
        axisTitleFontSize: {
            S: ["autoScaleFont", "axisTitleScaleFontFactor"],
            A: "true",
            T: "integer",
            M: "Ticks and Axis Titles",
            D: "10",
            C: "Font size for the axis titles in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the axis title scaling factor"
        },
        draw: {
            T: "void",
            M: "Functions",
            C: "Redraw the canvas",
            U: {
                Network: "true"
            }
        },
        featureNameFontSize: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "8",
            C: "Size in pixels for the font size of text of the features in the genome browser"
        },
        xAxisTickFormat: {
            A: "true",
            T: "string",
            M: "Axes",
            D: "false",
            C: "Format for the tick values in the X axis"
        },
        sequenceFColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,255)",
            C: "Color for the phenylalanines in the genome browser"
        },
        addRegressionLine: {
            T: "void",
            M: "Functions",
            C: "Add regression line(s) to a 2D-Scatter plot",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Scatter3D: "true"
            }
        },
        varLabelColor: {
            T: "color",
            M: "Variables",
            D: "foreground color",
            C: "Font color for the variable labels in one dimensional plots"
        },
        nodeSize: {
            T: "integer",
            M: "Network Graphs",
            D: "10 | 20",
            C: "Length in pixels for the size of the nodes in the network"
        },
        maxRows: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "10",
            C: "Maximum number of rows to display in the data table"
        },
        yAxisShow: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to show on not the values of the ticks in the Y axis"
        },
        zAxisMinorTicks: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "A flag to show minor tick lines in the Z axis"
        },
        destroyCanvasXpressZombies: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to destroy canvasXpress objects stored in the references array when they are no longer part of the DOM. This may happen when canvasXpress is used in other JS frameworks and the objects are not destroyed by the developer"
        },
        axisTickFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Ticks and Axis Titles",
            C: "Font for the axis ticks in one and two dimensional plots"
        },
        baseline: {
            A: "true",
            O: ["top", "middle", "bottom"],
            T: "option",
            M: "Text",
            D: "right",
            C: "Default vertical alignment for drawing text."
        },
        smpDendrogramPosition: {
            T: "option",
            M: "Dendrograms",
            D: "left",
            C: "Position for the sample dendrogram in the plot. It could be top, bottom, right or left depending on the orientation of the graph."
        },
        is3DPlot: {
            T: "boolean",
            M: "One dimentional plots",
            D: "false",
            C: "Flag to create or not a 3D plot"
        },
        removeHistogram: {
            T: "void",
            M: "Functions",
            C: "Remove histogram from a 2D-Scatter plot",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Scatter3D: "true"
            }
        },
        createRandomData: {
            T: "void",
            M: "Functions",
            C: "Create a random data set"
        },
        yAxisMinorTicks: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "A flag to show minor tick lines in the Y axis"
        },
        helpKeyEvents: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to enable help on key events."
        },
        remoteUpdate: {
            A: "true",
            T: "boolean",
            M: "Remote Procedures",
            D: "false",
            C: "Flag to indicate that the file to get the data needs to be updated"
        },
        shadowOffsetY: {
            S: ["showShadow"],
            A: "true",
            T: "integer",
            M: "General",
            D: "3",
            C: "Length in pixels for the shadow offset in the Y axis."
        },
        varSort: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Data",
            C: "Variable index used in sorting the data."
        },
        yAxisTicks: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "5",
            C: "Number of ticks in the Y axis"
        },
        decorations: {
            A: "true",
            T: "array",
            M: "Decorations",
            D: "[]",
            C: "Name of the node properties to include in the network decorations in the 'data.nodes' object"
        },
        showCode: {
            A: "true",
            T: "boolean",
            M: "Debug",
            D: "false",
            C: "Flag to show code for the canvas."
        },
        autoHideOnDecorationsCenter: {
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to hide node when decorations are positioned on the center"
        },
        colors: {
            S: ["colorScheme"],
            T: "array",
            M: "Attributes",
            D: "colors",
            C: "Colors."
        },
        showSampleNames: {
            T: "boolean",
            M: "Samples",
            D: "true",
            C: "Flag to show the sample names in one dimensional plots."
        },
        panningX: {
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            D: "0",
            C: "Number of unit to pan the network in the X dimension"
        },
        yAxisCurrent: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "0",
            C: "Index of the sample that is currently displayed displayed in the Y axis"
        },
        shadowColor: {
            S: ["showShadow"],
            A: "true",
            T: "color",
            M: "General",
            D: "rgba(0,0,0,0.5)",
            C: "Color for the shadow."
        },
        showCodeDiv: {
            A: "true",
            T: "void",
            M: "Functions",
            C: "Show the code for the plot"
        },
        dendrogramSpace: {
            T: "integer",
            M: "Dendrograms",
            D: "6",
            C: "Length in pixels to space the branches in the dendrograms."
        },
        addNormalDistributionLine: {
            T: "void",
            M: "Functions",
            C: "Add a normaldistribution line(s) to a 2D-Scatter plot",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Scatter3D: "true"
            }
        },
        kmeansSamples: {
            S: ["kmeansClusters", "maxIterations"],
            T: "void",
            M: "Functions",
            C: "Cluster samples using kmeans",
            U: {
                StackedPercent: "true",
                Bar: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        eventArrowKeys: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "true",
            C: "Flag to enable arrow key binding events."
        },
        maxTextSize: {
            A: "true",
            T: "integer",
            M: "Text",
            D: "14",
            C: "Maximum size for any text in the canvas."
        },
        skinHighlight: {
            Z: "true",
            A: "true",
            T: "color",
            M: "Skins",
            C: "Color for the highlight skin automatically calculated"
        },
        xAxisTitle: {
            T: "string",
            M: "Axes",
            D: "false",
            C: "Title for the X axis"
        },
        functionIntervals: {
            A: "true",
            T: "integer",
            M: "2D Scatter Plot",
            D: "20",
            C: "Number of intervals to use when drawing functions in the decorations"
        },
        gradient: {
            S: ["gradientType"],
            A: "true",
            T: "boolean",
            M: "General",
            D: "false",
            C: "Flag used to apply gradients to all elements ploted in the visualizations according to their corresponding color"
        },
        genomeResolution: {
            Z: "true",
            A: "true",
            O: ["low", "medium", "high"],
            T: "option",
            M: "Genome Browser",
            C: "Number to adjust the splines curvature"
        },
        maxCols: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "8",
            C: "Maximum number of columns to display in the data table"
        },
        rAxisAbsMax: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Maximum unfiltered value for the R axis"
        },
        sma5Color: {
            T: "color",
            M: "Candlestick Plots",
            D: "rgb(255,0,0)",
            C: "The color for the 5 day single moving average"
        },
        nodeFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Network Graphs",
            C: "Font for the text in networks"
        },
        x3DRatio: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "1",
            C: "Value between 0 - 1 for adjusting the 3D of the X Axis"
        },
        disableConfigurator: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "false",
            C: "Flag to disable configurator."
        },
        colorHSV: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Attributes",
            C: "Color HSV. Hue, Saturation and Value used in the configurator"
        },
        sequenceIColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,103,0)",
            C: "Color for the isoleucines in the genome browser"
        },
        smpTitle: {
            T: "string",
            M: "Samples",
            D: "false",
            C: "Title for the sample axis in one dimensional plots"
        },
        correlationAnchorLegendAlignWidth: {
            A: "true",
            T: "integer",
            M: "Correlation Graphs",
            D: "40",
            C: "Length in pixels of the height of the correlation anchor legend"
        },
        shapeEdgeBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to shape the nods."
        },
        xAxis2MaxStrLength: {
            Z: "true",
            A: "true",
            T: "string",
            M: "Axes",
            C: "Longest string for ticks in the 2nd X axis"
        },
        show3DGrid: {
            A: "true",
            T: "boolean",
            M: "3D Scatter Plot and Networks",
            D: "true",
            C: "Flag to show the X,Y,Z grid in scatter 3D plots"
        },
        randomNetworkNodes: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "50",
            C: "Default number of nodes when creating random networks"
        },
        codeType: {
            A: "true",
            O: ["pretty", "compact", "tab"],
            T: "option",
            M: "Debug",
            D: "pretty",
            C: "Output type for the JSON code"
        },
        xAxis2MinorValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the minor ticks in the 2nd X axis"
        },
        fontName: {
            A: "true",
            O: ["Gentilis", "Helvetiker", "Optimer", "Verdana, sans-serif"],
            T: "font",
            M: "Text",
            D: "Verdana, sans-serif",
            C: "Font name. It will be set depending on the browser. It could be Optimer, Helvetiker, Gentilis or Verdana, sans-serif"
        },
        smpLabelInterval: {
            A: "true",
            T: "integer",
            M: "Samples",
            D: "1",
            C: "Interval for the sample labels in one dimensional plots"
        },
        rAxisTitle: {
            T: "string",
            M: "Axes",
            D: "false",
            C: "Title for the R axis"
        },
        dataTableColumnWidth: {
            Z: "true",
            T: "array",
            M: "Data table",
            C: "Initialize configurations"
        },
        highlightSmp: {
            T: "array",
            M: "Samples",
            X: "getSamplesAsArray",
            D: "[]",
            C: "Name of samples in the 'data.y' object to highlight."
        },
        decorationsHeight: {
            A: "true",
            T: "integer",
            M: "Decorations",
            D: "20",
            C: "Length in pixels of the height for the decorations in the networks"
        },
        donutProportion: {
            T: "float",
            M: "Circular Graphs",
            D: "0.3",
            C: "Proportion of the center of the circular graph to use as void"
        },
        sequenceBColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the degenerate C/G/T and asparagines in the genome browser"
        },
        segregateVariables: {
            S: ["segregateVariables"],
            T: "option",
            M: "Functions",
            X: "getZData",
            C: "Segregate variables based on a variable category (data.z object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        coordinateLineColor: {
            T: "boolean",
            M: "Line Graphs",
            D: "true",
            C: "Flag to used same color in BarLine plots. If set to true the color of the bars and the lines will be the same"
        },
        dendrogramColor: {
            T: "color",
            M: "Dendrograms",
            D: "rgb(204,204,204)",
            C: "The color for the dendrograms"
        },
        sequenceQColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the glutamines in the genome browser"
        },
        layoutAxis: {
            Z: "true",
            A: "true",
            O: ["1", "2", "3"],
            T: "option",
            M: "Combination Plots",
            C: "Flag to indicated whether to print axes values when multiple graphs are displayed in the canvas. The possible values are: 1: horizontal, 2: vertical, 3: both"
        },
        smpIndicesStart: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Heatmaps",
            C: "Number that indicates starting point for samples in heatmaps when the canvas is zoom in."
        },
        xAxisCurrent: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "0",
            C: "Index of the sample that is currently displayed displayed in the X axis"
        },
        zAxisCurrent: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "0",
            C: "Index of the sample that is currently displayed displayed in the Z axis"
        },
        nodeScaleFontFactor: {
            T: "float",
            M: "Network Graphs",
            D: "1",
            C: "Scaling factor used to increse or decrease network text font size in the canvas."
        },
        evenColor: {
            T: "color",
            M: "Attributes",
            D: "rgb(240,240,240)",
            C: "The color for the even numbers in samples or sequences"
        },
        backgroundWindowGradient2Color: {
            S: ["backgroundType"],
            A: "true",
            T: "color",
            M: "General",
            D: "rgb(0,0,36)",
            C: "The second color of the gradient if the background is a type of window gradient."
        },
        showLevelOverlays: {
            T: "boolean",
            M: "Overlays",
            D: "true",
            C: "Flag to indicate to show or not the level overlays in one dimensional plots"
        },
        startPieSectors: {
            T: "float",
            M: "Pie Charts",
            D: "0",
            C: "Starting degrees for pie sectors. 0 is equivalent to 3:00 oclock"
        },
        legendBoxColor: {
            S: ["legendBox"],
            T: "color",
            M: "Legends",
            D: "rgb(0,0,0)",
            C: "Color for the box around the legend"
        },
        rotationSensitivity: {
            A: "true",
            T: "integer",
            M: "3D Scatter Plot and Networks",
            D: "45",
            C: "Factor to adjust the sensitivity of the mouse when rotating the  graph"
        },
        selectDataMode: {
            O: ["area", "name"],
            T: "option",
            M: "Scatter Plots",
            D: "area",
            C: "Type of mode to highliht selected data points"
        },
        font: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Text",
            D: "Verdana, sans-serif 12pt",
            C: "The combination of font name style and size."
        },
        skipClick: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            C: "Flag to skip click events after a mouse down event in the networks when the eventModel is global"
        },
        trackNameFontColor: {
            T: "color",
            M: "Genome Browser",
            D: "background color",
            C: "Color for the text of the tracks in the genome browser"
        },
        rAxisTransform: {
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile"],
            T: "option",
            M: "Axes",
            D: "false",
            C: "Tranformation for the values in the R axis."
        },
        scaleTextConstantMult: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Text",
            D: "40",
            C: "Constants to autoscale text"
        },
        varLabelDescription: {
            T: "string",
            M: "Variables",
            D: "false",
            C: "Variable label description is a valid sample classification included in the 'data.z' object used in heatmaps"
        },
        images: {
            S: ["scatterType"],
            A: "true",
            T: "array",
            M: "Attributes",
            D: "[]",
            C: "Array of urls of images used in scatter plots."
        },
        linkage: {
            S: ["distance", "clusterAxis", "imputeMethod", "centerData", "clusterSamples", "clusterVariables"],
            O: ["single", "complete", "average"],
            T: "option",
            M: "Clustering",
            D: "single",
            C: "Linkage type to use when clustering data."
        },
        smpLabelDescription: {
            T: "string",
            M: "Samples",
            D: "false",
            C: "Sample label description is a valid sample classification included in the 'data.x' object used in heatmaps"
        },
        sequenceStartColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,255,0)",
            C: "Color for the start codon in the genome browser"
        },
        backgroundGradient1Color: {
            S: ["backgroundType", "backgroundGradient2Color"],
            T: "color",
            M: "General",
            D: "rgb(0,0,200)",
            C: "The first color of the gradient if the background is a type of gradient."
        },
        smpLabelFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Samples",
            C: "Font for the sample labels in one dimensional plots"
        },
        timeValueIndices: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Array containig the indices of the values when the the graph is a time series"
        },
        legendColor: {
            T: "color",
            M: "Legends",
            D: "foregroung color",
            C: "Color for the legends"
        },
        layoutAdjust: {
            A: "true",
            T: "boolean",
            M: "Combination Plots",
            D: "false",
            C: "Flag to force recalculating the ranges in the axes when multiple graphs are displayed in the canvas."
        },
        featureNameFontColor: {
            T: "color",
            M: "Genome Browser",
            D: "background color",
            C: "Color for the text of the features in the genome browser"
        },
        isSelectNodes: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "0",
            C: "Number of selected nodes (in the data object)."
        },
        varHighlightColor: {
            T: "color",
            M: "Variables",
            D: "rgb(255,0,0)",
            C: "The color for the highlighted variables."
        },
        startRow: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data table",
            C: "Starting row in the data table"
        },
        remoteAutoPlayDelay: {
            A: "true",
            T: "integer",
            M: "Remote Procedures",
            D: "3000",
            C: "Time in milliseconds to wait between iterations over remote data sets"
        },
        kmeansClusters: {
            S: ["maxIterations", "kmeansSamples", "kmeansVariables"],
            T: "integer",
            M: "Clustering",
            D: "3",
            C: "Number of clusters when clustering data with kmeans."
        },
        lines: {
            Z: "true",
            A: "true",
            O: ["", "dashed", "dotted", "bezierY", "bezierX", "curved + arrow", "arrowHead", "arrowTail", "arrowHeadSquareTail", "arrowTailSquareHead", "square", "squareHead", "squareTail", "squareHeadArrowTail", "squareTailArrowHead"],
            T: "array",
            M: "Attributes",
            C: "Line types available network graphs The patterns can be: '', 'dashed', 'dotted', 'bezierY', 'bezierX' and 'curved'. The end could be: 'arrow', 'arrowHead', 'arrowTail', 'arrowHeadSquareTail', 'arrowTailSquareHead', 'square', 'squareHead', 'squareTail', 'squareHeadArrowTail' or 'squareTailArrowHead'."
        },
        varTitleScaleFontFactor: {
            T: "float",
            M: "Variables",
            D: "1",
            C: "Scaling factor used to increse or decrease variable font size in the canvas."
        },
        xAxis2MinorTicks: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "A flag to show minor tick lines in the 2nd X axis"
        },
        showPieGrid: {
            T: "float",
            M: "Pie Charts",
            D: "true",
            C: "A flag to show the labels for the grid when plotting multiple pies"
        },
        sequenceHColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,0,0)",
            C: "Color for the degenerate A/C/T and histidines in the genome browser"
        },
        acknowledgementIcon: {
            O: ["cx.png", "cxn.png"],
            T: "option",
            M: "General",
            D: "cx.png",
            C: "Acknowledge canvasXpress icon"
        },
        timeFormat: {
            A: "true",
            O: ["default", "shortDate", "mediumDate", "longDate", "fullDate", "shortTime", "mediumTime", "longTime", "isoDate", "isoTime", "isoDateTime", "isoUtcDateTime"],
            T: "option",
            M: "Attributes",
            D: "isoDate",
            C: "Time Format according to date.format.js Steven Levithan <stevenlevithan.com>"
        },
        networkStackStates: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "5",
            C: "Number of states to keep in the network stack after a drag or move"
        },
        sequenceEColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the glutamic acids in the genome browser"
        },
        hideCodeDiv: {
            A: "true",
            T: "void",
            M: "Functions",
            C: "Hide the code for the plot"
        },
        trackNameFontSize: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "10",
            C: "Size in pixels for the font size of text of the tracks in the genome browser"
        },
        sequenceEndColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,0,0)",
            C: "Color for the end codon in the genome browser"
        },
        dropdownButton: {
            A: "true",
            T: "image",
            M: "Images",
            D: "menu_dropdown.png",
            C: "Relative path to an image file to the drop down button (not including the image directory)"
        },
        legendFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Legends",
            C: "Font for the legends"
        },
        randomDataSampleAnnotationRatio: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "2",
            C: "Approximate number of classes in each sample annotation when creating random data"
        },
        xAxis2Values: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the ticks in the 2nd X axis"
        },
        freezeRowBottom: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "0",
            C: "Number of rows to freeze at the bottom of the data table"
        },
        xAxisTransformTicks: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to transform the values of the ticks in the X axis"
        },
        overrideEventlessNodes: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to override nodes that do not take events to be able to edit them"
        },
        legendScaleFontFactor: {
            T: "float",
            M: "Legends",
            D: "1",
            C: "Scaling factor used to increse or decrease legend font size in the canvas."
        },
        tmpAsciiArray: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Data",
            C: "A temporary array to enable sorting data asciibetically."
        },
        sma50Color: {
            T: "color",
            M: "Candlestick Plots",
            D: "rgb(0,0,0)",
            C: "The color for the 50 day single moving average"
        },
        areaIsCumulative: {
            T: "boolean",
            M: "Area Graphs",
            D: "false",
            C: "Flag to treat area graphs as cumulative values"
        },
        stopButton: {
            A: "true",
            T: "image",
            M: "Images",
            D: "stop.png",
            C: "Relative path to an image file to the stop button (not including the image directory)"
        },
        trackNameFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Genome Browser",
            C: "Font for the text of the tracks in the genome browser"
        },
        randomData: {
            A: "true",
            T: "boolean",
            M: "Data",
            D: "false",
            C: "Flag to create or not random data for debug and demonstraion purposes"
        },
        networkDivisions: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Network Graphs",
            C: "Number of angular divisions in the radial network."
        },
        resizerDraw: {
            A: "true",
            T: "boolean",
            M: "Axis Resizer",
            D: "true",
            C: "Flag to make the axis resizers draw the canvas as they move"
        },
        temperature: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "0",
            C: "Temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified"
        },
        indicatorWidth: {
            T: "integer",
            M: "Heatmaps and Networks",
            D: "1",
            C: "Length in pixels for the heatmap indicator line width used for increase the size of the indicator"
        },
        panningStep: {
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            D: "0.2",
            C: "Percentage step for panning networks."
        },
        featureTypeDefault: {
            O: ["box", "bar", "heatmap", "sequence", "triangle", "line"],
            T: "option",
            M: "Genome Browser",
            D: "line",
            C: "Default type for the feature in the genome browser"
        },
        sequenceFontSize: {
            A: "true",
            T: "integer",
            M: "Genome Browser",
            D: "10",
            C: "Size in pixels for the font size of text of the sequence in the genome browser"
        },
        zAxisValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the ticks in the Z axis"
        },
        allVsAllType: {
            O: ["both", "upper", "lower"],
            T: "option",
            M: "2D Scatter Plot",
            D: "both",
            C: "Type for the n-1 x n-1 matrix of 2D sccaterplots"
        },
        overlayFontSize: {
            A: "true",
            T: "integer",
            M: "Overlays",
            D: "6",
            C: "Font size for the overlays in one dimensional plots"
        },
        backgroundWindowGradientOrientation: {
            S: ["backgroundType"],
            A: "true",
            O: ["vertical", "horizontal"],
            T: "string",
            M: "General",
            D: "vertical",
            C: "The orientation for the gradient if the background type is windowGradient or windowGradient2."
        },
        yAxisTransformTicks: {
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "Flag to transform the values of the ticks in the Y axis"
        },
        zAxisTransform: {
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile"],
            T: "option",
            M: "Axes",
            D: "false",
            C: "Tranformation for the values in the Z axis."
        },
        isCreateHistogram: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "2D Scatter Plot",
            D: "false",
            C: "Flag to indicate there is a histogram"
        },
        rAxisValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the ticks in the R axis"
        },
        autoScaleFont: {
            S: ["smpLabelFontSize", "varLabelFontSize", "legendFontSize", "axisTickFontSize", "axisTitleFontSize"],
            A: "true",
            T: "boolean",
            M: "Text",
            D: "true",
            C: "Flag to automatically adjust the font size in many visualization. Please be aware that scaling factors can still modify the font size. This flag needs to be false for the text to accept the specified font size."
        },
        varIndicesStart: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Heatmaps",
            C: "Number that indicates starting point for variables in heatmaps when the canvas is zoom in."
        },
        backgroundGradient2Color: {
            S: ["backgroundType", "backgroundGradient1Color"],
            T: "color",
            M: "General",
            D: "rgb(0,0,36)",
            C: "The second color of the gradient if the background is a type of gradient."
        },
        smpLabelCircular: {
            T: "boolean",
            M: "Samples",
            D: "false",
            C: "Flag to show the sample names in a circular orientation in circular plots."
        },
        dataFilterWidth: {
            A: "true",
            T: "integer",
            M: "Events",
            D: "300",
            C: "Size in pixels for the data filters."
        },
        transparency: {
            A: "true",
            T: "float",
            M: "General",
            D: "null",
            C: "Percentage of transparency applied to all elements in the visualiztionss"
        },
        useSmpVarIndexOnClustering: {
            T: "boolean",
            M: "Clustering",
            D: "false",
            C: "Flag to indicate to use variable or sample index rather than names when clustering. This allows to use '(', ')' and ':' in the variable or sample name"
        },
        zAxisTickColor: {
            T: "color",
            M: "Axes",
            D: "rgb(204,204,204)",
            C: "Color for the tick lines in the Z axis"
        },
        transform: {
            S: ["transformType", "transformBase", "ratioReference", "zscoreAxis"],
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "save", "reset", "undo"],
            T: "option",
            M: "Functions",
            C: "Transform all the data. Warning: the option 'save' overwrites the original data",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        transformType: {
            O: ["false", "log2", "log10", "exp2", "exp10", "percentile", "zscore", "ratio", "ratio2", "ratio10", "save", "reset", "undo"],
            T: "option",
            M: "Data",
            D: "false",
            C: "Default transformation type."
        },
        timeValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Array containig the tick values when the the graph is a time series"
        },
        sequenceKColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,0,0)",
            C: "Color for the degenerate G/T and lysines in the genome browser"
        },
        backgroundWindowGradient1Color: {
            S: ["backgroundType"],
            A: "true",
            T: "color",
            M: "General",
            D: "rgb(0,0,200)",
            C: "The first color of the gradient if the background is a type of window gradient."
        },
        maxFeatureStringLen: {
            T: "integer",
            M: "Genome Browser",
            D: "50",
            C: "Maximum length in characters a feature label can have so anything above is truncated."
        },
        yAxis: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            X: "getSamplesAsArray",
            C: "Name of the samples groups or variables to be displayed in the Y axis"
        },
        setMinX: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Minimum value to set the data in the X axis"
        },
        sizeBy: {
            O: ["false", "variable"],
            T: "option",
            M: "Scatter and One-D Plots",
            X: "getXZData",
            D: "false",
            C: "Name of a variable annotation or a sample name or the string 'variable' to size the variables."
        },
        featureTranslateShow: {
            T: "boolean",
            M: "Genome Browser",
            D: "true",
            C: "Flag use to show tranlation"
        },
        varTitleFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Variables",
            C: "Font for the variable titles in one dimensional plots"
        },
        preScaleNetwork: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to prescale or not the network. This is a aesthetic parameter to make the graph look nicer... Sometimes..."
        },
        sequencePColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(255,165,0)",
            C: "Color for the prolines in the genome browser"
        },
        isHistogram: {
            A: "true",
            T: "boolean",
            M: "2D Scatter Plot",
            D: "false",
            C: "Flag to convert the 2D scatter plot into a histogram. That is, the points in the scatter plot are converted to bars that start at the bottom of the Y axis. It is useful to represent proteomics spectra or histograms."
        },
        xRotate: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "45",
            C: "Number of degrees to rotate graph arround the X axis"
        },
        indicatorCenter: {
            O: ["white", "black", "rainbow", "rainbow-red", "rainbow-green"],
            T: "option",
            M: "Heatmaps and Networks",
            D: "white",
            C: "Color for the center of the heatmap indicator. If rainbow-red is specified the order of the colors to generate the gradient will be: red - blue - green. If rainbow-green is specified then the order of the colors to generate the gradient will be: green - blue - red. The option rainbow is an alias for rainbow-red."
        },
        showLegend: {
            T: "boolean",
            M: "Legends",
            D: "true",
            C: "Flag to show or not the legend in the graphs"
        },
        weight: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Fraction of the canvas to be used (a value between 0 and 1). Used when multiple graphs are displayed in one canvas. Could be an number or an array of numbers."
        },
        sequenceYColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,255)",
            C: "Color for the degenerate C/T and tyrosines in the genome browser"
        },
        histogramBins: {
            A: "true",
            T: "integer",
            M: "2D Scatter Plot",
            D: "20",
            C: "Number of bins in histogram"
        },
        yAxisTickStyle: {
            A: "true",
            O: ["solid", "dotted"],
            T: "option",
            M: "Axes",
            D: "solid",
            C: "Style for the tick lines in the Y axis"
        },
        networkFreeze: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to prevent autoscaling for the network layout."
        },
        varTitle: {
            T: "integer",
            M: "Variables",
            D: "10",
            C: "Title for the sample axis in one dimensional plots"
        },
        stockIndicators: {
            O: ["Sma5", "Sma10", "Sma20", "Sma25", "Sma50"],
            T: "array",
            M: "Candlestick Plots",
            D: "[]",
            C: "Stock technical indicators"
        },
        colorNodeBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to color the nodes."
        },
        showPieSampleLabel: {
            T: "boolean",
            M: "Pie Charts",
            D: "true",
            C: "A flag to show the sample label when plotting mutliple pies"
        },
        backgroundImage: {
            S: ["backgroundType"],
            T: "url",
            M: "General",
            D: "false",
            C: "Url for the background image"
        },
        minTextSize: {
            A: "true",
            T: "integer",
            M: "Text",
            D: "4",
            C: "Minimum size for any text in the canvas."
        },
        isBoxPlotCalc: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data",
            C: "Flag to indicate if the iqr has been calculated if the graph type is Boxplot."
        },
        pieSegmentSeparation: {
            T: "integer",
            M: "Pie Charts",
            D: "3",
            C: "Length in pixels for the separation of the pieces of the pie charts"
        },
        blockFactor: {
            S: ["autoAdjust", "blockSeparationFactor"],
            A: "true",
            T: "int",
            M: "One dimentional plots",
            D: "1",
            C: "Factor to adjust the size of the sample blocks in the one dimensional graphs. The default is 1. If you want to make the blocks wider then increase this parameter (2 is twice as big). This only works if the auto adjust property is set to 'false'"
        },
        timeTicksFirst: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "false",
            C: "Flag to indicate whether to use the first date on a time graph or the last"
        },
        zAxisMinorValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the minor ticks in the Z axis"
        },
        dotLength: {
            A: "true",
            T: "integer",
            M: "Attributes",
            D: "1",
            C: "Size in pixels of the length between dots in the doted lines."
        },
        remoteParams: {
            A: "true",
            T: "object",
            M: "Remote Procedures",
            D: "{}",
            C: "Object to hold parameters used to obtain data remotely. The target property will be always added to the method as well as the direction [next|prev] (see below."
        },
        smpHighlightColor: {
            T: "color",
            M: "Samples",
            D: "rgb(255,0,0)",
            C: "The color for the higlighted samples."
        },
        network2DRotate: {
            Z: "true",
            A: "true",
            T: "integer",
            M: "Network Graphs",
            C: "Number of degrees to rotate network arround the X axis"
        },
        arrowPointSize: {
            A: "true",
            T: "integer",
            M: "Attributes",
            D: "10",
            C: "Size in pixels of the arrow head in arrow lines."
        },
        clusterSamples: {
            S: ["distance", "linkage", "clusterAxis", "imputeMethod", "centerData"],
            T: "void",
            M: "Functions",
            C: "Cluster samples based on data and generate a dendrogram on the sample axis. It takes no parameters",
            U: {
                StackedPercent: "true",
                Bar: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        yAxisValues: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            C: "Values for the ticks in the Y axis"
        },
        sequenceFill: {
            T: "color",
            M: "Genome Browser",
            D: "false",
            C: "Color for the background when showing sequnces in the box or sequence object in the Genome. The default is to use the background of the object. If specied a valid color then all the background of sequences will be uniform"
        },
        sma25Color: {
            T: "color",
            M: "Candlestick Plots",
            D: "rgb(255,0,255)",
            C: "The color for the 25 day single moving average"
        },
        cullingThreshold: {
            A: "true",
            T: "integer",
            M: "3D Scatter Plot and Networks",
            D: "1000",
            C: "Number of data point to start culling data"
        },
        outlineBy: {
            T: "string",
            M: "Scatter and One-D Plots",
            D: "false",
            C: "Name of the annotation for the outline when drawing a multidimensional Heatmap"
        },
        titleColor: {
            S: ["subtitle", "subtitleHeight"],
            T: "color",
            M: "Titles",
            D: "rgb(0,0,0)",
            C: "Color for the subtitle"
        },
        setMax2: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Maximum value to set the data in the 2nd axis"
        },
        selectDataModeDescription: {
            O: ["false"],
            T: "option",
            M: "Scatter Plots",
            X: "getZData",
            D: "false",
            C: "Variable label to display when highlihting selected data points that must be in the 'data.z' object"
        },
        setMax: {
            A: "true",
            T: "float",
            M: "Axes",
            D: "null",
            C: "Maximum value to set the data"
        },
        desegregateVariables: {
            S: ["segregateVariables"],
            T: "void",
            M: "Functions",
            C: "Desegregate variables previously segregated based on a variable category (data.z object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        sortVariablesByCategory: {
            S: ["sortDir", "sortVariablesBySample"],
            T: "array",
            M: "Functions",
            X: "getZData",
            C: "Sort the variables by a variable category (data.z object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        tickRotate: {
            T: "integer",
            M: "Ticks and Axis Titles",
            D: "0",
            C: "Rotation for graph ticks in degrees. It could be positive or negative."
        },
        networkLayoutType: {
            O: ["forceDirected", "organic", "radial"],
            T: "option",
            M: "Network Graphs",
            D: "forceDirected",
            C: "Type of network layout."
        },
        zoom: {
            A: "true",
            T: "float",
            M: "Zooming and Panning",
            D: "1",
            C: "Zoom factor for the networks. A number greater than zero"
        },
        initialTemperature: {
            A: "true",
            T: "integer",
            M: "Network Graphs",
            D: "0",
            C: "Initial temperature to limit displacement at later stages of forceDirected and organic layouts. A value based on the number of node and edges will be assigned if not specified"
        },
        citationFont: {
            Z: "true",
            A: "true",
            T: "font",
            M: "Titles",
            C: "Font for the reference citation"
        },
        legendBackgroundColor: {
            S: ["legendBox"],
            T: "color",
            M: "Legends",
            D: "background color",
            C: "Color for the legend background"
        },
        overlayScaleFontFactor: {
            A: "true",
            T: "float",
            M: "Overlays",
            D: "1",
            C: "Scaling factor used to increse or decrease overlays font size in the canvas in one dimensional plots"
        },
        showNetworkNodesLegend: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "true",
            C: "Flag to show node legends in the networks"
        },
        shadowBlur: {
            S: ["showShadow"],
            A: "true",
            T: "integer",
            M: "General",
            D: "2",
            C: "Amount in blur for the shadow."
        },
        varTitleLabelOverlayPosition: {
            O: ["botom", "top"],
            T: "option",
            M: "Variables",
            D: "bottom",
            C: "Position for variable labels in heatmaps"
        },
        remoteAutoPlay: {
            A: "true",
            T: "boolean",
            M: "Remote Procedures",
            D: "false",
            C: "Flag to iterate over remote data sets"
        },
        recalculateLayout: {
            T: "void",
            M: "Functions",
            C: "Recalculate the network layout",
            U: {
                ScatterBubble2D: "true",
                Scatter2D: "true",
                Scatter3D: "true"
            }
        },
        sequenceXColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the any aminoacid code in the genome browser"
        },
        sizeNodeBy: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Name of the attribute to size the nodes."
        },
        overlayFontColor: {
            A: "true",
            T: "color",
            M: "Overlays",
            D: "foregroung color",
            C: "Color for the overlays in one dimensional plots"
        },
        axisTickFontSize: {
            S: ["autoScaleFont", "tickScaleFontFactor"],
            A: "true",
            T: "integer",
            M: "Ticks and Axis Titles",
            D: "10",
            C: "Font size for the axis ticks in one and two dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the tick scaling factor"
        },
        snapshotCopyChangeOnly: {
            A: "true",
            T: "boolean",
            M: "Animation",
            D: "true",
            C: "Flag to indicate whether to copy all or only the changed attributes in the network animation. This optimizes memory usage for snapshots."
        },
        sequenceGColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,0)",
            C: "Color for the guanines and glycines in the genome browser"
        },
        xAxisMinorTicks: {
            A: "true",
            T: "boolean",
            M: "Axes",
            D: "true",
            C: "A flag to show minor tick lines in the X axis"
        },
        legendPosition: {
            O: ["right", "bottom"],
            T: "option",
            M: "Legends",
            D: "right",
            C: "Position for the legend in the graphs"
        },
        dashLength: {
            A: "true",
            T: "integer",
            M: "Attributes",
            D: "8",
            C: "Size in pixels of the length of the dashes and the separation between the dashes in the dashed lines."
        },
        zAxisTitle: {
            T: "string",
            M: "Axes",
            D: "false",
            C: "Title for the Z axis"
        },
        dotPlotJitter: {
            A: "true",
            T: "boolean",
            M: "Dot Plots",
            D: "false",
            C: "Flag to jitter the point in dotplots"
        },
        groupingFactors: {
            T: "array",
            M: "Data",
            X: "getXData",
            D: "[]",
            C: "An array that holds the group names used for grouping the data. It must be a category in the 'data.x' object"
        },
        remoteParentId: {
            Z: "true",
            A: "true",
            T: "string",
            M: "Remote Procedures",
            C: "Id for the parent holding the remoteWindow to prevent id collisions"
        },
        configuratorWidth: {
            A: "true",
            T: "integer",
            M: "Events",
            D: "300",
            C: "Size in pixels for the configurator."
        },
        networkRoot: {
            T: "string",
            M: "Network Graphs",
            D: "false",
            C: "Node Id of the network root."
        },
        translateX: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Amount to translate for the X axis."
        },
        varOverlays: {
            T: "array",
            M: "Overlays",
            X: "getZData",
            D: "[]",
            C: "Variable annotations included in the 'data.z' object used in one dimensional plots"
        },
        z3DRatio: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "1",
            C: "Value between 0 - 1 for adjusting the 3D of the Z Axis"
        },
        filterFeatureBy: {
            T: "filter",
            M: "Genome Browser",
            X: "getFeatureData",
            D: "[]",
            C: "Filter features by their properties used in genome browser      *"
        },
        foreground: {
            T: "color",
            M: "General",
            D: "rgb(0,0,0)",
            C: "Foreground color for the canvas"
        },
        remoteUpdating: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Remote Procedures",
            C: "Flag to indicate that updating data is in progress"
        },
        plotByVariable: {
            T: "boolean",
            M: "One dimentional plots",
            D: "false",
            C: "Flag to indicate whether to group the data variable rather than by sample"
        },
        blockSeparationFactor: {
            S: ["autoAdjust", "blockFactor"],
            A: "true",
            T: "int",
            M: "One dimentional plots",
            D: "1",
            C: "Factor to adjust the spacing between the sample blocks in the one dimensional graphs. The default is 1. If you  want to make the blocks wider apart then increse this parameter (2 is twice as much). This only works if the auto adjust property is set to 'false'"
        },
        rowHeight: {
            A: "true",
            T: "integer",
            M: "Data table",
            D: "100",
            C: "Mumber of pixels for the height of cells in the data table"
        },
        smpHairlineWidth: {
            T: "float",
            M: "One dimentional plots",
            D: "0.3",
            C: "The width for the thin line that appears in the middle of the sample block just for aesthetics."
        },
        scatterType: {
            O: ["false", "line", "bar", "image", "lineImage", "lineStep"],
            T: "option",
            M: "Scatter Plots",
            D: "false",
            C: "Type of scatter plot"
        },
        featureQualityValues: {
            T: "boolean",
            M: "Genome Browser",
            D: "false",
            C: "Flag use to show values for the quality"
        },
        dendrogramHang: {
            T: "boolean",
            M: "Dendrograms",
            D: "false",
            C: "Flag to show or not the nodes in the dendrogram as hanging or not similar to that one in R"
        },
        bar3DInverseWeight: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "1",
            C: "Value for adjusting the thickness of 3D bars. The larger the value the the thinner the bar"
        },
        repulsiveForceFunction: {
            A: "true",
            O: ["square", "log", "pow", "sqrt"],
            T: "option",
            M: "Network Graphs",
            D: "square",
            C: "Type of function to apply when calculating repulsive force in forceDirected network layouts"
        },
        resizerPosition: {
            A: "true",
            O: ["top", "rigth", "bottom", "left"],
            T: "option",
            M: "Axis Resizer",
            D: "bottom",
            C: "Position for the axis resizer in complex plots"
        },
        vennGroups: {
            T: "integer",
            M: "Venn Diagrams",
            D: "4",
            C: "Number of groups in the Venn diagram"
        },
        zAxis: {
            A: "true",
            T: "array",
            M: "Axes",
            D: "[]",
            X: "getSamplesAsArray",
            C: "Name of the samples groups or variables to be displayed in the Z axis"
        },
        lineType: {
            O: ["rect", "spline"],
            T: "option",
            M: "Line Graphs",
            D: "rect",
            C: "Type of line used to join the points in line graphs"
        },
        y3DRatio: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "1",
            C: "Value between 0 - 1 for adjusting the 3D of the Y Axis"
        },
        zscoreAxis: {
            O: ["samples", "variables"],
            T: "option",
            M: "Data",
            D: "samples",
            C: "Default axis to use to zsore the data."
        },
        featureStaggered: {
            T: "boolean",
            M: "Genome Browser",
            D: "false",
            C: "Flag use to stagger the features in the genome panel"
        },
        decorationsWidth: {
            A: "true",
            T: "integer",
            M: "Decorations",
            D: "10",
            C: "Length in pixels of the width for the decorations in the networks"
        },
        rAxisCurrent: {
            A: "true",
            T: "integer",
            M: "Axes",
            D: "0",
            C: "Index of the sample that is currently displayed displayed in the R axis"
        },
        moveParentsWithChildren: {
            A: "true",
            T: "boolean",
            M: "Network Graphs",
            D: "false",
            C: "Flag to make parents move when a child is moved"
        },
        filterVarBy: {
            T: "filter",
            M: "Variables",
            X: "getZData",
            D: "[]",
            C: "Filter variables by their annotation included in the 'data.z' object used in one dimensional plots"
        },
        maxPieSectors: {
            T: "float",
            M: "Pie Charts",
            D: "20",
            C: "Max pie sectors. After that number the sectors will be put in a sector named 'other'."
        },
        yAxisAbsMax: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Maximum unfiltered value for the Y axis"
        },
        xAxisAbsMin: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Minimum unfiltered value for the X axis"
        },
        correlationLabelInterval: {
            A: "true",
            T: "integer",
            M: "Correlation Graphs",
            D: "1",
            C: "Interval for the sample or variable labels in the correlation plot"
        },
        ringSegmentSeparation: {
            T: "int",
            M: "Circular Graphs",
            D: "4",
            C: "Number of degrees to separate the segments in the circular plots"
        },
        networkForceConstant: {
            A: "true",
            T: "float",
            M: "Network Graphs",
            D: "0",
            C: "Constant used for calculating attractive and repulsive forces in forcedDirected and organic layouts. A value based on the average area per node will be assigned if not specified"
        },
        networkShowDataTable: {
            A: "true",
            O: ["nodes", "edges"],
            T: "option",
            M: "Data table",
            D: "nodes",
            C: "Show nodes or edges on data table"
        },
        vennColors: {
            S: ["colors"],
            A: "true",
            T: "array",
            M: "Venn Diagrams",
            D: "[]",
            C: "Colors for the Venn bubles. If not specified the colors will be chosen from the colors array. Colors in this array need to be at least the same number of groups in the Venn diagram"
        },
        overlaysWidth: {
            A: "true",
            T: "integer",
            M: "Overlays",
            D: "30",
            C: "Length in pixels of the width for the colored boxes to clasify samples and or variables in one dimensional plots"
        },
        scaleX: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Combination Plots",
            C: "Scale factor for the X axis"
        },
        "this": {
            Z: "true",
            A: "true",
            T: "time",
            M: "Events",
            C: "Time in milliseconds to keep track of time"
        },
        gradientType: {
            S: ["gradient"],
            A: "true",
            O: ["linear", "radial"],
            T: "option",
            M: "General",
            D: "radial",
            C: "Type of patern used for the gradients applied to all elements in the visualizations"
        },
        allVsAll: {
            T: "boolean",
            M: "2D Scatter Plot",
            D: "false",
            C: "Flag to plot an n-1 x n-1 matrix of 2D sccaterplots"
        },
        showDataValues: {
            T: "boolean",
            M: "Bar Graphs",
            D: "false",
            C: "Flag to indicate whether to show data values in the one bar graphs."
        },
        resizerType: {
            A: "true",
            O: ["false", "samples", "box"],
            T: "option",
            M: "Axis Resizer",
            D: "false",
            C: "String to indicate the type of axis resizer in complex plots"
        },
        featureTracesShow: {
            T: "boolean",
            M: "Genome Browser",
            D: "true",
            C: "Flag use to show traces"
        },
        toolbarPermanent: {
            A: "true",
            T: "boolean",
            M: "Events",
            D: "false",
            C: "Flag to make the toolbar permanently visible."
        },
        decorationsColors: {
            A: "true",
            T: "array",
            M: "Decorations",
            D: "[]",
            C: "Array of colors used for selection in network decorations not to be confused by its singular form 'decorationsColor' above"
        },
        hideUnhideSmps: {
            T: "array",
            M: "Functions",
            X: "getSamplesAsArray",
            C: "Hide or unhide samples. It works like a switch",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                ScatterBubble2D: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Scatter2D: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Scatter3D: "true",
                Area: "true",
                Line: "true",
                AreaLine: "true",
                Heatmap: "true",
                Stacked: "true"
            }
        },
        zAxisAbsMax: {
            Z: "true",
            A: "true",
            T: "float",
            M: "Axes",
            C: "Maximum unfiltered value for the Z axis"
        },
        isMarketSwitched: {
            Z: "true",
            A: "true",
            T: "boolean",
            M: "Data",
            C: "Flag to indicate if the data is a Candlestick."
        },
        imputeMethod: {
            S: ["distance", "linkage", "clusterAxis", "centerData", "clusterSamples", "clusterVariables"],
            O: ["mean", "median"],
            T: "option",
            M: "Clustering",
            D: "mean",
            C: "Imputation method for missing data when clustering"
        },
        randomMissingDataPercentage: {
            A: "true",
            T: "integer",
            M: "Data",
            D: "0",
            C: "Default percentege of missing values when creating random data"
        },
        smpHairline: {
            O: ["false", "solid", "dotted"],
            T: "option",
            M: "One dimentional plots",
            D: "dotted",
            C: "This is a thin line that appears in the middle of the bar graphs just for aesthetics."
        },
        highlightVar: {
            T: "array",
            M: "Variables",
            X: "getVariablesAsArray",
            D: "[]",
            C: "Name of variables in the 'data.y' object to highlight."
        },
        smpOverlayRecycleColors: {
            T: "boolean",
            M: "Overlays",
            D: "false",
            C: "Flag to indicate to recycle sample overlay colors with each overlay"
        },
        sortSamplesByCategory: {
            S: ["sortDir", "sortSamplesByVariable"],
            T: "array",
            M: "Functions",
            X: "getXData",
            C: "Sort the samples by a sample category (data.x object)",
            U: {
                StackedPercent: "true",
                Bar: "true",
                Correletion: "true",
                Pie: "true",
                Barline: "true",
                StackedLine: "true",
                Dotplot: "true",
                Boxplot: "true",
                StackedPercentLine: "true",
                Area: "true",
                Line: "true",
                Stacked: "true",
                Heatmap: "true",
                AreaLine: "true"
            }
        },
        sequenceWColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,0,255)",
            C: "Color for the degenerate A/T and tryptophans in the genome browser"
        },
        ringWeight: {
            T: "array",
            M: "Circular Graphs",
            D: "[]",
            C: "Array containing the dimensions for each ring in the circular plots"
        },
        fontStyle: {
            A: "true",
            O: ["false", "bold", "italic"],
            T: "option",
            M: "Text",
            D: "false",
            C: "Font style. Not implemented yet."
        },
        showBoxplotOriginalData: {
            S: ["dotPlotDataPointRatio", "dotPlotDataPointTransparency"],
            A: "true",
            T: "boolean",
            M: "Box Plots",
            D: "false",
            C: "Flag to show original data in boxplots"
        },
        rAxisTickColor: {
            T: "color",
            M: "Axes",
            D: "rgb(204,204,204)",
            C: "Color for the tick lines in the R axis"
        },
        showVolume: {
            T: "boolean",
            M: "Candlestick Plots",
            D: "true",
            C: "Flag to show or not volume in the candlestick graphs"
        },
        sma10Color: {
            T: "color",
            M: "Candlestick Plots",
            D: "rgb(0,255,0)",
            C: "The color for the 5 day single moving average"
        },
        gradientOrientation: {
            S: ["backgroundType"],
            A: "true",
            O: ["vertical", "horizontal"],
            T: "option",
            M: "General",
            D: "vertical",
            C: "The orientation for the gradient if the background type is windowGradient or windowGradient2."
        },
        refresehDataTableOnDraw: {
            A: "true",
            T: "boolean",
            M: "Data table",
            D: "true",
            C: "Flag to indicate to refresh data after drawing the plot"
        },
        varLabelFontSize: {
            S: ["autoScaleFont", "varLabelScaleFontFactor"],
            A: "true",
            T: "integer",
            M: "Variables",
            D: "10",
            C: "Size for the variable labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the variable label scaling factor"
        },
        smpLabelFontSize: {
            S: ["autoScaleFont", "smpLabelScaleFontFactor"],
            A: "true",
            T: "integer",
            M: "Samples",
            D: "10",
            C: "Size for the sample labels in one dimensional plots. Be aware that auto scaling font must be turned off for this property to take effect. A more convenient way to modify the size is to use the sample label scaling factor"
        },
        maxRotate: {
            A: "true",
            T: "float",
            M: "3D Scatter Plot and Networks",
            D: "false",
            C: "Maximum number of degrees to rotate graph arround axes"
        },
        sequenceAColor: {
            T: "color",
            M: "Genome Browser",
            D: "rgb(0,103,0)",
            C: "Color for the adenines and alanines in the genome browser"
        },
        xAxis2TickFormat: {
            A: "true",
            T: "string",
            M: "Axes",
            D: "false",
            C: "Format for the tick values in the second X axis"
        },
        clusterVariables: {
            S: ["distance", "linkage", "clusterAxis", "imputeMethod", "centerData"],
            T: "void",
            M: "Functions",
            C: "Cluster variables based on data and generate a dendrogram on the variable axis. It takes no parameters",
            U: {
                Heatmap: "true"
            }
        },
        highlightNode: {
            T: "array",
            M: "Network Graphs",
            D: "[]",
            C: "Name of nodes in the 'data.nodes' object to highlight."
        },
        dataEvent: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Events",
            C: "Array to store the areas that will trigger an event"
        },
        snapshots: {
            Z: "true",
            A: "true",
            T: "array",
            M: "Snapshots",
            C: "Array to hold the data used in the animation"
        }
    },
    G: {
        name: {
            T: "string",
            M: "Genome",
            C: "Track name"
        }
    },
    E: {
        exact: {
            T: "boolean",
            M: "Network",
            C: "Flag to indicate to create the edge between nodes without substracting the size of the nodes"
        },
        type: {
            T: "string",
            M: "Network",
            C: "Type of line use to join the nodes"
        },
        width: {
            T: "integer",
            M: "Network",
            C: "Pixel width for the edges between nodes"
        },
        cap: {
            O: "butt, round, square",
            T: "option",
            M: "Network",
            C: "Type of cap for the end of the lines"
        }
    }
};